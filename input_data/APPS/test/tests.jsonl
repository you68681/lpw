{"task_id": "APPS/2590", "prompt": "def max_of_min_2d_array(n: int, m: int, array: List[List[int]]) -> int:\n    \"\"\"\n    =====Function Descriptions=====\n    min\n    \n    The tool min returns the minimum value along a given axis.\n    \n    import numpy\n    \n    my_array = numpy.array([[2, 5],\n    [3, 7],\n    [1, 3],\n    [4, 0]])\n    \n    print numpy.min(my_array, axis = 0)         #Output : [1 0]\n    print numpy.min(my_array, axis = 1)         #Output : [2 3 1 0]\n    print numpy.min(my_array, axis = None)      #Output : 0\n    print numpy.min(my_array)                   #Output : 0\n    \n    By default, the axis value is None. Therefore, it finds the minimum over all the dimensions of the input array.\n    \n    max\n    \n    The tool max returns the maximum value along a given axis.\n    \n    import numpy\n    \n    my_array = numpy.array([[2, 5],\n    [3, 7],\n    [1, 3],\n    [4, 0]])\n    \n    print numpy.max(my_array, axis = 0)         #Output : [4 7]\n    print numpy.max(my_array, axis = 1)         #Output : [5 7 3 4]\n    print numpy.max(my_array, axis = None)      #Output : 7\n    print numpy.max(my_array)                   #Output : 7\n    \n    By default, the axis value is None. Therefore, it finds the maximum over all the dimensions of the input array.\n    \n    =====Problem Statement=====\n    You are given a 2-D array with dimensions NXM.\n    Your task is to perform the min function over axis 1 and then find the max of that.\n    \n    =====Input Format=====\n    The first line of input contains the space separated values of N and M.\n    The next N lines contains M space separated integers.\n    \n    =====Output Format=====\n    Compute the min along axis 1 and then print the max of that result.\n    \"\"\"\n    import numpy as np\n    np_array = np.array(array)\n    min_values = np.min(np_array, axis=1)\n    return np.max(min_values)\n", "entry_point": "max_of_min_2d_array", "test": "\ndef check(candidate):\n    assert candidate(4, 2, [[2, 5], [3, 7], [1, 3], [4, 0]]) == 3\ncheck(max_of_min_2d_array)\n", "given_tests": ["assert max_of_min_2d_array(4, 2, [[2, 5], [3, 7], [1, 3], [4, 0]]) == 3"], "canonical_solution": "[\"import numpy\\nn,m = list(map(int,input().split()))\\nar = []\\nfor i in range(n):\\n    tmp = list(map(int,input().split()))\\n    ar.append(tmp)\\nnp_ar = numpy.array(ar)\\nprint((numpy.max(numpy.min(np_ar,axis=1))))\\n\", \"import numpy as np\\n\\nn, m = [int(x) for x in input().strip().split()]\\narray = np.array([[int(x) for x in input().strip().split()] for _ in range(n)])\\nprint(np.max(np.min(array, axis = 1)))\"]", "difficulty": "introductory"}
{"task_id": "APPS/3239", "prompt": "def guess_hat_color(a: str, b: str, c: str, d: str) -> int:\n    \"\"\"\n    # Task\n    Four men, `a, b, c and d` are standing in a line, one behind another.\n    \n    There's a wall between the first three people (a, b and c) and the last one (d).\n    \n    a, b and c are lined up in order of height, so that person a can see the backs of b and c, person b can see the back of c, and c can see just the wall.\n    \n    There are 4 hats, 2 black and 2 white. Each person is given a hat. None of them can see their own hat, but person a can see the hats of b and c, while person b can see the hat of person c. Neither c nor d can see any hats.\n    \n    Once a person figures out their hat's color, they shouts it.\n    \n    ![](http://stuffbox.in/wp-content/uploads/2016/08/Guess-hat-colour-604x270.png)\n    \n    Your task is to return the person who will guess their hat first. You can assume that they will speak only when they reach a correct conclusion.\n    \n    # Input/Output\n    \n    \n    - `[input]` string `a`\n    \n    a's hat color (\"white\" or \"black\").\n    \n    \n    - `[input]` string `b`\n    \n    b's hat color (\"white\" or \"black\").\n    \n    \n    - `[input]` string `c`\n    \n    c's hat color (\"white\" or \"black\").\n    \n    \n    - `[input]` string `d`\n    \n    d's hat color (\"white\" or \"black\").\n    \n    \n    - `[output]` an integer\n    \n    The person to guess his hat's color first, `1 for a, 2 for b, 3 for c and 4 for d`.\n    \"\"\"\n", "entry_point": "guess_hat_color", "test": "\ndef check(candidate):\n    assert candidate('white', 'black', 'white', 'black') == 2\n    assert candidate('white', 'black', 'black', 'white') == 1\ncheck(guess_hat_color)\n", "given_tests": ["assert guess_hat_color('white', 'black', 'white', 'black') == 2"], "canonical_solution": ["def guess_hat_color(a, b, c, d): return 1 if b == c else 2"], "difficulty": "introductory"}
{"task_id": "APPS/2468", "prompt": "def tictactoe(moves: List[List[int]]) -> str:\n    \"\"\"\n    Tic-tac-toe is played\u00a0by\u00a0two players A and B on a\u00a03\u00a0x\u00a03\u00a0grid.\n    Here are the rules of Tic-Tac-Toe:\n    \n    Players take turns placing characters into empty squares (\" \").\n    The first player A always places \"X\" characters, while the second player B\u00a0always places \"O\" characters.\n    \"X\" and \"O\" characters are always placed into empty squares, never on filled ones.\n    The game ends when there are 3 of the same (non-empty) character filling any row, column, or diagonal.\n    The game also ends if all squares are non-empty.\n    No more moves can be played if the game is over.\n    \n    Given an array moves where each element\u00a0is another array of size 2 corresponding to the row and column of the grid where they mark their respective character in the order in which A and B play.\n    Return the winner of the game if it exists (A or B), in case the game ends in a draw return \"Draw\", if there are still movements to play return \"Pending\".\n    You can assume that\u00a0moves is\u00a0valid (It follows the rules of Tic-Tac-Toe),\u00a0the grid is initially empty and A will play first.\n    \n    Example 1:\n    Input: moves = [[0,0],[2,0],[1,1],[2,1],[2,2]]\n    Output: \"A\"\n    Explanation: \"A\" wins, he always plays first.\n    \"X  \"    \"X  \"    \"X  \"    \"X  \"    \"X  \"\n    \"   \" -> \"   \" -> \" X \" -> \" X \" -> \" X \"\n    \"   \"    \"O  \"    \"O  \"    \"OO \"    \"OOX\"\n    \n    Example 2:\n    Input: moves = [[0,0],[1,1],[0,1],[0,2],[1,0],[2,0]]\n    Output: \"B\"\n    Explanation: \"B\" wins.\n    \"X  \"    \"X  \"    \"XX \"    \"XXO\"    \"XXO\"    \"XXO\"\n    \"   \" -> \" O \" -> \" O \" -> \" O \" -> \"XO \" -> \"XO \"\n    \"   \"    \"   \"    \"   \"    \"   \"    \"   \"    \"O  \"\n    \n    Example 3:\n    Input: moves = [[0,0],[1,1],[2,0],[1,0],[1,2],[2,1],[0,1],[0,2],[2,2]]\n    Output: \"Draw\"\n    Explanation: The game ends in a draw since there are no moves to make.\n    \"XXO\"\n    \"OOX\"\n    \"XOX\"\n    \n    Example 4:\n    Input: moves = [[0,0],[1,1]]\n    Output: \"Pending\"\n    Explanation: The game has not finished yet.\n    \"X  \"\n    \" O \"\n    \"   \"\n    \n    \n    Constraints:\n    \n    1 <= moves.length <= 9\n    moves[i].length == 2\n    0 <= moves[i][j] <= 2\n    There are no repeated elements on moves.\n    moves follow the rules of tic tac toe.\n    \"\"\"\n", "entry_point": "tictactoe", "test": "\ndef check(candidate):\n    assert candidate([[0, 0], [2, 0], [1, 1], [2, 1], [2, 2]]) == 'A'\n    assert candidate([[0, 0], [1, 1], [0, 1], [0, 2], [1, 0], [2, 0]]) == 'B'\n    assert candidate([[0, 0], [1, 1], [2, 0], [1, 0], [1, 2], [2, 1], [0, 1], [0, 2], [2, 2]]) == 'Draw'\n    assert candidate([[0, 0], [1, 1]]) == 'Pending'\ncheck(tictactoe)\n", "given_tests": ["assert tictactoe([[0, 0], [2, 0], [1, 1], [2, 1], [2, 2]]) == 'A'", "assert tictactoe([[0, 0], [1, 1], [0, 1], [0, 2], [1, 0], [2, 0]]) == 'B'", "assert tictactoe([[0, 0], [1, 1], [2, 0], [1, 0], [1, 2], [2, 1], [0, 1], [0, 2], [2, 2]]) == 'Draw'", "assert tictactoe([[0, 0], [1, 1]]) == 'Pending'"], "canonical_solution": ["class Solution:\\n    def tictactoe(self, moves: List[List[int]]) -> str:\\n        # player one and two moves\\n        player_a, player_b = moves[0::2], moves[1::2]\\n\\n        # possible wins\\n        possible_wins = {\\n            0: [[0, 0], [1, 1], [2, 2]],\\n            1: [[0, 0], [1, 0], [2, 0]],\\n            2: [[0, 1], [1, 1], [2, 1]],\\n            3: [[0, 2], [1, 2], [2, 2]],\\n            4: [[0, 0], [0, 1], [0, 2]],\\n            5: [[1, 0], [1, 1], [1, 2]],\\n            6: [[2, 0], [2, 1], [2, 2]],\\n            7: [[0, 2], [1, 1], [2, 0]]\\n        }\\n\\n        # count player one and two correct moves\\n        for possible_win in list(possible_wins.values()):\\n            count_a = 0\\n            for move in player_a:\\n                if move in possible_win:\\n                    count_a += 1\\n                if count_a == 3:\\n                    return 'A'\\n\\n            count_b = 0\\n            for move in player_b:\\n                if move in possible_win:\\n                    count_b += 1\\n                if count_b == 3:\\n                    return 'B'\\n\\n        return 'Draw' if len(player_a) + len(player_b) == 9 else 'Pending'\\n"], "difficulty": "introductory"}
{"task_id": "APPS/3231", "prompt": "def case_unification(s: str) -> str:\n    \"\"\"\n    # Task\n    Given an initial string `s`, switch case of the minimal possible number of letters to make the whole string written in the upper case or in the lower case.\n    \n    # Input/Output\n    \n    \n    `[input]` string `s`\n    \n    String of odd length consisting of English letters.\n    \n    3 \u2264 inputString.length \u2264 99.\n    \n    `[output]` a string\n    \n    The resulting string.\n    \n    # Example\n    \n    For `s = \"Aba\"`, the output should be `\"aba\"`\n    \n    For `s = \"ABa\"`, the output should be `\"ABA\"`\n    \"\"\"\n", "entry_point": "case_unification", "test": "\ndef check(candidate):\n    assert candidate('asdERvT') == 'asdervt'\n    assert candidate('oyTYbWQ') == 'OYTYBWQ'\n    assert candidate('bbiIRvbcW') == 'bbiirvbcw'\n    assert candidate('rWTmvcoRWEWQQWR') == 'RWTMVCORWEWQQWR'\ncheck(case_unification)\n", "given_tests": ["assert case_unification('Aba') == 'aba'", "assert case_unification('ABa') == 'ABA'"], "canonical_solution": ["def case_unification(s):", "    return s.lower() if sum(1 for i in s if i.islower()) > sum(1 for i in s if i.isupper()) else s.upper()"], "difficulty": "introductory"}
{"task_id": "APPS/2961", "prompt": "def complete_series(a: List[int]) -> List[int]:\n    \"\"\"\n    You are given an array of non-negative integers, your task is to complete the series from 0 to the highest number in the array.\n    \n    If the numbers in the sequence provided are not in order you should order them, but if a value repeats, then you must return a sequence with only one item, and the value of that item must be 0. like this:\n    ```\n    inputs        outputs\n    [2,1]     ->  [0,1,2]\n    [1,4,4,6] ->  [0]\n    ```\n    Notes: all numbers are positive integers.\n    \n    This is set of example outputs based on the input sequence.\n    ```\n    inputs        outputs\n    [0,1]   ->    [0,1]\n    [1,4,6] ->    [0,1,2,3,4,5,6]\n    [3,4,5] ->    [0,1,2,3,4,5]\n    [0,1,0] ->    [0]\n    ```\n    \"\"\"\n", "entry_point": "complete_series", "test": "\ndef check(candidate):\n    assert candidate([0, 1]) == [0, 1]\n    assert candidate([1, 4, 6]) == [0, 1, 2, 3, 4, 5, 6]\n    assert candidate([3, 4, 5]) == [0, 1, 2, 3, 4, 5]\n    assert candidate([2, 1]) == [0, 1, 2]\n    assert candidate([1, 4, 4, 6]) == [0]\ncheck(complete_series)\n", "given_tests": ["assert complete_series([0, 1]) == [0, 1]", "assert complete_series([1, 4, 6]) == [0, 1, 2, 3, 4, 5, 6]", "assert complete_series([3, 4, 5]) == [0, 1, 2, 3, 4, 5]", "assert complete_series([0, 1, 0]) == [0]", "assert complete_series([2, 1]) == [0, 1, 2]", "assert complete_series([1, 4, 4, 6]) == [0]"], "canonical_solution": ["def complete_series(a):", "    return list(range(max(a) + 1)) if len(a) == len(set(a)) else [0]"], "difficulty": "introductory"}
{"task_id": "APPS/3813", "prompt": "def does_fred_need_houseboat(x: int, y: int) -> int:\n    \"\"\"\n    # Task\n    Fred Mapper is considering purchasing some land in Louisiana to build his house on. In the process of investigating the land, he learned that the state of Louisiana is actually shrinking by 50 square miles each year, due to erosion caused by the Mississippi River. Since Fred is hoping to live in this house the rest of his life, he needs to know if his land is going to be lost to erosion.\n    \n    After doing more research, Fred has learned that the land that is being lost forms a semicircle. This semicircle is part of a circle centered at (0,0), with the line that bisects the circle being the `x` axis. Locations below the `x` axis are in the water. The semicircle has an area of 0 at the beginning of year 1. (Semicircle illustrated in the Figure.)\n    \n    ![](http://media.openjudge.cn/images/1005/semicircle.GIF)\n    \n    Given two coordinates `x` and `y`, your task is to calculate that Fred Mapper's house will begin eroding in how many years.\n    \n    Note:\n    \n    1. No property will appear exactly on the semicircle boundary: it will either be inside or outside.\n    \n    2. All locations are given in miles.\n    \n    3. (0,0) will not be given.\n    \n    # Example\n    \n    For `x = 1, y = 1`, the result should be `1`.\n    \n    After 1 year, Fred Mapper's house will begin eroding.\n    \n    For `x = 25, y = 0`, the result should be `20`.\n    \n    After 20 year, Fred Mapper's house will begin eroding.\n    \n    # Input/Output\n    \n    \n    - `[input]` integer `x`\n    \n    The X coordinates of the land Fred is considering. It will be an integer  point numbers measured in miles.\n    \n    `-100 <= x <= 100`\n    \n    \n    - `[input]` integer `y`\n    \n    The Y coordinates of the land Fred is considering. It will be an integer point numbers measured in miles.\n    \n    `0 <= y <= 100`\n    \n    \n    - `[output]` an integer\n    \n    The first year (start from 1) this point will be within the semicircle AT THE END OF YEAR.\n    \"\"\"\n", "entry_point": "does_fred_need_houseboat", "test": "\ndef check(candidate):\n    assert candidate(1, 1) == 1\n    assert candidate(25, 0) == 20\ncheck(does_fred_need_houseboat)\n", "given_tests": ["assert does_fred_need_houseboat(1, 1) == 1", "assert does_fred_need_houseboat(25, 0) == 20"], "canonical_solution": ["from math import ceil, pi; def does_fred_need_houseboat(x, y): return ceil(pi * (x**2 + y**2) / 100)"], "difficulty": "introductory"}
{"task_id": "APPS/3513", "prompt": "def folding(a: int, b: int) -> int:\n    \"\"\"\n    # Task\n    John was in math class and got bored, so he decided to fold some origami from a rectangular `a \u00d7 b` sheet of paper (`a > b`). His first step is to make a square piece of paper from the initial rectangular piece of paper by folding the sheet along the bisector of the right angle and cutting off the excess part.\n    \n    \n    \n    After moving the square piece of paper aside, John wanted to make even more squares! He took the remaining (`a-b`) \u00d7 `b` strip of paper and went on with the process until he was left with a square piece of paper.\n    \n    Your task is to determine how many square pieces of paper John can make.\n    \n    # Example:\n    \n    For: `a = 2, b = 1`, the output should be `2`.\n    \n    Given `a = 2` and `b = 1`, John can fold a `1 \u00d7 1` then another `1 \u00d7 1`.\n    \n    So the answer is `2`.\n    \n    For: `a = 10, b = 7`, the output should be `6`.\n    \n    We are given `a = 10` and `b = 7`. The following is the order of squares John folds: `7 \u00d7 7, 3 \u00d7 3, 3 \u00d7 3, 1 \u00d7 1, 1 \u00d7 1, and 1 \u00d7 1`.\n    \n    Here are pictures for the example cases.\n    \n    \n    \n    # Input/Output\n    \n    \n    - `[input]` integer `a`\n    \n    `2 \u2264 a \u2264 1000`\n    \n    \n    - `[input]` integer `b`\n    \n    `1 \u2264 b < a \u2264 1000`\n    \n    \n    - `[output]` an integer\n    \n    The maximum number of squares.\n    \"\"\"\n", "entry_point": "folding", "test": "\ndef check(candidate):\n    assert candidate(2, 1) == 2\n    assert candidate(10, 7) == 6\n    assert candidate(3, 1) == 3\n    assert candidate(4, 1) == 4\n    assert candidate(3, 2) == 3\n    assert candidate(4, 2) == 2\n    assert candidate(1000, 700) == 6\n    assert candidate(1000, 999) == 1000\ncheck(folding)\n", "given_tests": ["assert folding(2, 1) == 2", "assert folding(10, 7) == 6"], "canonical_solution": ["def folding(a, b): return 0 if b == 0 else a // b + folding(b, a % b)"], "difficulty": "introductory"}
{"task_id": "APPS/4035", "prompt": "def substring_test(first: str, second: str) -> bool:\n    \"\"\"\n    Given 2 strings, your job is to find out if there is a substring that appears in both strings. You will return true if you find a substring that appears in both strings, or false if you do not. We only care about substrings that are longer than one letter long.\n    \n    #Examples:\n    \n    ````\n    *Example 1*\n    SubstringTest(\"Something\",\"Fun\"); //Returns false\n    \n    *Example 2*\n    SubstringTest(\"Something\",\"Home\"); //Returns true\n    ````\n    In the above example, example 2 returns true because both of the inputs contain the substring \"me\". (so**ME**thing and ho**ME**)\n    In example 1, the method will return false because something and fun contain no common substrings. (We do not count the 'n' as a substring in this Kata because it is only 1 character long)\n    \n    #Rules:\n    Lowercase and uppercase letters are the same. So 'A' == 'a'.\n    We only count substrings that are > 1 in length.\n    \n    #Input:\n    Two strings with both lower and upper cases.\n    #Output:\n    A boolean value determining if there is a common substring between the two inputs.\n    \"\"\"\n", "entry_point": "substring_test", "test": "\ndef check(candidate):\n    assert candidate('Something', 'Home') == True\n    assert candidate('Something', 'Fun') == False\n    assert candidate('Something', '') == False\n    assert candidate('', 'Something') == False\n    assert candidate('BANANA', 'banana') == True\n    assert candidate('test', 'lllt') == False\n    assert candidate('', '') == False\n    assert candidate('1234567', '541265') == True\n    assert candidate('supercalifragilisticexpialidocious', 'SoundOfItIsAtrocious') == True\n    assert candidate('LoremipsumdolorsitametconsecteturadipiscingelitAeneannonaliquetligulautplaceratorciSuspendissepotentiMorbivolutpatauctoripsumegetaliquamPhasellusidmagnaelitNullamerostellustemporquismolestieaornarevitaediamNullaaliquamrisusnonviverrasagittisInlaoreetultricespretiumVestibulumegetnullatinciduntsempersemacrutrumfelisPraesentpurusarcutempusnecvariusidultricesaduiPellentesqueultriciesjustolobortisrhoncusdignissimNuncviverraconsequatblanditUtbibendumatlacusactristiqueAliquamimperdietnuncsempertortorefficiturviverra', 'thisisalongstringtest') == True\n    assert candidate('Codewars is sweet!', 'is') == True\ncheck(substring_test)\n", "given_tests": ["assert substring_test('Something', 'Fun') == False", "assert substring_test('Something', 'Home') == True"], "canonical_solution": "[\"def substring_test(first, second): first = first.lower(); second = second.lower(); for i in range(len(first) - 2): if first[i:i+2] in second: return True; return False\"]", "difficulty": "introductory"}
{"task_id": "APPS/2905", "prompt": "def nickname_generator(name: str) -> str:\n    \"\"\"\n    Nickname Generator\n    \n    Write a function, `nicknameGenerator` that takes a string name as an argument and returns the first 3 or 4 letters as a nickname.\n    \n    If the 3rd letter is a consonant, return the first 3 letters.\n    \n    If the 3rd letter is a vowel, return the first 4 letters.\n    \n    If the string is less than 4 characters, return \"Error: Name too short\".\n    \n    **Notes:**\n    \n    - Vowels are \"aeiou\", so discount the letter \"y\".\n    - Input will always be a string.\n    - Input will always have the first letter capitalised and the rest lowercase (e.g. Sam).\n    - The input can be modified\n    \"\"\"\n", "entry_point": "nickname_generator", "test": "\ndef check(candidate):\n    assert candidate('Jimmy') == 'Jim'\n    assert candidate('Samantha') == 'Sam'\n    assert candidate('Sam') == 'Error: Name too short'\n    assert candidate('Kayne') == 'Kay'\n    assert candidate('Melissa') == 'Mel'\n    assert candidate('James') == 'Jam'\n    assert candidate('Gregory') == 'Greg'\n    assert candidate('Jeannie') == 'Jean'\n    assert candidate('Kimberly') == 'Kim'\n    assert candidate('Timothy') == 'Tim'\n    assert candidate('Dani') == 'Dan'\n    assert candidate('Saamy') == 'Saam'\n    assert candidate('Saemy') == 'Saem'\n    assert candidate('Saimy') == 'Saim'\n    assert candidate('Saomy') == 'Saom'\n    assert candidate('Saumy') == 'Saum'\n    assert candidate('Boyna') == 'Boy'\n    assert candidate('Kiyna') == 'Kiy'\n    assert candidate('Sayma') == 'Say'\n    assert candidate('Ni') == 'Error: Name too short'\n    assert candidate('Jam') == 'Error: Name too short'\n    assert candidate('Suv') == 'Error: Name too short'\ncheck(nickname_generator)\n", "given_tests": ["assert nickname_generator('Robert') == 'Rob'", "assert nickname_generator('Jeannie') == 'Jean'"], "canonical_solution": "[\"def nickname_generator(name): return \\\"Error: Name too short\\\" if len(name) < 4 else name[:3+(name[2] in \\\"aeiou\\\")]\", \"def nickname_generator(name): return name[:3+(name[2] in 'aeiou')] if len(name) > 3 else 'Error: Name too short'\", \"def nickname_generator(name): return \\\"Error: Name too short\\\" if len(name) < 4 else name[:4] if name[2] in \\\"aeiou\\\" else name[:3]\", \"def nickname_generator(name): if len(name) < 4: return \\\"Error: Name too short\\\" elif name[2] not in 'aeiou': return name[:3] elif name[2] in 'aeiou': return name[:4]\", \"def nickname_generator(name): VOWELS = 'aeiou' if len(name) < 4: return 'Error: Name too short' if name[2] in VOWELS: return name[:4] else: return name[:3]\", \"is_vowel = set(\\\"aeiou\\\").__contains__ def nickname_generator(name): if len(name) < 4: return \\\"Error: Name too short\\\" # Take that Yu, Lee, Bob, and others! if is_vowel(name[2]): return name[:4] return name[:3]\", \"def nickname_generator(name): if len(name) > 3: return name[:4] if name[2] in 'aeiou' else name[:3] else: return 'Error: Name too short'\", \"def nickname_generator(name): return (name[:4] if name[2] in \\\"aeiou\\\" else name[:3]) if len(name) > 3 else \\\"Error: Name too short\\\"\", \"def nickname_generator(name): VOWELS = 'aeiou' if len(name) < 4: return 'Error: Name too short' if name[2] in VOWELS: return name[:4] return name[:3]\", \"def nickname_generator(name): if len(name) < 4: return 'Error: Name too short' return name[: 4 if name[2] in 'aeiou' else 3]\"]", "difficulty": "introductory"}
{"task_id": "APPS/4907", "prompt": "def candles(candlesNumber: int, makeNew: int) -> int:\n    \"\"\"\n    # Task\n    When a candle finishes burning it leaves a leftover. makeNew leftovers can be combined to make a new candle, which, when burning down, will in turn leave another leftover.\n    \n    You have candlesNumber candles in your possession. What's the total number of candles you can burn, assuming that you create new candles as soon as you have enough leftovers?\n    \n    # Example\n    \n    For candlesNumber = 5 and makeNew = 2, the output should be `9`.\n    \n    Here is what you can do to burn 9 candles:\n    ```\n    burn 5 candles, obtain 5 leftovers;\n    create 2 more candles, using 4 leftovers (1 leftover remains);\n    burn 2 candles, end up with 3 leftovers;\n    create another candle using 2 leftovers (1 leftover remains);\n    burn the created candle, which gives another leftover (2 leftovers in total);\n    create a candle from the remaining leftovers;\n    burn the last candle.\n    Thus, you can burn 5 + 2 + 1 + 1 = 9 candles, which is the answer.\n    ```\n    \n    # Input/Output\n    \n    \n    - `[input]` integer `candlesNumber`\n    \n    The number of candles you have in your possession.\n    \n    Constraints: 1 \u2264 candlesNumber \u2264 50.\n    \n    \n    - `[input]` integer `makeNew`\n    \n    The number of leftovers that you can use up to create a new candle.\n    \n    Constraints: 2 \u2264 makeNew \u2264 5.\n    \n    \n    - `[output]` an integer\n    \"\"\"\n", "entry_point": "candles", "test": "\ndef check(candidate):\n    assert candidate(5, 2) == 9\ncheck(candles)\n", "given_tests": ["assert candles(5, 2) == 9"], "canonical_solution": "[\"def candles(candlesNumber, makeNew):\\n    total_burnt = candlesNumber\\n    leftovers = candlesNumber\\n    while leftovers >= makeNew:\\n        new_candles = leftovers // makeNew\\n        total_burnt += new_candles\\n        leftovers = new_candles + (leftovers % makeNew)\\n    return total_burnt\", \"def candles(m, n):\\n    total = m\\n    leftovers = m\\n    while leftovers >= n:\\n        new_candles = leftovers // n\\n        total += new_candles\\n        leftovers = new_candles + (leftovers % n)\\n    return total\", \"def candles(a, b):\\n    total = a\\n    leftovers = a\\n    while leftovers >= b:\\n        new_candles = leftovers // b\\n        total += new_candles\\n        leftovers = new_candles + (leftovers % b)\\n    return total\"]", "difficulty": "introductory"}
{"task_id": "APPS/3776", "prompt": "def segment_cover(A: List[int], L: int) -> int:\n    \"\"\"\n    # Task\n    Given some points(array `A`) on the same line, determine the minimum number of line segments with length `L` needed to cover all of the given points. A point is covered if it is located inside some segment or on its bounds.\n    \n    # Example\n    \n    For `A = [1, 3, 4, 5, 8]` and `L = 3`, the output should be `2`.\n    \n    Check out the image below for better understanding:\n    \n    ![](https://codefightsuserpics.s3.amazonaws.com/tasks/segmentCover/img/example.png?_tm=1474900035857)\n    \n    \n    For `A = [1, 5, 2, 4, 3]` and `L = 1`, the output should be `3`.\n    \n    segment1: `1-2`(covered points 1,2),\n    \n    segment2: `3-4`(covered points 3,4),\n    \n    segment3: `5-6`(covered point 5)\n    \n    For `A = [1, 10, 100, 1000]` and `L = 1`, the output should be `4`.\n    \n    segment1: `1-2`(covered point 1),\n    \n    segment2: `10-11`(covered point 10),\n    \n    segment3: `100-101`(covered point 100),\n    \n    segment4: `1000-1001`(covered point 1000)\n    \n    \n    # Input/Output\n    \n    \n    - `[input]` integer array A\n    \n    Array of point coordinates on the line (all points are different).\n    \n    Constraints:\n    \n    `1 \u2264 A.length \u2264 50,`\n    \n    `-5000 \u2264 A[i] \u2264 5000.`\n    \n    \n    - `[input]` integer `L`\n    \n    Segment length, a positive integer.\n    \n    Constraints: `1 \u2264 L \u2264 100.`\n    \n    \n    - `[output]` an integer\n    \n    The minimum number of line segments that can cover all of the given points.\n    \"\"\"\n", "entry_point": "segment_cover", "test": "\ndef check(candidate):\n    assert candidate([1, 3, 4, 5, 8], 3) == 2\n    assert candidate([-7, -2, 0, -1, -6, 7, 3, 4], 4) == 3\n    assert candidate([1, 5, 2, 4, 3], 1) == 3\n    assert candidate([1, 10, 100, 1000], 1) == 4\ncheck(segment_cover)\n", "given_tests": ["assert segment_cover([1, 3, 4, 5, 8], 3) == 2"], "canonical_solution": ["def segment_cover(A, L):\n  n=1\n  s=min(A)\n  for i in sorted(A):\n      if s+L<i:\n          s=i\n          n+=1\n  return n"], "difficulty": "introductory"}
{"task_id": "APPS/2718", "prompt": "def timed_reading(max_length: int, text: str) -> int:\n    \"\"\"\n    # Task\n    Timed Reading is an educational tool used in many schools to improve and advance reading skills. A young elementary student has just finished his very first timed reading exercise. Unfortunately he's not a very good reader yet, so whenever he encountered a word longer than maxLength, he simply skipped it and read on.\n    \n    Help the teacher figure out how many words the boy has read by calculating the number of words in the text he has read, no longer than maxLength.\n    \n    Formally, a word is a substring consisting of English letters, such that characters to the left of the leftmost letter and to the right of the rightmost letter are not letters.\n    \n    # Example\n    \n    For `maxLength = 4` and `text = \"The Fox asked the stork, 'How is the soup?'\"`, the output should be `7`\n    \n    The boy has read the following words: `\"The\", \"Fox\", \"the\", \"How\", \"is\", \"the\", \"soup\".`\n    \n    # Input/Output\n    \n    \n    - `[input]` integer `maxLength`\n    \n    A positive integer, the maximum length of the word the boy can read.\n    \n    Constraints: `1 \u2264 maxLength \u2264 10.`\n    \n    \n    - `[input]` string `text`\n    \n    A non-empty string of English letters and punctuation marks.\n    \n    \n    - `[output]` an integer\n    \n    The number of words the boy has read.\n    \"\"\"\n", "entry_point": "timed_reading", "test": "\ndef check(candidate):\n    assert candidate(4, 'The Fox asked the stork, How is the soup?') == 7\n    assert candidate(1, '...') == 0\n    assert candidate(3, 'This play was good for us.') == 3\n    assert candidate(3, 'Suddenly he stopped, and glanced up at the houses') == 5\n    assert candidate(6, 'Zebras evolved among the Old World horses within the last four million years.') == 11\n    assert candidate(5, 'Although zebra species may have overlapping ranges, they do not interbreed.') == 6\n    assert candidate(1, 'Oh!') == 0\n    assert candidate(5, 'Now and then, however, he is horribly thoughtless, and seems to take a real delight in giving me pain.') == 14\ncheck(timed_reading)\n", "given_tests": ["assert timed_reading(4, 'The Fox asked the stork, How is the soup?') == 7"], "canonical_solution": ["import re\ndef timed_reading(max_length, text):\n    return sum(len(i) <= max_length for i in re.findall('\\w+', text))"], "difficulty": "introductory"}
{"task_id": "APPS/3351", "prompt": "def evil_code_medal(user_time: str, gold: str, silver: str, bronze: str) -> str:\n    \"\"\"\n    # Task\n    `EvilCode` is a game similar to `Codewars`. You have to solve programming tasks as quickly as possible. However, unlike `Codewars`, `EvilCode` awards you with a medal, depending on the time you took to solve the task.\n    \n    To get a medal, your time must be (strictly) inferior to the time corresponding to the medal. You can be awarded `\"Gold\", \"Silver\" or \"Bronze\"` medal, or `\"None\"` medal at all. Only one medal (the best achieved) is awarded.\n    \n    You are given the time achieved for the task and the time corresponding to each medal. Your task is to return the awarded medal.\n    \n    Each time is given in the format `HH:MM:SS`.\n    \n    \n    # Input/Output\n    \n    `[input]` string `userTime`\n    \n    The time the user achieved.\n    \n    `[input]` string `gold`\n    \n    The time corresponding to the gold medal.\n    \n    `[input]` string `silver`\n    \n    The time corresponding to the silver medal.\n    \n    `[input]` string `bronze`\n    \n    The time corresponding to the bronze medal.\n    \n    It is guaranteed that `gold < silver < bronze`.\n    \n    `[output]` a string\n    \n    The medal awarded, one of for options: `\"Gold\", \"Silver\", \"Bronze\" or \"None\"`.\n    \n    # Example\n    \n    For\n    ```\n    userTime = \"00:30:00\", gold = \"00:15:00\",\n    silver = \"00:45:00\" and bronze = \"01:15:00\"```\n    \n    the output should be `\"Silver\"`\n    \n    For\n    ```\n    userTime = \"01:15:00\", gold = \"00:15:00\",\n    silver = \"00:45:00\" and bronze = \"01:15:00\"```\n    \n    the output should be `\"None\"`\n    \n    # For Haskell version\n    ```\n    In Haskell, the result is a Maybe, returning Just String indicating\n    the medal if they won or Nothing if they don't.\n    ```\n    \"\"\"\n", "entry_point": "evil_code_medal", "test": "\ndef check(candidate):\n    assert candidate(\"00:30:00\", \"00:15:00\", \"00:45:00\", \"01:15:00\") == \"Silver\"\n    assert candidate(\"01:15:00\", \"00:15:00\", \"00:45:00\", \"01:15:00\") == \"None\"\n    assert candidate(\"00:00:01\", \"00:00:10\", \"00:01:40\", \"01:00:00\") == \"Gold\"\n    assert candidate(\"00:10:01\", \"00:00:10\", \"00:01:40\", \"01:00:00\") == \"Bronze\"\n    assert candidate(\"00:00:01\", \"00:00:02\", \"00:00:03\", \"00:00:04\") == \"Gold\"\n    assert candidate(\"90:00:01\", \"60:00:02\", \"70:00:03\", \"80:00:04\") == \"None\"\n    assert candidate(\"03:15:00\", \"03:15:00\", \"03:15:01\", \"03:15:02\") == \"Silver\"\n    assert candidate(\"99:59:58\", \"99:59:57\", \"99:59:58\", \"99:59:59\") == \"Bronze\"\n    assert candidate(\"14:49:03\", \"77:39:08\", \"92:11:36\", \"94:07:41\") == \"Gold\"\n    assert candidate(\"61:01:40\", \"64:19:53\", \"79:30:02\", \"95:24:48\") == \"Gold\"\ncheck(evil_code_medal)\n", "given_tests": ["assert evil_code_medal(\"00:30:00\", \"00:15:00\", \"00:45:00\", \"01:15:00\") == \"Silver\""], "canonical_solution": ["def evil_code_medal(user_time, gold, silver, bronze):\n    for medal, time in [[\"Gold\", gold], [\"Silver\", silver], [\"Bronze\", bronze]]:\n        if user_time < time:\n            return medal\n    return \"None\""], "difficulty": "introductory"}
{"task_id": "APPS/4630", "prompt": "def decrypt(s: str) -> str:\n    \"\"\"\n    # Task\n    Smartphones software security has become a growing concern related to mobile telephony. It is particularly important as it relates to the security of available personal information.\n    \n    For this reason, Ahmed decided to encrypt phone numbers of contacts in such a way that nobody can decrypt them. At first he tried encryption algorithms very complex, but the decryption process is tedious, especially when he needed to dial a speed dial.\n    \n    He eventually found the algorithm following: instead of writing the number itself, Ahmed multiplied by 10, then adds the result to the original number.\n    \n    For example, if the phone number is `123`, after the transformation, it becomes `1353`. Ahmed truncates the result (from the left), so it has as many digits as the original phone number. In this example Ahmed wrote `353` instead of `123` in his smart phone.\n    \n    Ahmed needs a program to recover the original phone number from number stored on his phone. The program return \"impossible\" if the initial number can not be calculated.\n    \n    Note: There is no left leading zero in either the input or the output; Input `s` is given by string format, because it may be very huge ;-)\n    \n    # Example\n    \n    For `s=\"353\"`, the result should be `\"123\"`\n    \n    ```\n    1230\n    +  123\n    .......\n    = 1353\n    \n    truncates the result to 3 digit -->\"353\"\n    \n    So the initial number is \"123\"\n    ```\n    For `s=\"123456\"`, the result should be `\"738496\"`\n    \n    ```\n    7384960\n    +  738496\n    .........\n    = 8123456\n    \n    truncates the result to 6 digit -->\"123456\"\n    \n    So the initial number is \"738496\"\n    ```\n    For `s=\"4334\"`, the result should be `\"impossible\"`\n    \n    Because no such a number can be encrypted to `\"4334\"`.\n    \n    # Input/Output\n    \n    \n    - `[input]` string `s`\n    \n    string presentation of n with `1 <= n <= 10^100`\n    \n    \n    - `[output]` a string\n    \n    The original phone number before encryption, or `\"impossible\"` if the initial number can not be calculated.\n    \"\"\"\n", "entry_point": "decrypt", "test": "\ndef check(candidate):\n    assert candidate('353') == '123'\n    assert candidate('444') == '404'\n    assert candidate('123456') == '738496'\n    assert candidate('147') == '377'\n    assert candidate('4334') == 'impossible'\ncheck(decrypt)\n", "given_tests": ["assert decrypt('353') == '123'", "assert decrypt('123456') == '738496'", "assert decrypt('4334') == 'impossible'"], "canonical_solution": ["def decrypt(s): return next((str(b // 11) for b in (int(str(a) + s) for a in range(1, 11)) if b % 11 == 0), 'impossible')"], "difficulty": "introductory"}
{"task_id": "APPS/2521", "prompt": "def reformat(s: str) -> str:\n    \"\"\"\n    Given alphanumeric string s. (Alphanumeric string is a string consisting of lowercase English letters and digits).\n    You have to find a permutation of\u00a0the string where no letter is followed by another letter and no digit is followed by another digit. That is, no two adjacent characters have the same type.\n    Return the reformatted string or return an empty string if it is impossible to reformat the string.\n    \n    Example 1:\n    Input: s = \"a0b1c2\"\n    Output: \"0a1b2c\"\n    Explanation: No two adjacent characters have the same type in \"0a1b2c\". \"a0b1c2\", \"0a1b2c\", \"0c2a1b\" are also valid permutations.\n    \n    Example 2:\n    Input: s = \"leetcode\"\n    Output: \"\"\n    Explanation: \"leetcode\" has only characters so we cannot separate them by digits.\n    \n    Example 3:\n    Input: s = \"1229857369\"\n    Output: \"\"\n    Explanation: \"1229857369\" has only digits so we cannot separate them by characters.\n    \n    Example 4:\n    Input: s = \"covid2019\"\n    Output: \"c2o0v1i9d\"\n    \n    Example 5:\n    Input: s = \"ab123\"\n    Output: \"1a2b3\"\n    \n    \n    Constraints:\n    \n    1 <= s.length <= 500\n    s consists of only lowercase English letters and/or digits.\n    \"\"\"\n", "entry_point": "reformat", "test": "\ndef check(candidate):\n    assert candidate('a0b1c2') == '0a1b2c' or candidate('a0b1c2') == 'a0b1c2' or candidate('a0b1c2') == '0c2a1b'\n    assert candidate('leetcode') == ''\n    assert candidate('1229857369') == ''\n    assert candidate('covid2019') == 'c2o0v1i9d' or candidate('covid2019') == '2c0o1v9i'\n    assert candidate('ab123') == '1a2b3' or candidate('ab123') == 'a1b2c'\ncheck(reformat)\n", "given_tests": ["assert reformat('a0b1c2') == '0a1b2c' or reformat('a0b1c2') == 'a0b1c2' or reformat('a0b1c2') == '0c2a1b'"], "canonical_solution": ["class Solution:\n    def reformat(self, s: str) -> str:\n        n = [str(i) for i in range(0, 10)]\n        a, b = [], []\n        for i in s:\n            if i in n:\n                b.append(i)\n            else:\n                a.append(i)\n        if abs(len(a) - len(b)) > 1:\n            return ''\n        r = ''\n        if len(a) == len(b):\n            while a:\n                r += a.pop()\n                r += b.pop()\n        elif len(a) > len(b):\n            while b:\n                r += a.pop()\n                r += b.pop()\n            r += a[0]\n        else:\n            while a:\n                r += b.pop()\n                r += a.pop()\n            r += b[0]\n        return r"], "difficulty": "introductory"}
{"task_id": "APPS/2706", "prompt": "def pass_the_bill(total: int, conservative: int, reformist: int) -> int:\n    \"\"\"\n    # Story&Task\n    There are three parties in parliament. The \"Conservative Party\", the \"Reformist Party\", and a group of independants.\n    \n    You are a member of the \u201cConservative Party\u201d and you party is trying to pass a bill. The \u201cReformist Party\u201d is trying to block it.\n    \n    In order for a bill to pass, it must have a majority vote, meaning that more than half of all members must approve of a bill before it is passed . The \"Conservatives\" and \"Reformists\" always vote the same as other members of thier parties, meaning that all the members of each party will all vote yes, or all vote no .\n    \n    However, independants vote individually, and the independant vote is often the determining factor as to whether a bill gets passed or not.\n    \n    Your task is to find the minimum number of independents that have to vote for your party's (the Conservative Party's) bill so that it is passed .\n    \n    In each test case the makeup of the Parliament will be different . In some cases your party may make up the majority of parliament, and in others it may make up the minority. If your party is the majority, you may find that you do not neeed any independants to vote in favor of your bill in order for it to pass . If your party is the minority, it may be possible that there are not enough independants for your bill to be passed . If it is impossible for your bill to pass, return `-1`.\n    \n    # Input/Output\n    \n    \n    - `[input]` integer `totalMembers`\n    \n    The total number of members.\n    \n    \n    - `[input]` integer `conservativePartyMembers`\n    \n    The number of members in the Conservative Party.\n    \n    \n    - `[input]` integer `reformistPartyMembers`\n    \n    The number of members in the Reformist Party.\n    \n    \n    - `[output]` an integer\n    \n    The minimum number of independent members that have to vote as you wish so that the bill is passed, or `-1` if you can't pass it anyway.\n    \n    # Example\n    \n    For `n = 8, m = 3 and k = 3`, the output should be `2`.\n    \n    It means:\n    ```\n    Conservative Party member --> 3\n    Reformist Party member   --> 3\n    the independent members --> 8 - 3 - 3 = 2\n    If 2 independent members change their minds\n    3 + 2 > 3\n    the bill will be passed.\n    If 1 independent members change their minds\n    perhaps the bill will be failed\n    (If the other independent members is against the bill).\n    3 + 1 <= 3 + 1\n    ```\n    \n    For `n = 13, m = 4 and k = 7`, the output should be `-1`.\n    ```\n    Even if all 2 independent members support the bill\n    there are still not enough votes to pass the bill\n    4 + 2 < 7\n    So the output is -1\n    ```\n    \"\"\"\n", "entry_point": "pass_the_bill", "test": "\ndef check(candidate):\n    assert candidate(8, 3, 3) == 2\n    assert candidate(13, 4, 7) == -1\n    assert candidate(7, 4, 3) == 0\n    assert candidate(11, 4, 1) == 2\n    assert candidate(11, 5, 1) == 1\n    assert candidate(11, 6, 1) == 0\n    assert candidate(11, 4, 4) == 2\n    assert candidate(11, 5, 4) == 1\n    assert candidate(11, 5, 5) == 1\n    assert candidate(11, 4, 6) == -1\n    assert candidate(11, 4, 5) == 2\n    assert candidate(15, 9, 3) == 0\n    assert candidate(16, 7, 8) == -1\n    assert candidate(16, 8, 7) == 1\n    assert candidate(16, 1, 8) == -1\ncheck(pass_the_bill)\n", "given_tests": ["assert pass_the_bill(8, 3, 3) == 2", "assert pass_the_bill(13, 4, 7) == -1"], "canonical_solution": ["def pass_the_bill(total, conservative, reformist): return -1 if reformist >= (total / 2) else max(0, total // 2 + 1 - conservative)"], "difficulty": "introductory"}
{"task_id": "APPS/4536", "prompt": "def capitals_first(string: str) -> str:\n    \"\"\"\n    Create a function that takes an input String and returns a String, where all the uppercase words of the input String are in front and all the lowercase words at the end.\n    The order of the uppercase and lowercase words should be the order in which they occur.\n    \n    If a word starts with a number or special character, skip the word and leave it out of the result.\n    \n    Input String will not be empty.\n    \n    For an input String: \"hey You, Sort me Already!\"\n    the function should return: \"You, Sort Already! hey me\"\n    \"\"\"\n", "entry_point": "capitals_first", "test": "\ndef check(candidate):\n    assert candidate('hey You, Sort me Already') == 'You, Sort Already hey me'\n    assert candidate('sense Does to That Make you?') == 'Does That Make sense to you?'\n    assert candidate('i First need Thing In coffee The Morning') == 'First Thing In The Morning i need coffee'\n    assert candidate('123 baby You and Me') == 'You Me baby and'\n    assert candidate('Life gets Sometimes pretty !Hard') == 'Life Sometimes gets pretty'\ncheck(capitals_first)\n", "given_tests": ["assert capitals_first('hey You, Sort me Already') == 'You, Sort Already hey me'"], "canonical_solution": ["def capitals_first(string): return ' '.join([word for word in string.split() if word[0].isupper()] + [word for word in string.split() if word[0].islower()])"], "difficulty": "introductory"}
{"task_id": "APPS/2496", "prompt": "def day_of_the_week(day: int, month: int, year: int) -> str:\n    \"\"\"\n    Given a date, return the corresponding day of the week for that date.\n    The input is given as three integers representing the day, month and year respectively.\n    Return the answer as one of the following values\u00a0{\"Sunday\", \"Monday\", \"Tuesday\", \"Wednesday\", \"Thursday\", \"Friday\", \"Saturday\"}.\n    \n    Example 1:\n    Input: day = 31, month = 8, year = 2019\n    Output: \"Saturday\"\n    \n    Example 2:\n    Input: day = 18, month = 7, year = 1999\n    Output: \"Sunday\"\n    \n    Example 3:\n    Input: day = 15, month = 8, year = 1993\n    Output: \"Sunday\"\n    \n    \n    Constraints:\n    \n    The given dates are valid\u00a0dates between the years 1971 and 2100.\n    \"\"\"\n", "entry_point": "day_of_the_week", "test": "\ndef check(candidate):\n    assert candidate(31, 8, 2019) == 'Saturday'\n    assert candidate(18, 7, 1999) == 'Sunday'\n    assert candidate(15, 8, 1993) == 'Sunday'\ncheck(day_of_the_week)\n", "given_tests": ["assert day_of_the_week(31, 8, 2019) == 'Saturday'", "assert day_of_the_week(18, 7, 1999) == 'Sunday'", "assert day_of_the_week(15, 8, 1993) == 'Sunday'"], "canonical_solution": ["import calendar\n\nclass Solution:\n    def day_of_the_week(self, day: int, month: int, year: int) -> str:\n        return calendar.day_name[calendar.weekday(year, month, day)]"], "difficulty": "introductory"}
{"task_id": "APPS/2370", "prompt": "def max_length_three_blocks_palindrome(t: int, cases: List[Tuple[int, List[int]]]) -> List[int]:\n    \"\"\"\n    The only difference between easy and hard versions is constraints.\n    \n    You are given a sequence $a$ consisting of $n$ positive integers.\n    \n    Let's define a three blocks palindrome as the sequence, consisting of at most two distinct elements (let these elements are $a$ and $b$, $a$ can be equal $b$) and is as follows: $[\\underbrace{a, a, \\dots, a}_{x}, \\underbrace{b, b, \\dots, b}_{y}, \\underbrace{a, a, \\dots, a}_{x}]$. There $x, y$ are integers greater than or equal to $0$. For example, sequences $[]$, $[2]$, $[1, 1]$, $[1, 2, 1]$, $[1, 2, 2, 1]$ and $[1, 1, 2, 1, 1]$ are three block palindromes but $[1, 2, 3, 2, 1]$, $[1, 2, 1, 2, 1]$ and $[1, 2]$ are not.\n    \n    Your task is to choose the maximum by length subsequence of $a$ that is a three blocks palindrome.\n    \n    You have to answer $t$ independent test cases.\n    \n    Recall that the sequence $t$ is a a subsequence of the sequence $s$ if $t$ can be derived from $s$ by removing zero or more elements without changing the order of the remaining elements. For example, if $s=[1, 2, 1, 3, 1, 2, 1]$, then possible subsequences are: $[1, 1, 1, 1]$, $[3]$ and $[1, 2, 1, 3, 1, 2, 1]$, but not $[3, 2, 3]$ and $[1, 1, 1, 1, 2]$.\n    \n    \n    -----Input-----\n    \n    The first line of the input contains one integer $t$ ($1 \\le t \\le 2000$) \u2014 the number of test cases. Then $t$ test cases follow.\n    \n    The first line of the test case contains one integer $n$ ($1 \\le n \\le 2000$) \u2014 the length of $a$. The second line of the test case contains $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 26$), where $a_i$ is the $i$-th element of $a$. Note that the maximum value of $a_i$ can be up to $26$.\n    \n    It is guaranteed that the sum of $n$ over all test cases does not exceed $2000$ ($\\sum n \\le 2000$).\n    \n    \n    -----Output-----\n    \n    For each test case, print the answer \u2014 the maximum possible length of some subsequence of $a$ that is a three blocks palindrome.\n    \n    \n    -----Example-----\n    Input\n    6\n    8\n    1 1 2 2 3 2 1 1\n    3\n    1 3 3\n    4\n    1 10 10 1\n    1\n    26\n    2\n    2 1\n    3\n    1 1 1\n    \n    Output\n    7\n    2\n    4\n    1\n    1\n    3\n    \"\"\"\n", "entry_point": "max_length_three_blocks_palindrome", "test": "\ndef check(candidate):\n    assert candidate(6, [(8, [1, 1, 2, 2, 3, 2, 1, 1]), (3, [1, 3, 3]), (4, [1, 10, 10, 1]), (1, [26]), (2, [2, 1]), (3, [1, 1, 1])]) == [7, 2, 4, 1, 1, 3]\ncheck(max_length_three_blocks_palindrome)\n", "given_tests": ["assert max_length_three_blocks_palindrome(6, [(8, [1, 1, 2, 2, 3, 2, 1, 1]), (3, [1, 3, 3]), (4, [1, 10, 10, 1]), (1, [26]), (2, [2, 1]), (3, [1, 1, 1])]) == [7, 2, 4, 1, 1, 3]"], "canonical_solution": ["from collections import defaultdict; from heapq import heappush, heappop; from itertools import permutations, accumulate; import sys, math, bisect; def LI(): return [int(x) for x in sys.stdin.readline().split()]; def I(): return int(sys.stdin.readline()); def LS():return [list(x) for x in sys.stdin.readline().split()]; def S(): res = list(sys.stdin.readline()); if res[-1] == \"\\n\": return res[:-1]; return res; def IR(n): return [I() for i in range(n)]; def LIR(n): return [LI() for i in range(n)]; def SR(n): return [S() for i in range(n)]; def LSR(n): return [LS() for i in range(n)]; sys.setrecursionlimit(1000000); mod = 1000000007; def solve(): def f(a,b): if a == b: return len(d[a]); da = d[a]; db = d[b]; res = 0; for x in range(len(da) >> 1): l = da[x]; r = da[-1-x]; i = bisect.bisect_left(db,l); j = bisect.bisect_left(db,r); y = max(0,j-i); s = 2*(x+1)+y; if res < s: res = s; return res; t = I(); for _ in range(t): n = I(); a = LI(); m = max(a); d = [[] for i in range(m)]; for i in range(n): ai = a[i]-1; d[ai].append(i); ans = 1; for a in range(m): if not d[a]: continue; for b in range(m): if not d[b]: continue; res = f(a,b); if ans < res: ans = res; print(ans); return; def __starting_point(): solve(); __starting_point()"], "difficulty": "introductory"}
{"task_id": "APPS/3791", "prompt": "def moment_of_time_in_space(moment: str) -> List[bool]:\n    \"\"\"\n    # Task\n    You are given a `moment` in time and space. What you must do is break it down into time and space, to determine if that moment is from the past, present or future.\n    \n    `Time` is the sum of characters that increase time (i.e. numbers in range ['1'..'9'].\n    \n    `Space` in the number of characters which do not increase time (i.e. all characters but those that increase time).\n    \n    The moment of time is determined as follows:\n    ```\n    If time is greater than space, than the moment is from the future.\n    If time is less than space, then the moment is from the past.\n    Otherwise, it is the present moment.```\n    \n    You should return an array of three elements, two of which are false, and one is true. The true value should be at the `1st, 2nd or 3rd` place for `past, present and future` respectively.\n    \n    # Examples\n    \n    For `moment = \"01:00 pm\"`, the output should be `[true, false, false]`.\n    \n    time equals 1, and space equals 7, so the moment is from the past.\n    \n    For `moment = \"12:02 pm\"`, the output should be `[false, true, false]`.\n    \n    time equals 5, and space equals 5, which means that it's a present moment.\n    \n    For `moment = \"12:30 pm\"`, the output should be `[false, false, true]`.\n    \n    time equals 6, space equals 5, so the moment is from the future.\n    \n    # Input/Output\n    \n    \n    - `[input]` string `moment`\n    \n    The moment of time and space that the input time came from.\n    \n    \n    - `[output]` a boolean array\n    \n    Array of three elements, two of which are false, and one is true. The true value should be at the 1st, 2nd or 3rd place for past, present and future respectively.\n    \"\"\"\n", "entry_point": "moment_of_time_in_space", "test": "\ndef check(candidate):\n    assert candidate('12:30 am') == [False, False, True]\n    assert candidate('12:02 pm') == [False, True, False]\n    assert candidate('01:00 pm') == [True, False, False]\n    assert candidate('11:12 am') == [False, False, True]\n    assert candidate('05:20 pm') == [False, False, True]\n    assert candidate('04:20 am') == [False, True, False]\ncheck(moment_of_time_in_space)\n", "given_tests": ["assert moment_of_time_in_space('12:02 pm') == [False, True, False]", "assert moment_of_time_in_space('12:30 am') == [False, False, True]", "assert moment_of_time_in_space('01:00 pm') == [True, False, False]"], "canonical_solution": ["def moment_of_time_in_space(moment): d = sum(int(c) if c in '123456789' else -1 for c in moment); return [d < 0, d == 0, d > 0]"], "difficulty": "introductory"}
{"task_id": "APPS/2444", "prompt": "def max_distance_between_ones(n: int) -> int:\n    \"\"\"\n    Given a positive integer n, find and return the longest distance between any two adjacent 1's in the binary representation of n. If there are no two adjacent 1's, return 0.\n    Two 1's are adjacent if there are only 0's separating them (possibly no 0's). The distance between two 1's is the absolute difference between their bit positions. For example, the two 1's in \"1001\" have a distance of 3.\n    \n    Example 1:\n    Input: n = 22\n    Output: 2\n    Explanation: 22 in binary is \"10110\".\n    The first adjacent pair of 1's is \"10110\" with a distance of 2.\n    The second adjacent pair of 1's is \"10110\" with a distance of 1.\n    The answer is the largest of these two distances, which is 2.\n    Note that \"10110\" is not a valid pair since there is a 1 separating the two 1's underlined.\n    \n    Example 2:\n    Input: n = 5\n    Output: 2\n    Explanation: 5 in binary is \"101\".\n    \n    Example 3:\n    Input: n = 6\n    Output: 1\n    Explanation: 6 in binary is \"110\".\n    \n    Example 4:\n    Input: n = 8\n    Output: 0\n    Explanation: 8 in binary is \"1000\".\n    There aren't any adjacent pairs of 1's in the binary representation of 8, so we return 0.\n    \n    Example 5:\n    Input: n = 1\n    Output: 0\n    \n    \n    Constraints:\n    \n    1 <= n <= 109\n    \"\"\"\n", "entry_point": "max_distance_between_ones", "test": "\ndef check(candidate):\n    assert candidate(22) == 2\n    assert candidate(5) == 2\n    assert candidate(8) == 0\ncheck(max_distance_between_ones)\n", "given_tests": ["assert max_distance_between_ones(22) == 2", "assert max_distance_between_ones(8) == 0", "assert max_distance_between_ones(5) == 2"], "canonical_solution": ["class Solution: def binaryGap(self, n: int) -> int: maxDist = 0; currDist = 0; while n: if n & 1 and currDist != 0: maxDist = max(maxDist, currDist); currDist = 1; elif n & 1: currDist = 1; elif not n & 1 and currDist != 0: currDist += 1; n >>= 1; return maxDist"], "difficulty": "introductory"}
{"task_id": "APPS/4537", "prompt": "def bin2gray(bits: list) -> list:\n    \"\"\"\n    Gray code is a form of binary encoding where transitions between consecutive numbers differ by only one bit. This is a useful encoding for reducing hardware data hazards with values that change rapidly and/or connect to slower hardware as inputs. It is also useful for generating inputs for Karnaugh maps.\n    \n    Here is an exemple of what the code look like:\n    \n    ```\n    0:    0000\n    1:    0001\n    2:    0011\n    3:    0010\n    4:    0110\n    5:    0111\n    6:    0101\n    7:    0100\n    8:    1100\n    ```\n    \n    The goal of this kata is to build two function bin2gray and gray2bin wich will convert natural binary to Gray Code and vice-versa. We will use the \"binary reflected Gray code\". The input and output will be arrays of 0 and 1, MSB at index 0.\n    \n    There are \"simple\" formula to implement these functions. It is a very interesting exercise to find them by yourself.\n    \n    All input will be correct binary arrays.\n    \"\"\"\n", "entry_point": "bin2gray", "test": "\ndef check(candidate):\n    assert candidate([1, 0, 1]) == [1, 1, 1]\n    assert candidate([1, 1]) == [1, 0]\n    assert candidate([1]) == [1]\n    assert candidate([0]) == [0]\n    assert candidate([1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0]) == [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1]\n    assert candidate([1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0, 1, 0, 1, 0, 1, 1, 1, 0, 1, 0, 1, 0]) == [1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 0, 0, 1, 1, 1, 1, 1]\ncheck(bin2gray)\n", "given_tests": ["assert bin2gray([1, 0, 1]) == [1, 1, 1]", "assert bin2gray([1, 1]) == [1, 0]"], "canonical_solution": ["def bin2gray(bits): return [x ^ y for x, y in zip(bits, [0] + bits)]\ndef gray2bin(bits): return [reduce(lambda x, y: x ^ y, bits[:i + 1]) for i, _ in enumerate(bits)]"], "difficulty": "introductory"}
{"task_id": "APPS/4329", "prompt": "def pig_latin(s: str) -> str:\n    \"\"\"\n    Pig Latin is an English language game where the goal is to hide the meaning of a word from people not aware of the rules.\n    \n    So, the goal of this kata is to wite a function that encodes a single word string to pig latin.\n    \n    The rules themselves are rather easy:\n    \n    1) The word starts with a vowel(a,e,i,o,u) -> return the original string plus \"way\".\n    \n    2) The word starts with a consonant -> move consonants from the beginning of the word to the end of the word until the first vowel, then return it plus \"ay\".\n    \n    3) The result must be lowercase, regardless of the case of the input. If the input string has any non-alpha characters, the function must return None, null, Nothing (depending on the language).\n    \n    4) The function must also handle simple random strings and not just English words.\n    \n    5) The input string has no vowels -> return the original string plus \"ay\".\n    \n    For example, the word \"spaghetti\" becomes \"aghettispay\" because the first two letters (\"sp\") are consonants, so they are moved to the end of the string and \"ay\" is appended.\n    \"\"\"\n", "entry_point": "pig_latin", "test": "\ndef check(candidate):\n    assert candidate('Hello') == 'ellohay'\n    assert candidate('CCCC') == 'ccccay'\n    assert candidate('tes3t5') == None\n    assert candidate('ay') == 'ayway'\n    assert candidate('') == None\n    assert candidate('YA') == 'ayay'\n    assert candidate('123') == None\n    assert candidate('ya1') == None\n    assert candidate('yaYAya') == 'ayayayay'\n    assert candidate('YayayA') == 'ayayayay'\ncheck(pig_latin)\n", "given_tests": ["assert pig_latin('spaghetti') == 'aghettispay'"], "canonical_solution": ["def pig_latin(st): s = st.lower(); VOWELS = set('aeiou'); return (None if not s.isalpha() else s + 'way' if s[0] in VOWELS else (lambda s: [s[1:] + s[:1] for _ in range(len(s)) if s[0] not in VOWELS][0] + 'ay'))(s)"], "difficulty": "introductory"}
{"task_id": "APPS/2473", "prompt": "def modifyString(s: str) -> str:\n    \"\"\"\n    Given a string\u00a0s\u00a0containing only lower case English letters\u00a0and the '?'\u00a0character, convert all the '?' characters into lower case letters such that the final string does not contain any consecutive repeating\u00a0characters.\u00a0You cannot modify the non '?' characters.\n    It is guaranteed that there are no consecutive repeating characters in the given string except for '?'.\n    Return the final string after all the conversions (possibly zero) have been made. If there is more than one solution, return any of them.\u00a0It can be shown that an answer is always possible with the given constraints.\n    \n    Example 1:\n    Input: s = \"?zs\"\n    Output: \"azs\"\n    Explanation: There are 25 solutions for this problem. From \"azs\" to \"yzs\", all are valid. Only \"z\" is an invalid modification as the string will consist of consecutive repeating characters in \"zzs\".\n    Example 2:\n    Input: s = \"ubv?w\"\n    Output: \"ubvaw\"\n    Explanation: There are 24 solutions for this problem. Only \"v\" and \"w\" are invalid modifications as the strings will consist of consecutive repeating characters in \"ubvvw\" and \"ubvww\".\n    \n    Example 3:\n    Input: s = \"j?qg??b\"\n    Output: \"jaqgacb\"\n    \n    Example 4:\n    Input: s = \"??yw?ipkj?\"\n    Output: \"acywaipkja\"\n    \n    \n    Constraints:\n    \n    1 <= s.length\u00a0<= 100\n    s contains\u00a0only lower case English letters and '?'.\n    \"\"\"\n", "entry_point": "modifyString", "test": "\ndef check(candidate):\n    assert candidate('?zs') == 'azs'\n    assert candidate('ubv?w') == 'ubvaw'\n    assert candidate('j?qg??b') == 'jaqgacb'\n    assert candidate('??yw?ipkj?') == 'acywaipkja'\ncheck(modifyString)\n", "given_tests": ["assert modifyString('?zs') == 'azs'", "assert modifyString('ubv?w') == 'ubvaw'", "assert modifyString('j?qg??b') == 'jaqgacb'", "assert modifyString('??yw?ipkj?') == 'acywaipkja'"], "canonical_solution": ["def modifyString(s): return ''.join(chr(97 + (i + 1) % 3) if c == '?' else c for i, c in enumerate(s))"], "difficulty": "introductory"}
{"task_id": "APPS/2732", "prompt": "def blocks(s: str) -> str:\n    \"\"\"\n    ## Task\n    \n    You will receive a string consisting of lowercase letters, uppercase letters and digits as input. Your task is to return this string as blocks separated by dashes (`\"-\"`). The elements of a block should be sorted with respect to the hierarchy listed below, and each block cannot contain multiple instances of the same character. Elements should be put into the first suitable block.\n    \n    The hierarchy is:\n    1. lowercase letters (`a - z`), in alphabetical order\n    2. uppercase letters (`A - Z`), in alphabetical order\n    3. digits (`0 - 9`), in ascending order\n    \n    ## Examples\n    \n    * `\"21AxBz\" -> \"xzAB12\"` - since input does not contain repeating characters, you only need 1 block\n    * `\"abacad\" -> \"abcd-a-a\"` - character \"a\" repeats 3 times, thus 3 blocks are needed\n    * `\"\" -> \"\"` - an empty input should result in an empty output\n    * `\"hbh420sUUW222IWOxndjn93cdop69NICEep832\" -> \"bcdehjnopsxCEINOUW0234689-dhnpIUW239-2-2-2\"` - a more sophisticated example\n    \n    Good luck!\n    \"\"\"\n", "entry_point": "blocks", "test": "\ndef check(candidate):\n    assert candidate('heyitssampletestkk') == 'aeiklmpsty-ehkst-s'\n    assert candidate('dasf6ds65f45df65gdf651vdf5s1d6g5f65vqweAQWIDKsdds') == 'adefgqsvwADIKQW1456-dfgsv156-dfs56-dfs56-dfs56-df56-d5-d'\n    assert candidate('SDF45648374RHF8BFVYg378rg3784rf87g3278bdqG') == 'bdfgqrBDFGHRSVY2345678-grF3478-gF3478-3478-78-8'\n    assert candidate('') == ''\n    assert candidate('aaaaaaaaaa') == 'a-a-a-a-a-a-a-a-a-a'\ncheck(blocks)\n", "given_tests": ["assert blocks('21AxBz') == 'xzAB12'", "assert blocks('abacad') == 'abcd-a-a'", "assert blocks('->') == ''"], "canonical_solution": ["from collections import Counter\n\nsort = lambda c: (c.isdigit(), c.isupper(), c)\n\ndef blocks(s):\n    answer, counter = [], Counter(s)\n    while counter:\n        block = ''.join(sorted(counter, key=sort))\n        answer.append(block)\n        counter = counter - Counter(block)\n    return '-'.join(answer)"], "difficulty": "introductory"}
{"task_id": "APPS/2863", "prompt": "def AlanAnnoyingKid(sentence: str) -> str:\n    \"\"\"\n    Alan's child can be annoying at times.\n    \n    When Alan comes home and tells his kid what he has accomplished today, his kid never believes him.\n    \n    Be that kid.\n    \n    Your function 'AlanAnnoyingKid' takes as input a sentence spoken by Alan (a string). The sentence contains the following structure:\n    \n    \"Today I \" + [action_verb] + [object] + \".\"\n    \n    (e.g.: \"Today I played football.\")\n    \n    \n    Your function will return Alan's kid response, which is another sentence with the following structure:\n    \n    \"I don't think you \" + [action_performed_by_alan] + \" today, I think you \" + [\"did\" OR \"didn't\"] + [verb_of _action_in_present_tense] + [\" it!\" OR \" at all!\"]\n    \n    (e.g.:\"I don't think you played football today, I think you didn't play at all!\")\n    \n    \n    Note the different structure depending on the presence of a negation in Alan's first sentence (e.g., whether Alan says \"I dind't play football\", or \"I played football\").\n    \n    ! Also note: Alan's kid is young and only uses simple, regular verbs that use a simple \"ed\" to make past tense.\n    There are random test cases.\n    \n    Some more examples:\n    \n    input  = \"Today I played football.\"\n    output = \"I don't think you played football today, I think you didn't play at all!\"\n    \n    input  = \"Today I didn't attempt to hardcode this Kata.\"\n    output = \"I don't think you didn't attempt to hardcode this Kata today, I think you did attempt it!\"\n    \n    input  = \"Today I didn't play football.\"\n    output = \"I don't think you didn't play football today, I think you did play it!\"\n    \n    input  = \"Today I cleaned the kitchen.\"\n    output = \"I don't think you cleaned the kitchen today, I think you didn't clean at all!\"\n    \"\"\"\n", "entry_point": "AlanAnnoyingKid", "test": "\ndef check(candidate):\n    assert candidate('Today I played football.') == \"I don't think you played football today, I think you didn't play at all!\"\n    assert candidate(\"Today I didn't play football.\") == \"I don't think you didn't play football today, I think you did play it!\"\n    assert candidate(\"Today I didn't attempt to hardcode this Kata.\") == \"I don't think you didn't attempt to hardcode this Kata today, I think you did attempt it!\"\n    assert candidate('Today I cleaned the kitchen.') == \"I don't think you cleaned the kitchen today, I think you didn't clean at all!\"\n    assert candidate('Today I learned to code like a pro.') == \"I don't think you learned to code like a pro today, I think you didn't learn at all!\"\ncheck(AlanAnnoyingKid)\n", "given_tests": ["assert AlanAnnoyingKid('Today I played football.') == \"I don't think you played football today, I think you didn't play at all!\"", "assert AlanAnnoyingKid(\"Today I didn't attempt to hardcode this Kata.\") == \"I don't think you didn't attempt to hardcode this Kata today, I think you did attempt it!\"", "assert AlanAnnoyingKid(\"Today I didn't play football.\") == \"I don't think you didn't play football today, I think you did play it!\"", "assert AlanAnnoyingKid('Today I cleaned the kitchen.') == \"I don't think you cleaned the kitchen today, I think you didn't clean at all!\""], "canonical_solution": ["def AlanAnnoyingKid(sentence: str) -> str: return f\"I don't think you {sentence[7:-1]} today, I think you {'did' if \"didn't\" in sentence else \"didn't\"} {sentence.split()[2] if \"didn't\" in sentence else sentence.split()[2][:-2]} {'it!' if \"didn't\" in sentence else 'at all!'}\""], "difficulty": "introductory"}
{"task_id": "APPS/3877", "prompt": "def T9(words: list, seq: str) -> list:\n    \"\"\"\n    The T9 typing predictor helps with suggestions for possible word combinations on an old-style numeric keypad phone. Each digit in the keypad (2-9) represents a group of 3-4 letters. To type a letter, press once the key which corresponds to the letter group that contains the required letter. Typing words is done by typing letters of the word in sequence.\n    \n    The letter groups and corresponding digits are as follows:\n    ```\n    -----------------\n    |  1  |  2  |  3  |\n    |     | ABC | DEF |\n    |-----|-----|-----|\n    |  4  |  5  |  6  |\n    | GHI | JKL | MNO |\n    |-----|-----|-----|\n    |  7  |  8  |  9  |\n    | PQRS| TUV | WXYZ|\n    -----------------\n    ```\n    \n    The prediction algorithm tries to match the input sequence against a predefined dictionary of words. The combinations which appear in the dictionary are considered valid words and are shown as suggestions.\n    \n    Given a list of words as a reference dictionary, and a non-empty string (of digits 2-9) as input, complete the function which returns suggestions based on the string of digits, which are found in the reference dictionary.\n    \n    For example:\n    ```python\n    T9(['hello', 'world'], '43556') returns ['hello']\n    T9(['good', 'home', 'new'], '4663') returns ['good', 'home']\n    ```\n    \n    Note that the dictionary must be case-insensitive (`'hello'` and `'Hello'` are same entries). The list returned must contain the word as it appears in the dictionary (along with the case).\n    \n    Example:\n    ```python\n    T9(['Hello', 'world'], '43556') returns ['Hello']\n    ```\n    \n    If there is no prediction available from the given dictionary, then return the string containing first letters of the letter groups, which correspond to the input digits.\n    \n    For example:\n    ```python\n    T9([], '43556') returns ['gdjjm']\n    T9(['gold', 'word'], '4663') returns ['gmmd']\n    ```\n    \"\"\"\n", "entry_point": "T9", "test": "\ndef check(candidate):\n    assert candidate(['hello', 'world'], '43556') == ['hello']\n    assert candidate(['good', 'home', 'new'], '4663') == ['good', 'home']\n    assert candidate(['gone', 'hood', 'good', 'old'], '4663') == ['gone', 'hood', 'good']\n    assert candidate(['Hello', 'world'], '43556') == ['Hello']\n    assert candidate(['gOOD', 'hOmE', 'NeW'], '4663') == ['gOOD', 'hOmE']\n    assert candidate(['goNe', 'hood', 'GOOD', 'old'], '4663') == ['goNe', 'hood', 'GOOD']\n    assert candidate([], '43556') == ['gdjjm']\n    assert candidate(['gold'], '4663') == ['gmmd']\n    assert candidate(['gone', 'hood', 'good', 'old'], '729') == ['paw']\ncheck(T9)\n", "given_tests": ["assert T9(['hello', 'world'], '43556') == ['hello']", "assert T9(['good', 'home', 'new'], '4663') == ['good', 'home']", "assert T9(['Hello', 'world'], '43556') == ['Hello']", "assert T9([], '43556') == ['gdjjm']", "assert T9(['gold', 'word'], '4663') == ['gmmd']"], "canonical_solution": ["FROM   = \"abc def ghi jkl mno pqrs tuv wxyz\".split()\nTO_NUM = \"222 333 444 555 666 7777 888 9999\".split()\n\nTABLE_TO_NUM  = str.maketrans( *map(''.join, (FROM, TO_NUM)) )\nTABLE_TO_CHAR = str.maketrans( *map(lambda lst: ''.join(x[0] for x in lst), (TO_NUM, FROM)))\n\n\ndef T9(words, seq):\n    return ( [w for w in words if seq == w.lower().translate(TABLE_TO_NUM)]\n                or [seq.translate(TABLE_TO_CHAR)] )"], "difficulty": "introductory"}
{"task_id": "APPS/2740", "prompt": "def wheat_from_chaff(values: list) -> list:\n    \"\"\"\n    # Scenario\n    \n    With **_Cereal crops_** like wheat or rice, before we can eat the grain kernel, we need to remove that inedible hull, or *to separate the wheat from the chaff*.\n    ___\n    \n    # Task\n    \n    **_Given_** a *sequence of n integers* , **_separate_** *the negative numbers (chaff) from positive ones (wheat).*\n    ___\n    \n    # Notes\n    \n    * **_Sequence size_** is _at least_ **_3_**\n    * **_Return_** *a new sequence*, such that  **_negative numbers (chaff) come first, then positive ones (wheat)_**.\n    * In Java , *you're not allowed to modify the input Array/list/Vector*\n    * **_Have no fear_** , *it is guaranteed that there will be no zeroes* .\n    * **_Repetition_** of numbers in *the input sequence could occur* , so **_duplications are included when separating_**.\n    * If a misplaced *positive* number is found in the front part of the sequence, replace it with the last misplaced negative number (the one found near the end of the input). The second misplaced positive number should be swapped with the second last misplaced negative number. *Negative numbers found at the head (begining) of the sequence* , **_should be kept in place_** .\n    \n    ____\n    \n    # Input >> Output Examples:\n    \n    ```\n    wheatFromChaff ({7, -8, 1 ,-2}) ==> return ({-2, -8, 1, 7})\n    ```\n    \n    ## **_Explanation_**:\n    \n    * **_Since_** `7 ` is a  **_positive number_** , it should not be located at the beginnig so it needs to be swapped with the **last negative number** `-2`.\n    ____\n    \n    ```\n    wheatFromChaff ({-31, -5, 11 , -42, -22, -46, -4, -28 }) ==> return ({-31, -5,- 28, -42, -22, -46 , -4, 11})\n    ```\n    \n    ## **_Explanation_**:\n    \n    * **_Since_**, `{-31, -5} ` are  **_negative numbers_** *found at the head (begining) of the sequence* , *so we keep them in place* .\n    * Since `11` is a positive number, it's replaced by  the last negative which is `-28` , and so on till sepration is complete.\n    \n    ____\n    \n    ```\n    wheatFromChaff ({-25, -48, -29, -25, 1, 49, -32, -19, -46, 1}) ==> return ({-25, -48, -29, -25, -46, -19, -32, 49, 1, 1})\n    ```\n    \n    ## **_Explanation_**:\n    \n    * **_Since_** `{-25, -48, -29, -25} ` are  **_negative numbers_** *found at the head (begining) of the input* , *so we keep them in place* .\n    \n    * Since `1` is a positive number, it's replaced by  the last negative which is `-46` , and so on till sepration is complete.\n    \n    * Remeber, *duplications are included when separating* , that's why the number `1` appeared twice at the end of the output.\n    ____\n    \n    # Tune Your Code , There are 250 Assertions , 100.000 element For Each .\n    \n    # Only O(N) Complexity Solutions Will pass .\n    ____\n    \"\"\"\n", "entry_point": "wheat_from_chaff", "test": "\ndef check(candidate):\n    assert candidate([2, -4, 6, -6]) == [-6, -4, 6, 2]\n    assert candidate([7, -3, -10]) == [-10, -3, 7]\n    assert candidate([7, -8, 1, -2]) == [-2, -8, 1, 7]\n    assert candidate([8, 10, -6, -7, 9]) == [-7, -6, 10, 8, 9]\n    assert candidate([-3, 4, -10, 2, -6]) == [-3, -6, -10, 2, 4]\n    assert candidate([2, -6, -4, 1, -8, -2]) == [-2, -6, -4, -8, 1, 2]\n    assert candidate([16, 25, -48, -47, -37, 41, -2]) == [-2, -37, -48, -47, 25, 41, 16]\n    assert candidate([-30, -11, 36, 38, 34, -5, -50]) == [-30, -11, -50, -5, 34, 38, 36]\n    assert candidate([-31, -5, 11, -42, -22, -46, -4, -28]) == [-31, -5, -28, -42, -22, -46, -4, 11]\n    assert candidate([46, 39, -45, -2, -5, -6, -17, -32, 17]) == [-32, -17, -45, -2, -5, -6, 39, 46, 17]\n    assert candidate([-9, -8, -6, -46, 1, -19, 44]) == [-9, -8, -6, -46, -19, 1, 44]\n    assert candidate([-37, -10, -42, 19, -31, -40, -45, 33]) == [-37, -10, -42, -45, -31, -40, 19, 33]\n    assert candidate([-25, -48, -29, -25, 1, 49, -32, -19, -46, 1]) == [-25, -48, -29, -25, -46, -19, -32, 49, 1, 1]\n    assert candidate([-7, -35, -46, -22, 46, 43, -44, -14, 34, -5, -26]) == [-7, -35, -46, -22, -26, -5, -44, -14, 34, 43, 46]\n    assert candidate([-46, -50, -28, -45, -27, -40, 10, 35, 34, 47, -46, -24]) == [-46, -50, -28, -45, -27, -40, -24, -46, 34, 47, 35, 10]\n    assert candidate([-33, -14, 16, 31, 4, 41, -10, -3, -21, -12, -45, 41, -19]) == [-33, -14, -19, -45, -12, -21, -10, -3, 41, 4, 31, 41, 16]\n    assert candidate([-17, 7, -12, 10, 4, -8, -19, -24, 40, 31, -29, 21, -45, 1]) == [-17, -45, -12, -29, -24, -8, -19, 4, 40, 31, 10, 21, 7, 1]\n    assert candidate([-16, 44, -7, -31, 9, -43, -44, -18, 50, 39, -46, -24, 3, -34, -27]) == [-16, -27, -7, -31, -34, -43, -44, -18, -24, -46, 39, 50, 3, 9, 44]\ncheck(wheat_from_chaff)\n", "given_tests": ["assert wheat_from_chaff([7, -8, 1 ,-2]) == [-2, -8, 1, 7]", "assert wheat_from_chaff([-31, -5, 11 , -42, -22, -46, -4, -28 ]) == [-31, -5,- 28, -42, -22, -46 , -4, 11]", "assert wheat_from_chaff([-25, -48, -29, -25, 1, 49, -32, -19, -46, 1]) == [-25, -48, -29, -25, -46, -19, -32, 49, 1, 1]"], "canonical_solution": ["def wheat_from_chaff(values): i, j = 0, len(values)-1 while True: while i < j and values[i] < 0: i += 1 while i < j and values[j] > 0: j -= 1 if i >= j: return values values[i], values[j] = values[j], values[i]"], "difficulty": "introductory"}
{"task_id": "APPS/2505", "prompt": "def is_rectangle_overlap(rec1: list, rec2: list) -> bool:\n    \"\"\"\n    An axis-aligned rectangle is represented as a list [x1, y1, x2, y2], where (x1, y1) is the coordinate of its bottom-left corner, and (x2, y2) is the coordinate of its top-right corner. Its top and bottom edges are parallel to the X-axis, and its left and right edges are parallel to the Y-axis.\n    Two rectangles overlap if the area of their intersection is positive. To be clear, two rectangles that only touch at the corner or edges do not overlap.\n    Given two axis-aligned rectangles rec1 and rec2, return true if they overlap, otherwise return false.\n    \n    Example 1:\n    Input: rec1 = [0,0,2,2], rec2 = [1,1,3,3]\n    Output: true\n    Example 2:\n    Input: rec1 = [0,0,1,1], rec2 = [1,0,2,1]\n    Output: false\n    Example 3:\n    Input: rec1 = [0,0,1,1], rec2 = [2,2,3,3]\n    Output: false\n    \n    \n    Constraints:\n    \n    rect1.length == 4\n    rect2.length == 4\n    -109 <= rec1[i], rec2[i] <= 109\n    rec1[0] <= rec1[2] and rec1[1] <= rec1[3]\n    rec2[0] <= rec2[2] and rec2[1] <= rec2[3]\n    \"\"\"\n", "entry_point": "is_rectangle_overlap", "test": "\ndef check(candidate):\n    assert candidate([0, 0, 2, 2], [1, 1, 3, 3]) == True\n    assert candidate([0, 0, 1, 1], [1, 0, 2, 1]) == False\n    assert candidate([0, 0, 1, 1], [2, 2, 3, 3]) == False\ncheck(is_rectangle_overlap)\n", "given_tests": ["assert is_rectangle_overlap([0, 0, 2, 2], [1, 1, 3, 3]) == True", "assert is_rectangle_overlap([0, 0, 1, 1], [1, 0, 2, 1]) == False", "assert is_rectangle_overlap([0, 0, 1, 1], [2, 2, 3, 3]) == False"], "canonical_solution": ["def is_rectangle_overlap(rec1, rec2): return not (rec1[0] >= rec2[2] or rec1[2] <= rec2[0] or rec1[1] >= rec2[3] or rec1[3] <= rec2[1])"], "difficulty": "introductory"}
{"task_id": "APPS/2491", "prompt": "def buddy_strings(A: str, B: str) -> bool:\n    \"\"\"\n    Given two strings A and B of lowercase letters, return true if you can swap two letters in A so the result is equal to B, otherwise, return false.\n    Swapping letters is defined as taking two indices i and j (0-indexed) such that i != j and swapping the characters at A[i] and A[j]. For example, swapping at indices 0 and 2 in \"abcd\" results in \"cbad\".\n    \n    Example 1:\n    Input: A = \"ab\", B = \"ba\"\n    Output: true\n    Explanation: You can swap A[0] = 'a' and A[1] = 'b' to get \"ba\", which is equal to B.\n    \n    Example 2:\n    Input: A = \"ab\", B = \"ab\"\n    Output: false\n    Explanation: The only letters you can swap are A[0] = 'a' and A[1] = 'b', which results in \"ba\" != B.\n    \n    Example 3:\n    Input: A = \"aa\", B = \"aa\"\n    Output: true\n    Explanation: You can swap A[0] = 'a' and A[1] = 'a' to get \"aa\", which is equal to B.\n    \n    Example 4:\n    Input: A = \"aaaaaaabc\", B = \"aaaaaaacb\"\n    Output: true\n    \n    Example 5:\n    Input: A = \"\", B = \"aa\"\n    Output: false\n    \n    \n    Constraints:\n    \n    0 <= A.length <= 20000\n    0 <= B.length <= 20000\n    A and B consist of lowercase letters.\n    \"\"\"\n", "entry_point": "buddy_strings", "test": "\ndef check(candidate):\n    assert candidate('ab', 'ba') == True\n    assert candidate('ab', 'ab') == False\n    assert candidate('aa', 'aa') == True\n    assert candidate('aaaaaaabc', 'aaaaaaacb') == True\n    assert candidate('', 'aa') == False\ncheck(buddy_strings)\n", "given_tests": ["assert buddy_strings('ab', 'ba') == True", "assert buddy_strings('ab', 'ab') == False", "assert buddy_strings('aa', 'aa') == True", "assert buddy_strings('aaaaaaabc', 'aaaaaaacb') == True", "assert buddy_strings('', 'aa') == False"], "canonical_solution": ["def buddy_strings(A: str, B: str) -> bool: return not (len(A) != len(B) or (set(A) != set(B) and len(set(A)) == len(A)) or sum([A[i] != B[i] for i in range(len(A))]) not in [0, 2])"], "difficulty": "introductory"}
{"task_id": "APPS/4777", "prompt": "def mystery_range(s: str, n: int) -> list[int]:\n    \"\"\"\n    In this kata, your task is to write a function that returns the smallest and largest integers in an unsorted string. In this kata, a range is considered a finite sequence of consecutive integers.\n    Input\n    Your function will receive two arguments:\n    \n    A string comprised of integers in an unknown range; think of this string as the result when a range of integers is shuffled around in random order then joined together into a string\n    An integer value representing the size of the range\n    \n    Output\n    Your function should return the starting (minimum) and ending (maximum) numbers of the range in the form of an array/list comprised of two integers.\n    \n    Test Example\n    \n    ```python\n    input_string = '1568141291110137'\n    \n    mystery_range(input_string, 10) # [6, 15]\n    \n    # The 10 numbers in this string are:\n    # 15 6 8 14 12 9 11 10 13 7\n    # Therefore the range of numbers is from 6 to 15\n    ```\n    \n    \n    Technical Details\n    \n    The maximum size of a range will be 100 integers\n    The starting number of a range will be: 0 < n < 100\n    Full Test Suite: 21 fixed tests, 100 random tests\n    Use Python 3+ for the Python translation\n    For JavaScript, require has been disabled and most built-in prototypes have been frozen (prototype methods can be added to Array and Function)\n    All test cases will be valid\n    \n    If you enjoyed this kata, be sure to check out my other katas\n    \"\"\"\n", "entry_point": "mystery_range", "test": "\ndef check(candidate):\n    assert candidate('1568141291110137', 10) == [6, 15]\ncheck(mystery_range)\n", "given_tests": ["assert mystery_range('1568141291110137', 10) == [6, 15]"], "canonical_solution": ["from collections import Counter\ndef mystery_range(s, n):\n    i, target = -1, Counter(s)\n    sum_ = sum(map(Counter, map(str, range(n))), Counter())\n    while True:\n        i += 1\n        sum_ = sum_ - Counter(str(i)) + Counter(str(i + n))\n        if sum_ == target:\n            if len(str(i + 1)) < len(str(i + n)) or \\\n                str(i + 1) in set(map(''.join, zip(*[iter(s)]*len(str(i + 1))))):\n                return [i + 1, i + n]"], "difficulty": "introductory"}
{"task_id": "APPS/2423", "prompt": "def min_start_value(nums: list[int]) -> int:\n    \"\"\"\n    Given an array of integers\u00a0nums, you start with an initial positive value startValue.\n    In each iteration, you calculate the step by step sum of startValue\u00a0plus\u00a0elements in nums\u00a0(from left to right).\n    Return the minimum positive value of\u00a0startValue such that the step by step sum is never less than 1.\n    \n    Example 1:\n    Input: nums = [-3,2,-3,4,2]\n    Output: 5\n    Explanation: If you choose startValue = 4, in the third iteration your step by step sum is less than 1.\n    step by step sum\n    startValue = 4 | startValue = 5 | nums\n    (4 -3 ) = 1  | (5 -3 ) = 2    |  -3\n    (1 +2 ) = 3  | (2 +2 ) = 4    |   2\n    (3 -3 ) = 0  | (4 -3 ) = 1    |  -3\n    (0 +4 ) = 4  | (1 +4 ) = 5    |   4\n    (4 +2 ) = 6  | (5 +2 ) = 7    |   2\n    \n    Example 2:\n    Input: nums = [1,2]\n    Output: 1\n    Explanation: Minimum start value should be positive.\n    \n    Example 3:\n    Input: nums = [1,-2,-3]\n    Output: 5\n    \n    \n    Constraints:\n    \n    1 <= nums.length <= 100\n    -100 <= nums[i] <= 100\n    \"\"\"\n", "entry_point": "min_start_value", "test": "\ndef check(candidate):\n    assert candidate([-3, 2, -3, 4, 2]) == 5\n    assert candidate([1, 2]) == 1\n    assert candidate([1, -2, -3]) == 5\ncheck(min_start_value)\n", "given_tests": ["assert min_start_value([-3, 2, -3, 4, 2]) == 5", "assert min_start_value([1,2]) == 1", "assert min_start_value([1,-2,-3]) == 5"], "canonical_solution": ["class Solution:\n    def minStartValue(self, nums: list[int]) -> int:\n        res = 1\n        for ind, n in enumerate(nums):\n            temp = 1 - sum(nums[:ind + 1])\n            if temp > res:\n                res = temp\n        return res"], "difficulty": "introductory"}
{"task_id": "APPS/2956", "prompt": "def encode(stg: str) -> str:\n    \"\"\"\n    *Translations appreciated*\n    \n    ## Background information\n    \n    The Hamming Code is used to correct errors, so-called bit flips, in data transmissions. Later in the description follows a detailed explanation of how it works.\n    In this Kata we will implement the Hamming Code with bit length 3, this has some advantages and disadvantages:\n    - \u2713 Compared to other versions of hamming code, we can correct more mistakes\n    - \u2713 It's simple to implement\n    - x  The size of the input triples\n    \n    \n    \n    ## Task 1: Encode function:\n    \n    First of all we have to implement the encode function, which is pretty easy, just follow the steps below.\n    \n    Steps:\n    1. convert every letter of our text to ASCII value\n    2. convert ASCII value to 8-bit binary string\n    3. replace every \"0\" with \"000\" and every \"1\" with \"111\"\n    \n    Let's do an example:\n    \n    We have to convert the string ```hey``` to hamming code sequence.\n    \n    1. First convert it to ASCII values:\n    \n    ```104``` for ```h```, ```101``` for ```e``` and ```121``` for ```y```.\n    \n    \n    2. Now we convert the ASCII values to a 8-bit binary string:\n    \n    ```104``` -> ```01101000```, ```101``` -> ```01100101``` and ```121``` -> ```01111001```\n    \n    if we concat the binarys we get ```011010000110010101111001```\n    \n    \n    3. Now we replace every \"0\" with \"000\" and every \"1\" with \"111\":\n    \n    ```011010000110010101111001``` -> ```000111111000111000000000000111111000000111000111000111111111111000000111```\n    \n    That's it good job!\n    \n    \n    ## Task 2: Decode function:\n    \n    Now we have to check if there happened any mistakes and correct them.\n    Errors will only be a bit flip and not a loose of bits, so the length of the input string is always divisible by 3.\n    \n    example:\n    - 111 --> 101  this can and will happen\n    - 111 --> 11   this won't happen\n    \n    The length of the input string is also always divsible by 24 so that you can convert it to an ASCII value.\n    \n    Steps:\n    1. Split the string of 0 and 1 in groups of three characters example: \"000\", \"111\"\n    2. Check if an error occured:\n    If no error occured the group is \"000\" or \"111\", then replace \"000\" with \"0\" and \"111\" with 1\n    If an error occured the group is for example \"001\" or \"100\" or \"101\" and so on...\n    Replace this group with the character that occurs most often. example: \"010\" -> \"0\" , \"110\" -> \"1\"\n    \n    3. Now take a group of 8 characters and convert that binary number to decimal ASCII value\n    4. Convert the ASCII value to a char and well done you made it :)\n    \n    \n    \n    Look at this example carefully to understand it better:\n    \n    We got a bit sequence:\n    \n    ```100111111000111001000010000111111000000111001111000111110110111000010111```\n    \n    First we split the bit sequence into groups of three:\n    \n    ```100```, ```111```, ```111```, ```000```, ```111```, ```001``` ....\n    \n    Every group with the most \"0\" becomes \"0\" and every group with the most \"1\" becomes \"1\":\n    \n    ```100``` -> ```0``` Because there are two ```0``` and only one ```1```\n    \n    ```111``` -> ```1``` Because there are zero ```0``` and three ```1```\n    \n    ```111``` -> ```1``` Because there are zero ```0``` and three ```1```\n    \n    ```000``` -> ```0``` Because there are three ```0``` and zero ```1```\n    \n    ```111``` -> ```1``` Because there are zero ```0``` and three ```1```\n    \n    ```001``` -> ```0``` Because there are two ```0``` and one ```1```\n    \n    Now concat all 0 and 1 to get ```011010000110010101111001```\n    \n    We split this string into groups of eight:\n    ```01101000```, ```01100101``` and ```01111001```.\n    \n    And now convert it back to letters:\n    \n    ```01101000``` is binary representation of 104, which is ASCII value of ```h```\n    \n    ```01100101``` is binary representation of 101, which is ASCII value of ```e```\n    \n    ```01111001``` is binary representation of 121, which is ASCII value of ```y```\n    \n    Now we got our word ```hey``` !\n    \"\"\"\n\n    def decode(bits: str) -> str:\n    \"\"\"\n    Now we have to check if there happened any mistakes and correct them.\n    Errors will only be a bit flip and not a loss of bits, so the length of the input string is always divisible by 3.\n    Split the string of 0 and 1 in groups of three characters. Check if an error occurred:\n    If no error occurred the group is '000' or '111', then replace '000' with '0' and '111' with '1'.\n    If an error occurred the group is for example '001' or '100' or '101' and so on...\n    Replace this group with the character that occurs most often. Take a group of 8 characters and convert that binary number to decimal ASCII value.\n    Convert the ASCII value to a character.\n\n    Args:\n    bits (str): The input string of bits to be decoded.\n\n    Returns:\n    str: The decoded string from the Hamming Code.\n    \"\"\"\n", "entry_point": "encode", "test": "\ndef check(candidate):\n    assert candidate('hey') == '000111111000111000000000000111111000000111000111000111111111111000000111'\n    assert candidate('The Sensei told me that i can do this kata') == '000111000111000111000000000111111000111000000000000111111000000111000111000000111000000000000000000111000111000000111111000111111000000111000111000111111000111111111000000111111111000000111111000111111000000111000111000111111000111000000111000000111000000000000000000111111111000111000000000111111000111111111111000111111000111111000000000111111000000111000000000000111000000000000000000111111000111111000111000111111000000111000111000000111000000000000000000111111111000111000000000111111000111000000000000111111000000000000111000111111111000111000000000000111000000000000000000111111000111000000111000000111000000000000000000111111000000000111111000111111000000000000111000111111000111111111000000000111000000000000000000111111000000111000000000111111000111111111111000000111000000000000000000111111111000111000000000111111000111000000000000111111000111000000111000111111111000000111111000000111000000000000000000111111000111000111111000111111000000000000111000111111111000111000000000111111000000000000111'\n    assert candidate('T3st') == '000111000111000111000000000000111111000000111111000111111111000000111111000111111111000111000000'\n    assert candidate('T?st!%') == '000111000111000111000000000000111111111111111111000111111111000000111111000111111111000111000000000000111000000000000111000000111000000111000111'\ncheck(encode)\n", "given_tests": ["assert encode('hey') == '000111111000111000000000000111111000000111000111000111111111111000000111'"], "canonical_solution": ["def encode(stg: str) -> str:\n    return ''.join(digit * 3 for char in stg for digit in f\"{ord(char):08b}\")\n\n\ndef decode(bits: str) -> str:\n    reduced = (get_digit(triplet) for triplet in chunks(bits, 3))\n    return ''.join(get_char(byte) for byte in chunks(''.join(reduced), 8))\n\n\ndef chunks(seq, size):\n    return (seq[i:i+size] for i in range(0, len(seq), size))\n\n\ndef get_digit(triplet):\n    return max(triplet, key=triplet.count)\n\n\ndef get_char(byte):\n    return chr(int(byte, 2))"], "difficulty": "introductory"}
{"task_id": "APPS/2480", "prompt": "def min_cost_to_move_chips(position: list[int]) -> int:\n    \"\"\"\n    We have n chips, where the position of the ith chip is position[i].\n    We need to move all the chips to the same position. In one step, we can change the position of the ith chip from position[i] to:\n    \n    position[i] + 2 or position[i] - 2 with cost = 0.\n    position[i] + 1 or position[i] - 1 with cost = 1.\n    \n    Return the minimum cost needed to move all the chips to the same position.\n    \n    Example 1:\n    \n    Input: position = [1,2,3]\n    Output: 1\n    Explanation: First step: Move the chip at position 3 to position 1 with cost = 0.\n    Second step: Move the chip at position 2 to position 1 with cost = 1.\n    Total cost is 1.\n    \n    Example 2:\n    \n    Input: position = [2,2,2,3,3]\n    Output: 2\n    Explanation: We can move the two chips at poistion 3 to position 2. Each move has cost = 1. The total cost = 2.\n    \n    Example 3:\n    Input: position = [1,1000000000]\n    Output: 1\n    \n    \n    Constraints:\n    \n    1 <= position.length <= 100\n    1 <= position[i] <= 10^9\n    \"\"\"\n", "entry_point": "min_cost_to_move_chips", "test": "\ndef check(candidate):\n    assert candidate([1, 2, 3]) == 1\n    assert candidate([2, 2, 2, 3, 3]) == 2\n    assert candidate([1, 1000000000]) == 1\ncheck(min_cost_to_move_chips)\n", "given_tests": ["assert min_cost_to_move_chips([1, 2, 3]) == 1", "assert min_cost_to_move_chips([2,2,2,3,3]) == 2", "assert min_cost_to_move_chips([1,1000000000]) == 1"], "canonical_solution": ["class Solution:\n    def minCostToMoveChips(self, position: list[int]) -> int:\n        d = {}\n        a = 0\n        b = 0\n        for i in position:\n            if i not in d:\n                d[i]=1\n            else:\n                d[i]+=1\n        for i in d:\n            if i % 2 == 0:\n                a += d[i]\n            else:\n                b += d[i]\n        return min(a, b)"], "difficulty": "introductory"}
{"task_id": "APPS/4715", "prompt": "def build_palindrome(s: str) -> str:\n    \"\"\"\n    ## Task\n    \n    Given a string, add the fewest number of characters possible from the front or back to make it a palindrome.\n    \n    ## Example\n    \n    For the input `cdcab`, the output should be `bacdcab`\n    \n    ## Input/Output\n    \n    Input is a string consisting of lowercase latin letters with length 3 <= str.length <= 10\n    \n    The output is a palindrome string satisfying the task.\n    \n    For s = `ab` either solution (`aba` or `bab`) will be accepted.\n    \"\"\"\n", "entry_point": "build_palindrome", "test": "\ndef check(candidate):\n    assert candidate('abcdc') == 'abcdcba'\n    assert candidate('ababa') == 'ababa'\ncheck(build_palindrome)\n", "given_tests": ["assert build_palindrome('cdcab') == 'bacdcab'"], "canonical_solution": ["def build_palindrome(s): return min((s[::-1][i:] + s for i in range(len(s)) if (s[::-1][i:] + s) == (s[::-1][i:] + s)[::-1]), key=len)"], "difficulty": "introductory"}
{"task_id": "APPS/2418", "prompt": "def containsDuplicate(nums: list[int]) -> bool:\n    \"\"\"\n    Given an array of integers, find if the array contains any duplicates.\n    \n    Your function should return true if any value appears at least twice in the array, and it should return false if every element is distinct.\n    \n    Example 1:\n    \n    \n    Input: [1,2,3,1]\n    Output: true\n    \n    Example 2:\n    \n    \n    Input: [1,2,3,4]\n    Output: false\n    \n    Example 3:\n    \n    \n    Input: [1,1,1,3,3,4,3,2,4,2]\n    Output: true\n    \"\"\"\n", "entry_point": "containsDuplicate", "test": "\ndef check(candidate):\n    assert candidate([1, 2, 3, 1]) == True\n    assert candidate([1, 2, 3, 4]) == False\n    assert candidate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]) == True\ncheck(containsDuplicate)\n", "given_tests": ["assert containsDuplicate([1, 2, 3, 1]) == True", "assert containsDuplicate([1, 2, 3, 4]) == False", "assert containsDuplicate([1, 1, 1, 3, 3, 4, 3, 2, 4, 2]) == True"], "canonical_solution": ["class Solution:\n    def containsDuplicate(self, nums: list[int]) -> bool:\n        return len(nums) != len(set(nums))"], "difficulty": "introductory"}
{"task_id": "APPS/3133", "prompt": "def vaccine_list(age: str, status: str, month: str) -> list[str]:\n    \"\"\"\n    ### Vaccinations for children under 5\n    You have been put in charge of administrating vaccinations for children in your local area. Write a function that will generate a list of vaccines for each child presented for vaccination, based on the child's age and vaccination history, and the month of the year.\n    #### The function takes three parameters: age, status and month\n    - The parameter 'age' will be given in weeks up to 16 weeks, and thereafter in months. You can assume that children presented will be scheduled for vaccination (eg '16 weeks', '12 months' etc).\n    - The parameter 'status' indicates if the child has missed a scheduled vaccination, and the argument will be a string that says 'up-to-date', or a scheduled stage (eg '8 weeks') that has been missed, in which case you need to add any missing shots to the list. Only one missed vaccination stage will be passed in per function call.\n    - If the month is 'september', 'october' or 'november' add 'offer fluVaccine' to the list.\n    - Make sure there are no duplicates in the returned list, and sort it alphabetically.\n    \n    #### Example input and output\n    ~~~~\n    input     ('12 weeks', 'up-to-date', 'december')\n    output    ['fiveInOne', 'rotavirus']\n    \n    input     ('12 months', '16 weeks', 'june')\n    output     ['fiveInOne', 'hibMenC', 'measlesMumpsRubella', 'meningitisB', 'pneumococcal']\n    \n    input     ('40 months', '12 months', 'october')\n    output    ['hibMenC', 'measlesMumpsRubella', 'meningitisB', 'offer fluVaccine', 'preSchoolBooster']\n    ~~~~\n    \n    #### To save you typing it up, here is the vaccinations list\n    ~~~~\n    fiveInOne : ['8 weeks', '12 weeks', '16 weeks'],\n    //Protects against: diphtheria, tetanus, whooping cough, polio and Hib (Haemophilus influenzae type b)\n    pneumococcal : ['8 weeks', '16 weeks'],\n    //Protects against: some types of pneumococcal infection\n    rotavirus : ['8 weeks', '12 weeks'],\n    //Protects against: rotavirus infection, a common cause of childhood diarrhoea and sickness\n    meningitisB : ['8 weeks', '16 weeks', '12 months'],\n    //Protects against: meningitis caused by meningococcal type B bacteria\n    hibMenC : ['12 months'],\n    //Protects against: Haemophilus influenzae type b (Hib), meningitis caused by meningococcal group C bacteria\n    measlesMumpsRubella : ['12 months', '40 months'],\n    //Protects against: measles, mumps and rubella\n    fluVaccine : ['september','october','november'],\n    //Given at: annually in Sept/Oct\n    preSchoolBooster : ['40 months']\n    //Protects against: diphtheria, tetanus, whooping cough and polio\n    ~~~~\n    \"\"\"\n", "entry_point": "vaccine_list", "test": "\ndef check(candidate):\n    assert candidate('12 weeks', 'up-to-date', 'december') == ['fiveInOne', 'rotavirus']\n    assert candidate('12 months', '16 weeks', 'june') == ['fiveInOne', 'hibMenC', 'measlesMumpsRubella', 'meningitisB', 'pneumococcal']\n    assert candidate('40 months', '12 months', 'october') == ['hibMenC', 'measlesMumpsRubella', 'meningitisB', 'offer fluVaccine', 'preSchoolBooster']\ncheck(vaccine_list)\n", "given_tests": ["assert vaccine_list('12 weeks', 'up-to-date', 'december') == ['fiveInOne', 'rotavirus']", "assert vaccine_list('12 months', '16 weeks', 'june') == ['fiveInOne', 'hibMenC', 'measlesMumpsRubella', 'meningitisB', 'pneumococcal']", "assert vaccine_list('40 months', '12 months', 'october') == ['hibMenC', 'measlesMumpsRubella', 'meningitisB', 'offer fluVaccine', 'preSchoolBooster']"], "canonical_solution": ["from itertools import chain\n\ndef vaccine_list(*args):\n    TOME = {\n        '8 weeks':   ['fiveInOne', 'pneumococcal', 'rotavirus', 'meningitisB'],\n        '12 weeks':  ['fiveInOne', 'rotavirus'],\n        '16 weeks':  ['fiveInOne', 'pneumococcal', 'meningitisB'],\n        '12 months': ['meningitisB', 'hibMenC', 'measlesMumpsRubella'],\n        '40 months': ['measlesMumpsRubella', 'preSchoolBooster'],\n        'september': ['offer fluVaccine'],\n        'october':   ['offer fluVaccine'],\n        'november':  ['offer fluVaccine'],\n    }\n    return sorted(set(chain.from_iterable(TOME.get(s,()) for s in args)))"], "difficulty": "introductory"}
{"task_id": "APPS/2387", "prompt": "def max_burles_spent(t: int, test_cases: list[int]) -> list[int]:\n    \"\"\"\n    Mishka wants to buy some food in the nearby shop. Initially, he has $s$ burles on his card.\n    \n    Mishka can perform the following operation any number of times (possibly, zero): choose some positive integer number $1 \\le x \\le s$, buy food that costs exactly $x$ burles and obtain $\\lfloor\\frac{x}{10}\\rfloor$ burles as a cashback (in other words, Mishka spends $x$ burles and obtains $\\lfloor\\frac{x}{10}\\rfloor$ back). The operation $\\lfloor\\frac{a}{b}\\rfloor$ means $a$ divided by $b$ rounded down.\n    \n    It is guaranteed that you can always buy some food that costs $x$ for any possible value of $x$.\n    \n    Your task is to say the maximum number of burles Mishka can spend if he buys food optimally.\n    \n    For example, if Mishka has $s=19$ burles then the maximum number of burles he can spend is $21$. Firstly, he can spend $x=10$ burles, obtain $1$ burle as a cashback. Now he has $s=10$ burles, so can spend $x=10$ burles, obtain $1$ burle as a cashback and spend it too.\n    \n    You have to answer $t$ independent test cases.\n    \n    \n    -----Input-----\n    \n    The first line of the input contains one integer $t$ ($1 \\le t \\le 10^4$) \u2014 the number of test cases.\n    \n    The next $t$ lines describe test cases. Each test case is given on a separate line and consists of one integer $s$ ($1 \\le s \\le 10^9$) \u2014 the number of burles Mishka initially has.\n    \n    \n    -----Output-----\n    \n    For each test case print the answer on it \u2014 the maximum number of burles Mishka can spend if he buys food optimally.\n    \n    \n    -----Example-----\n    Input\n    6\n    1\n    10\n    19\n    9876\n    12345\n    1000000000\n    \n    Output\n    1\n    11\n    21\n    10973\n    13716\n    1111111111\n    \"\"\"\n", "entry_point": "max_burles_spent", "test": "\ndef check(candidate):\n    assert candidate(6, [1, 10, 19, 9876, 12345, 1000000000]) == [1, 11, 21, 10973, 13716, 1111111111]\ncheck(max_burles_spent)\n", "given_tests": ["assert max_burles_spent(6, [1, 10, 19, 9876, 12345, 1000000000]) == [1, 11, 21, 10973, 13716, 1111111111]"], "canonical_solution": ["def max_burles_spent(t, test_cases):\n        results = []\n        for s in test_cases:\n            spent = 0\n            while s >= 10:\n                cashback = s // 10\n                spent += cashback * 10\n                s = s % 10 + cashback\n            spent += s\n            results.append(spent)\n        return results\n  "], "difficulty": "introductory"}
{"task_id": "APPS/4634", "prompt": "def pac_man(N: int, PM: list[int], enemies: list[list[int]]) -> int:\n    \"\"\"\n    # Task\n    Pac-Man got lucky today! Due to minor performance issue all his enemies have frozen. Too bad Pac-Man is not brave enough to face them right now, so he doesn't want any enemy to see him.\n    \n    Given a gamefield of size `N` x `N`, Pac-Man's position(`PM`) and his enemies' positions(`enemies`), your task is to count the number of coins he can collect without being seen.\n    \n    An enemy can see a Pac-Man if they are standing on the same row or column.\n    \n    It is guaranteed that no enemy can see Pac-Man on the starting position. There is a coin on each empty square (i.e. where there is no Pac-Man or enemy).\n    \n    # Example\n    \n    For `N = 4, PM = [3, 0], enemies = [[1, 2]]`, the result should be `3`.\n    ```\n    Let O represent coins, P - Pac-Man and E - enemy.\n    OOOO\n    OOEO\n    OOOO\n    POOO```\n    Pac-Man cannot cross row 1 and column 2.\n    \n    He can only collect coins from points `(2, 0), (2, 1) and (3, 1)`, like this:\n    ```\n    x is the points that Pac-Man can collect the coins.\n    OOOO\n    OOEO\n    xxOO\n    PxOO\n    ```\n    \n    # Input/Output\n    \n    \n    - `[input]` integer `N`\n    \n    The field size.\n    \n    \n    - `[input]` integer array `PM`\n    \n    Pac-Man's position (pair of integers)\n    \n    \n    - `[input]` 2D integer array `enemies`\n    \n    Enemies' positions (array of pairs)\n    \n    \n    - `[output]` an integer\n    \n    Number of coins Pac-Man can collect.\n    \n    \n    # More PacMan Katas\n    \n    - [Play PacMan: Devour all](https://www.codewars.com/kata/575c29d5fcee86cb8b000136)\n    \n    - [Play PacMan 2: The way home](https://www.codewars.com/kata/575ed46e23891f67d90000d8)\n    \"\"\"\n", "entry_point": "pac_man", "test": "\ndef check(candidate):\n    assert candidate(1, [0, 0], []) == 0\n    assert candidate(2, [0, 0], []) == 3\n    assert candidate(3, [0, 0], []) == 8\n    assert candidate(3, [1, 1], []) == 8\n    assert candidate(2, [0, 0], [[1, 1]]) == 0\n    assert candidate(3, [2, 0], [[1, 1]]) == 0\n    assert candidate(3, [2, 0], [[0, 2]]) == 3\n    assert candidate(10, [4, 6], [[0, 2], [5, 2], [5, 5]]) == 15\n    assert candidate(8, [1, 1], [[5, 4]]) == 19\n    assert candidate(8, [1, 5], [[5, 4]]) == 14\n    assert candidate(8, [6, 1], [[5, 4]]) == 7\ncheck(pac_man)\n", "given_tests": ["assert pac_man(1, [0, 0], []) == 0", "assert pac_man(10, [4, 6], [[0, 2], [5, 2], [5, 5]]) == 15", "assert pac_man(8, [1, 1], [[5, 4]]) == 19"], "canonical_solution": ["def pac_man(size, pacman, enemies): px, py = pacman; mx, my, Mx, My = -1, -1, size, size; for x, y in enemies: if x < px and x > mx: mx = x; if y < py and y > my: my = y; if x > px and x < Mx: Mx = x; if y > py and y < My: My = y; return (Mx - mx - 1) * (My - my - 1) - 1"], "difficulty": "introductory"}
{"task_id": "APPS/2537", "prompt": "def distanceBetweenBusStops(distance: List[int], start: int, destination: int) -> int:\n    \"\"\"\n    A bus\u00a0has n stops numbered from 0 to n - 1 that form\u00a0a circle. We know the distance between all pairs of neighboring stops where distance[i] is the distance between the stops number\u00a0i and (i + 1) % n.\n    The bus goes along both directions\u00a0i.e. clockwise and counterclockwise.\n    Return the shortest distance between the given\u00a0start\u00a0and destination\u00a0stops.\n    \n    Example 1:\n    \n    Input: distance = [1,2,3,4], start = 0, destination = 1\n    Output: 1\n    Explanation: Distance between 0 and 1 is 1 or 9, minimum is 1.\n    \n    Example 2:\n    \n    Input: distance = [1,2,3,4], start = 0, destination = 2\n    Output: 3\n    Explanation: Distance between 0 and 2 is 3 or 7, minimum is 3.\n    \n    \n    Example 3:\n    \n    Input: distance = [1,2,3,4], start = 0, destination = 3\n    Output: 4\n    Explanation: Distance between 0 and 3 is 6 or 4, minimum is 4.\n    \n    \n    Constraints:\n    \n    1 <= n\u00a0<= 10^4\n    distance.length == n\n    0 <= start, destination < n\n    0 <= distance[i] <= 10^4\n    \"\"\"\n", "entry_point": "distanceBetweenBusStops", "test": "\ndef check(candidate):\n    assert candidate([1, 2, 3, 4], 0, 1) == 1\n    assert candidate([1, 2, 3, 4], 0, 2) == 3\n    assert candidate([1, 2, 3, 4], 0, 3) == 4\ncheck(distanceBetweenBusStops)\n", "given_tests": ["assert distanceBetweenBusStops([1, 2, 3, 4], 0, 1) == 1", "assert distanceBetweenBusStops([1, 2, 3, 4], 0, 2) == 3", "assert distanceBetweenBusStops([1, 2, 3, 4], 0, 3) == 4"], "canonical_solution": ["class Solution:\n    def distanceBetweenBusStops(self, distance: List[int], start: int, destination: int) -> int:\n        if start > destination:\n            start, destination = destination, start\n        sum1 = sum(distance[start:destination])\n        sum2 = sum(distance) - sum1\n        return min(sum1, sum2)"], "difficulty": "introductory"}
{"task_id": "APPS/2520", "prompt": "def reverse(x: int) -> int:\n    \"\"\"\n    Given a 32-bit signed integer, reverse digits of an integer.\n    \n    Example 1:\n    \n    \n    Input: 123\n    Output: 321\n    \n    \n    Example 2:\n    \n    \n    Input: -123\n    Output: -321\n    \n    \n    Example 3:\n    \n    \n    Input: 120\n    Output: 21\n    \n    \n    Note:\n    Assume we are dealing with an environment which could only store integers within the 32-bit signed integer range: [\u2212231,\u00a0 231\u00a0\u2212 1]. For the purpose of this problem, assume that your function returns 0 when the reversed integer overflows.\n    \"\"\"\n", "entry_point": "reverse", "test": "\ndef check(candidate):\n    assert candidate(123) == 321\n    assert candidate(-123) == -321\n    assert candidate(120) == 21\ncheck(reverse)\n", "given_tests": ["assert reverse(123) == 321", "assert reverse(-123) == -321", "assert reverse(120) == 21"], "canonical_solution": ["class Solution:\n    def reverse(self, x: int) -> int:\n        sign = -1 if x < 0 else 1\n        x = abs(x)\n        rev = 0\n        while x != 0:\n            rev = rev * 10 + x % 10\n            x //= 10\n        rev *= sign\n        if rev < -2**31 or rev > 2**31 - 1:\n            return 0\n        return rev"], "difficulty": "introductory"}
{"task_id": "APPS/2394", "prompt": "def min_moves_to_regular_bracket_sequence(t: int, test_cases: list[tuple[int, str]]) -> list[int]:\n    \"\"\"\n    You are given a bracket sequence $s$ of length $n$, where $n$ is even (divisible by two). The string $s$ consists of $\\frac{n}{2}$ opening brackets '(' and $\\frac{n}{2}$ closing brackets ')'.\n    \n    In one move, you can choose exactly one bracket and move it to the beginning of the string or to the end of the string (i.e. you choose some index $i$, remove the $i$-th character of $s$ and insert it before or after all remaining characters of $s$).\n    \n    Your task is to find the minimum number of moves required to obtain regular bracket sequence from $s$. It can be proved that the answer always exists under the given constraints.\n    \n    Recall what the regular bracket sequence is:\n    \n    \"()\" is regular bracket sequence;  if $s$ is regular bracket sequence then \"(\" + $s$ + \")\" is regular bracket sequence;  if $s$ and $t$ are regular bracket sequences then $s$ + $t$ is regular bracket sequence.\n    \n    For example, \"()()\", \"(())()\", \"(())\" and \"()\" are regular bracket sequences, but \")(\", \"()(\" and \")))\" are not.\n    \n    You have to answer $t$ independent test cases.\n    \n    \n    -----Input-----\n    \n    The first line of the input contains one integer $t$ ($1 \\le t \\le 2000$) \u2014 the number of test cases. Then $t$ test cases follow.\n    \n    The first line of the test case contains one integer $n$ ($2 \\le n \\le 50$) \u2014 the length of $s$. It is guaranteed that $n$ is even. The second line of the test case containg the string $s$ consisting of $\\frac{n}{2}$ opening and $\\frac{n}{2}$ closing brackets.\n    \n    \n    -----Output-----\n    \n    For each test case, print the answer \u2014 the minimum number of moves required to obtain regular bracket sequence from $s$. It can be proved that the answer always exists under the given constraints.\n    \n    \n    -----Example-----\n    Input\n    4\n    2\n    )(\n    4\n    ()()\n    8\n    ())()()(\n    10\n    )))((((())\n    \n    Output\n    1\n    0\n    1\n    3\n    \n    \n    \n    -----Note-----\n    \n    In the first test case of the example, it is sufficient to move the first bracket to the end of the string.\n    \n    In the third test case of the example, it is sufficient to move the last bracket to the beginning of the string.\n    \n    In the fourth test case of the example, we can choose last three openning brackets, move them to the beginning of the string and obtain \"((()))(())\".\n    \"\"\"\n", "entry_point": "min_moves_to_regular_bracket_sequence", "test": "\ndef check(candidate):\n    assert candidate(4, [(2, ')('), (4, '()()'), (8, '())()()('), (10, ')))((((())')]) == [1, 0, 1, 3]\ncheck(min_moves_to_regular_bracket_sequence)\n", "given_tests": ["assert min_moves_to_regular_bracket_sequence(4, [(2, ')('), (4, '()()'), (8, '())()()('), (10, ')))((((())')]) == [1, 0, 1, 3]"], "canonical_solution": ["def min_moves_to_regular_bracket_sequence(t, test_cases):\n        results = []\n        for n, s in test_cases:\n            st = 0\n            fans = 0\n            for x in s:\n                if x == ')':\n                    st -= 1\n                else:\n                    st += 1\n                if st < 0:\n                    fans += 1\n                    st = 0\n            results.append(fans)\n        return results"], "difficulty": "introductory"}
{"task_id": "APPS/2469", "prompt": "def checkIfExist(arr: list[int]) -> bool:\n    \"\"\"\n    Given an array arr of integers, check if there exists two integers N and M such that N is the double of M ( i.e. N = 2 * M).\n    More formally check if there exists\u00a0two indices i and j such that :\n    \n    i != j\n    0 <= i, j < arr.length\n    arr[i] == 2 * arr[j]\n    \n    \n    Example 1:\n    Input: arr = [10,2,5,3]\n    Output: true\n    Explanation: N = 10 is the double of M = 5,that is, 10 = 2 * 5.\n    \n    Example 2:\n    Input: arr = [7,1,14,11]\n    Output: true\n    Explanation: N = 14 is the double of M = 7,that is, 14 = 2 * 7.\n    \n    Example 3:\n    Input: arr = [3,1,7,11]\n    Output: false\n    Explanation: In this case does not exist N and M, such that N = 2 * M.\n    \n    \n    Constraints:\n    \n    2 <= arr.length <= 500\n    -10^3 <= arr[i] <= 10^3\n    \"\"\"\n", "entry_point": "checkIfExist", "test": "\ndef check(candidate):\n    assert candidate([10, 2, 5, 3]) == True\n    assert candidate([7, 1, 14, 11]) == True\n    assert candidate([3, 1, 7, 11]) == False\ncheck(checkIfExist)\n", "given_tests": ["assert checkIfExist([10, 2, 5, 3]) == True", "assert checkIfExist([7, 1, 14, 11]) == True", "assert checkIfExist([3, 1, 7, 11]) == False"], "canonical_solution": ["def checkIfExist(arr):\n        found = {}\n        for num in arr:\n            if num * 2 in found:\n                return True\n            if num % 2 == 0 and num / 2 in found:\n                return True\n            found[num] = True\n        return False"], "difficulty": "introductory"}
{"task_id": "APPS/2379", "prompt": "def min_num_subsequences(t: int, test_cases: list[tuple[int, str]]) -> list[tuple[int, list[int]]]:\n    \"\"\"\n    You are given a binary string $s$ consisting of $n$ zeros and ones.\n    \n    Your task is to divide the given string into the minimum number of subsequences in such a way that each character of the string belongs to exactly one subsequence and each subsequence looks like \"010101 ...\" or \"101010 ...\" (i.e. the subsequence should not contain two adjacent zeros or ones).\n    \n    Recall that a subsequence is a sequence that can be derived from the given sequence by deleting zero or more elements without changing the order of the remaining elements. For example, subsequences of \"1011101\" are \"0\", \"1\", \"11111\", \"0111\", \"101\", \"1001\", but not \"000\", \"101010\" and \"11100\".\n    \n    You have to answer $t$ independent test cases.\n    \n    \n    -----Input-----\n    \n    The first line of the input contains one integer $t$ ($1 \\le t \\le 2 \\cdot 10^4$) \u2014 the number of test cases. Then $t$ test cases follow.\n    \n    The first line of the test case contains one integer $n$ ($1 \\le n \\le 2 \\cdot 10^5$) \u2014 the length of $s$. The second line of the test case contains $n$ characters '0' and '1' \u2014 the string $s$.\n    \n    It is guaranteed that the sum of $n$ does not exceed $2 \\cdot 10^5$ ($\\sum n \\le 2 \\cdot 10^5$).\n    \n    \n    -----Output-----\n    \n    For each test case, print the answer: in the first line print one integer $k$ ($1 \\le k \\le n$) \u2014 the minimum number of subsequences you can divide the string $s$ to. In the second line print $n$ integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le k$), where $a_i$ is the number of subsequence the $i$-th character of $s$ belongs to.\n    \n    If there are several answers, you can print any.\n    \n    \n    -----Example-----\n    Input\n    4\n    4\n    0011\n    6\n    111111\n    5\n    10101\n    8\n    01010000\n    \n    Output\n    2\n    1 2 2 1\n    6\n    1 2 3 4 5 6\n    1\n    1 1 1 1 1\n    4\n    1 1 1 1 1 2 3 4\n    \"\"\"\n", "entry_point": "min_num_subsequences", "test": "\ndef check(candidate):\n    assert candidate(4, [(4, '0011'), (6, '111111'), (5, '10101'), (8, '01010000')]) == [(2, [1, 2, 2, 1]), (6, [1, 2, 3, 4, 5, 6]), (1, [1, 1, 1, 1, 1]), (4, [1, 1, 1, 1, 1, 2, 3, 4])]\ncheck(min_num_subsequences)\n", "given_tests": ["assert min_num_subsequences(4, [(4, '0011'), (6, '111111'), (5, '10101'), (8, '01010000')]) == [(2, [1, 2, 2, 1]), (6, [1, 2, 3, 4, 5, 6]), (1, [1, 1, 1, 1, 1]), (4, [1, 1, 1, 1, 1, 2, 3, 4])]"], "canonical_solution": ["def min_num_subsequences(t, test_cases):\n        results = []\n        for n, s in test_cases:\n            zero_stack = []\n            one_stack = []\n            result = [0] * n\n            max_subsequences = 0\n            for i, ch in enumerate(s):\n                if ch == '0':\n                    if one_stack:\n                        idx = one_stack.pop()\n                        result[i] = idx\n                        zero_stack.append(idx)\n                    else:\n                        max_subsequences += 1\n                        result[i] = max_subsequences\n                        zero_stack.append(max_subsequences)\n                else:\n                    if zero_stack:\n                        idx = zero_stack.pop()\n                        result[i] = idx\n                        one_stack.append(idx)\n                    else:\n                        max_subsequences += 1\n                        result[i] = max_subsequences\n                        one_stack.append(max_subsequences)\n            results.append((max_subsequences, result))\n        return results"], "difficulty": "introductory"}
{"task_id": "APPS/4255", "prompt": "def make_upper_case(s: str) -> str:\n    \"\"\"\n    Write a function which converts the input string to uppercase.\n    \n    ~~~if:bf\n    For BF all inputs end with \\0, all inputs are lowercases and there is no space between.\n    ~~~\n    \"\"\"\n", "entry_point": "make_upper_case", "test": "\ndef check(candidate):\n    assert candidate('hello') == 'HELLO'\n    assert candidate('hello world') == 'HELLO WORLD'\n    assert candidate('hello world !') == 'HELLO WORLD !'\n    assert candidate('heLlO wORLd !') == 'HELLO WORLD !'\n    assert candidate('1,2,3 hello world!') == '1,2,3 HELLO WORLD!'\ncheck(make_upper_case)\n", "given_tests": ["assert make_upper_case('hello world !') == 'HELLO WORLD !'"], "canonical_solution": ["def make_upper_case(s): return s.upper()"], "difficulty": "introductory"}
{"task_id": "APPS/3843", "prompt": "def encrypt(text: str) -> str:\n    \"\"\"\n    For encrypting strings this region of chars is given (in this order!):\n    \n    * all letters (ascending, first all UpperCase, then all LowerCase)\n    * all digits (ascending)\n    * the following chars: `.,:;-?! '()$%&\"`\n    \n    These are 77 chars! (This region is zero-based.)\n    \n    Write two methods:\n    ```python\n    def encrypt(text)\n    def decrypt(encrypted_text)\n    ```\n    \n    Prechecks:\n    1. If the input-string has chars, that are not in the region, throw an Exception(C#, Python) or Error(JavaScript).\n    2. If the input-string is null or empty return exactly this value!\n    \n    For building the encrypted string:\n    1. For every second char do a switch of the case.\n    2. For every char take the index from the region. Take the difference from the region-index of the char before (from the input text! Not from the fresh encrypted char before!). (Char2 = Char1-Char2)\n    Replace the original char by the char of the difference-value from the region. In this step the first letter of the text is unchanged.\n    3. Replace the first char by the mirror in the given region. (`'A' -> '\"'`, `'B' -> '&'`, ...)\n    \n    Simple example:\n    \n    * Input:  `\"Business\"`\n    * Step 1: `\"BUsInEsS\"`\n    * Step 2: `\"B61kujla\"`\n    * `B -> U`\n    * `B (1) - U (20) = -19`\n    * `-19 + 77 = 58`\n    * `Region[58] = \"6\"`\n    * `U -> s`\n    * `U (20) - s (44) = -24`\n    * `-24 + 77 = 53`\n    * `Region[53] = \"1\"`\n    * Step 3: `\"&61kujla\"`\n    \n    This kata is part of the Simple Encryption Series:\n    Simple Encryption #1 - Alternating Split\n    Simple Encryption #2 - Index-Difference\n    Simple Encryption #3 - Turn The Bits Around\n    Simple Encryption #4 - Qwerty\n    \n    Have fun coding it and please don't forget to vote and rank this kata! :-)\n    \"\"\"\n\n\ndef decrypt(encrypted_text: str) -> str:\n    \"\"\"\n    The reverse process of the encryption described above.\n    \"\"\"\n", "entry_point": "encrypt", "test": "\ndef check(candidate):\n    assert candidate('$-Wy,dM79H\\'i\\'o$n0C&I.ZTcMJw5vPlZc Hn!krhlaa:khV mkL;gvtP-S7Rt1Vp2RV:wV9VuhO Iz3dqb.U0w') == 'Do the kata \"Kobayashi-Maru-Test!\" Endless fun and excitement when finding a solution!'\n    assert candidate('5MyQa9p0riYplZc') == 'This is a test!'\n    assert candidate('5MyQa79H\\'ijQaw!Ns6jVtpmnlZ.V6p') == 'This kata is very interesting!'\n    assert candidate('') == ''\n    assert candidate(None) == None\ncheck(encrypt)\n", "given_tests": ["assert encrypt('$-Wy,dM79H\\'i\\'o$n0C&I.ZTcMJw5vPlZc Hn!krhlaa:khV mkL;gvtP-S7Rt1Vp2RV:wV9VuhO Iz3dqb.U0w') == 'Do the kata \"Kobayashi-Maru-Test!\" Endless fun and excitement when finding a solution!'"], "canonical_solution": ["region = \"ABCDEFGHIJKLMNOPQRSTUVWXYZabcdefghijklmnopqrstuvwxyz0123456789.,:;-?! '()$%&\\\"\"\n\ndef decrypt(encrypted_text):\n    if not encrypted_text: return encrypted_text\n    \n    letters = list(encrypted_text)\n    letters[0] = region[-(region.index(letters[0]) + 1)]\n    for i in range(1, len(letters)):\n        letters[i] = region[region.index(letters[i - 1]) - region.index(letters[i])]\n    \n    for i in range(1, len(letters), 2):\n        letters[i] = letters[i].swapcase()\n\n    return \"\".join(letters)\n    \n\ndef encrypt(text):\n    if not text: return text\n    \n    letters = list(text)\n    for i in range(1, len(letters), 2):\n        letters[i] = text[i].swapcase()\n        \n    swapped = letters[:]\n    for i in range(1, len(letters)):\n        letters[i] = region[region.index(swapped[i - 1]) - region.index(swapped[i])]\n        \n    letters[0] = region[-(region.index(swapped[0]) + 1)]\n    return \"\".join(letters)"], "difficulty": "introductory"}
{"task_id": "APPS/2431", "prompt": "def find_unique_k_diff_pairs(arr: list[int], k: int) -> int:\n    \"\"\"\n    Given an array of integers and an integer k, you need to find the number of unique k-diff pairs in the array. Here a k-diff pair is defined as an integer pair (i, j), where i and j are both numbers in the array and their absolute difference is k.\n    \n    \n    \n    Example 1:\n    \n    Input: [3, 1, 4, 1, 5], k = 2\n    Output: 2\n    Explanation: There are two 2-diff pairs in the array, (1, 3) and (3, 5).Although we have two 1s in the input, we should only return the number of unique pairs.\n    \n    \n    \n    Example 2:\n    \n    Input:[1, 2, 3, 4, 5], k = 1\n    Output: 4\n    Explanation: There are four 1-diff pairs in the array, (1, 2), (2, 3), (3, 4) and (4, 5).\n    \n    \n    \n    Example 3:\n    \n    Input: [1, 3, 1, 5, 4], k = 0\n    Output: 1\n    Explanation: There is one 0-diff pair in the array, (1, 1).\n    \n    \n    \n    Note:\n    \n    The pairs (i, j) and (j, i) count as the same pair.\n    The length of the array won't exceed 10,000.\n    All the integers in the given input belong to the range: [-1e7, 1e7].\n    \"\"\"\n", "entry_point": "find_unique_k_diff_pairs", "test": "\ndef check(candidate):\n    assert candidate([3, 1, 4, 1, 5], 2) == 2\n    assert candidate([1, 2, 3, 4, 5], 1) == 4\n    assert candidate([1, 3, 1, 5, 4], 0) == 1\ncheck(find_unique_k_diff_pairs)\n", "given_tests": ["assert find_unique_k_diff_pairs([3, 1, 4, 1, 5], 2) == 2", "assert find_unique_k_diff_pairs([1, 2, 3, 4, 5], 1) == 4", "assert find_unique_k_diff_pairs([1, 3, 1, 5, 4], 0) == 1"], "canonical_solution": ["class Solution:\\n def findPairs(self, nums, k):\\n \\\"\\\"\\\"\\n :type nums: List[int]\\n :type k: int\\n :rtype: int\\n \\\"\\\"\\\"\\n if k < 0:\\n return 0\\n from collections import Counter\\n c = Counter(nums)\\n if k == 0:\\n return sum([1 for num, count in list(c.items()) if count > 1])\\n else:\\n return sum([1 for num, _ in list(c.items()) if num + k in c])\\n\\ndef find_unique_k_diff_pairs(arr: list[int], k: int) -> int:\\n sol = Solution()\\n return sol.findPairs(arr, k)"], "difficulty": "introductory"}
{"task_id": "APPS/1545", "prompt": "def check_parity_QC(n: int, cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    The Quark Codejam's number QC(n, m) represents the number of ways to partition a set of n things into m nonempty subsets. For example, there are seven ways to split a four-element set into two parts:\n    \n    {1, 2, 3} \u222a {4}, {1, 2, 4} \u222a {3}, {1, 3, 4} \u222a {2}, {2, 3, 4} \u222a {1},\n    \n    {1, 2} \u222a {3, 4}, {1, 3} \u222a {2, 4}, {1, 4} \u222a {2, 3}.\n    \n    We can compute QC(n, m) using the recurrence,\n    \n    QC(n, m) = mQC(n \u2212 1, m) + QC(n \u2212 1, m \u2212 1), for integers 1 < m < n.\n    \n    but your task is a somewhat different: given integers n and m, compute the parity of QC(n, m), i.e. QC(n, m) mod 2.\n    \n    Example :\n    \n    QC(4, 2) mod 2 = 1.\n    Write a program that reads two positive integers n and m, computes QC(n, m) mod 2, and writes the\n    \n    result.\n    \n    -----Input-----\n    The input begins with a single positive integer on a line by itself indicating the number of the cases. This line is followed by the input cases.\n    \n    The input consists two integers n and m separated by a space, with 1 \u2264 m \u2264 n \u2264 1000000000.\n    \n    -----Output-----\n    For each test case, print the output.\n    \n    The output should be the integer S(n, m) mod 2.\n    Sample Input\n    1\n    \n    4 2\n    Sample Output\n    1\n    \"\"\"\n", "entry_point": "check_parity_QC", "test": "\ndef check(candidate):\n    assert candidate(1, [(4, 2)]) == [1]\ncheck(check_parity_QC)\n", "given_tests": ["assert check_parity_QC(1, [(4, 2)]) == [1]"], "canonical_solution": "for i in range(eval(input())): n,k=input().strip().split(); n=int(n); k=int(k); print(int(((n-k)&(int((k-1)/2)))==0))", "difficulty": "interview"}
{"task_id": "APPS/910", "prompt": "def calculate_scales(T: int, test_cases: List[Tuple[str, int]]) -> List[int]:\n    \"\"\"\n    Recently, Chef got obsessed with piano. He is a just a rookie in this stuff and can not move his fingers from one key to other fast enough. He discovered that the best way to train finger speed is to play scales.\n    \n    There are different kinds of scales which are divided on the basis of their interval patterns. For instance, major scale is defined by pattern T-T-S-T-T-T-S, where \u2018T\u2019 stands for a whole tone whereas \u2018S\u2019 stands for a semitone. Two semitones make one tone. To understand how they are being played, please refer to the below image of piano\u2019s octave \u2013 two consecutive keys differ by one semitone.\n    \n    If we start playing from first key (note C), then we\u2019ll play all white keys in a row (notes C-D-E-F-G-A-B-C \u2013 as you can see C and D differ for a tone as in pattern, and E and F differ for a semitone).\n    \n    This pattern could be played some number of times (in cycle).\n    \n    \n    Each time Chef takes some type of a scale and plays using some number of octaves. Sometimes Chef can make up some scales, so please don\u2019t blame him if you find some scale that does not exist in real world.\n    \n    Formally, you have a set of 12 keys (i.e. one octave) and you have N such sets in a row. So in total, you have 12*N keys. You also have a pattern that consists of letters 'T' and 'S', where 'T' means move forward for two keys (from key x to key x + 2, and 'S' means move forward for one key (from key x to key x + 1).\n    \n    Now, you can start playing from any of the 12*N keys. In one play, you can repeat the pattern as many times as you want, but you cannot go outside the keyboard.\n    \n    Repeating pattern means that if, for example, you have pattern STTST, you can play STTST as well as STTSTSTTST, as well as STTSTSTTSTSTTST, as well as any number of repeating. For this pattern, if you choose to repeat it once, if you start at some key x, you'll press keys: x (letter 'S')-> x + 1 (letter 'T')-> x + 3 (letter 'T')-> x + 5 (letter 'S') -> x + 6 (letter 'T')-> x + 8. Also 1 \u2264 x, x + 8 \u2264 12*N so as to avoid going off the keyboard.\n    \n    You are asked to calculate number of different plays that can be performed. Two plays differ if and only if they start at different keys or patterns are repeated different number of times.\n    \n    -----Input-----\n    The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n    \n    First line of each test case contains scale\u2019s pattern \u2013 string s consisting of letters \u2018T\u2019 and \u2018S\u2019 only.\n    \n    Second line contains one integer N \u2013 number of octaves he\u2019ll be using.\n    \n    -----Output-----\n    For each test case output a single number in a line corresponding to number of different scales he\u2019ll play.\n    \n    -----Constraints-----\n    - 1 \u2264 T \u2264 105\n    - 1 \u2264 |S| \u2264 100\n    - 1 \u2264 n \u2264 7\n    \n    -----Subtasks-----\n    Subtask 1: T < 10 4, N = 1\n    Subtask 2: No additional constraints.\n    \n    -----Example-----\n    Input:\n    2\n    TTTT\n    1\n    TTSTTTS\n    3\n    \n    Output:\n    4\n    36\n    \n    -----Explanation-----\n    Example case 1. In the first case there is only one octave and Chef can play scale (not in cycle each time) starting with notes C, C#, D, D# - four together.\n    \"\"\"\n", "entry_point": "calculate_scales", "test": "\ndef check(candidate):\n    assert candidate(2, [('TTTT', 1), ('TTSTTTS', 3)]) == [4, 36]\ncheck(calculate_scales)\n", "given_tests": ["assert calculate_scales(2, [('TTTT', 1), ('TTSTTTS', 3)]) == [4, 36]"], "canonical_solution": "[\"t =int(input())\\r\\nfor i in range(t):\\r\\n    C=[ord(x)-ord('R') for x in list(input())]\\r\\n    N=int(input())\\r\\n    L=sum(C)\\r\\n    r=1\\r\\n    c=0\\r\\n    while(r*L<N*12):\\r\\n        c+=N*12-r*L\\r\\n        r+=1\\r\\n    print(c)\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\\r\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/1037", "prompt": "def pawn_chess(T: int, test_cases: List[str]) -> List[str]:\n    \"\"\"\n    Ada is playing pawn chess with Suzumo.\n    Pawn chess is played on a long board with N$N$ squares in one row. Initially, some of the squares contain pawns.\n    Note that the colours of the squares and pawns do not matter in this game, but otherwise, the standard chess rules apply:\n    - no two pawns can occupy the same square at the same time\n    - a pawn cannot jump over another pawn (they are no knights!), i.e. if there is a pawn at square i$i$, then it can only be moved to square i\u22122$i-2$ if squares i\u22121$i-1$ and i\u22122$i-2$ are empty\n    - pawns cannot move outside of the board (outs are forbidden)\n    The players alternate turns; as usual, Ada plays first. In each turn, the current player must choose a pawn and move it either one or two squares to the left of its current position. The player that cannot make a move loses.\n    Can Ada always beat Suzumo? Remember that Ada is a chess grandmaster, so she always plays optimally.\n    \n    -----Input-----\n    - The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n    - The first and only line of each test case contains a single string S$S$ with length N$N$ describing the initial board from left to right. An empty square and a square containing a pawn are denoted by the characters '.' and 'P' respectively.\n    \n    -----Output-----\n    For each test case, print a single line containing the string \"Yes\" if Ada wins the game or \"No\" otherwise (without quotes).\n    \n    -----Constraints-----\n    - 1\u2264T\u2264500$1 \\le T \\le 500$\n    - 2\u2264N\u2264128$2 \\le N \\le 128$\n    - S$S$ contains only characters '.' and 'P'\n    \n    -----Example Input-----\n    1\n    ..P.P\n    \n    -----Example Output-----\n    Yes\n    \n    -----Explanation-----\n    Example case 1: Ada can move the first pawn two squares to the left; the board after this move looks like\n    P...P\n    \n    and now, Suzumo can only move the second pawn. If he moves it one square to the left, Ada will move it two squares to the left on her next move, and if he moves it two squares to the left, Ada will move it one square to the left, so the board after Ada's next move will look like\n    PP...\n    \n    and Suzumo cannot make any move here.\n    \"\"\"\n", "entry_point": "pawn_chess", "test": "\ndef check(candidate):\n    assert candidate(1, ['..P.P']) == ['Yes']\ncheck(pawn_chess)\n", "given_tests": ["assert pawn_chess(1, ['..P.P']) == ['Yes']"], "canonical_solution": "[\"for _ in range(int(input())):\\n    s = input().strip()\\n    a = []\\n    last = 0\\n    for i in range(len(s)):\\n     if s[i] == 'P':\\n      a.append(i - last)\\n      last = i + 1\\n    x = 0\\n    a = a[::-1]\\n    for v in a[::2]:\\n     x ^= v % 3\\n    print('Yes' if x else 'No')\"]", "difficulty": "interview"}
{"task_id": "APPS/1562", "prompt": "def minimize_m(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[int]:\n    \"\"\"\n    \"I'm a fan of anything that tries to replace actual human contact.\" - Sheldon.\n    After years of hard work, Sheldon was finally able to develop a formula which would diminish the real human contact.\n    He found k$k$ integers n1,n2...nk$n_1,n_2...n_k$ . Also he found that if he could minimize the value of m$m$ such that  \u2211ki=1$\\sum_{i=1}^k$n$n$i$i$C$C$m$m$i$i$ is even, where m$m$ = \u2211ki=1$\\sum_{i=1}^k$mi$m_i$, he would finish the real human contact.\n    Since Sheldon is busy choosing between PS-4 and XBOX-ONE, he want you to help him to calculate the minimum value of m$m$.\n    \n    -----Input:-----\n    - The first line of the input contains a single integer T$T$ denoting the number of test cases. The\n    description of T$T$ test cases follows.\n    - The first line of each test case contains a single integer k$k$.\n    - Next line contains k space separated integers n1,n2...nk$n_1,n_2...n_k$ .\n    \n    -----Output:-----\n    For each test case output the minimum value of m for which \u2211ki=1$\\sum_{i=1}^k$n$n$i$i$C$C$m$m$i$i$ is even, where  m$m$=m1$m_1$+m2$m_2$+. . . mk$m_k$   and  0$0$ <= mi$m_i$<= ni$n_i$ .  If no such answer exists print -1.\n    \n    -----Constraints-----\n    - 1\u2264T\u22641000$1 \\leq T \\leq 1000$\n    - 1\u2264k\u22641000$1 \\leq k \\leq 1000$\n    - 1\u2264ni\u226410$1 \\leq n_i \\leq 10$18$18$\n    \n    -----Sample Input:-----\n    1\n    1\n    5\n    \n    -----Sample Output:-----\n    2\n    \n    -----EXPLANATION:-----\n    5$5$C$C$2$2$ = 10 which is even and m is minimum.\n    \"\"\"\n", "entry_point": "minimize_m", "test": "\ndef check(candidate):\n    assert candidate(1, [(1, [5])]) == [2]\ncheck(minimize_m)\n", "given_tests": ["assert minimize_m(1, [(1, [5])]) == [2]"], "canonical_solution": "[\"t = int(input())\\n\\ndef conv(n):\\n    k = bin(n)\\n    k = k[2:]\\n    z = len(k)\\n    c = '1'*z\\n    if c == k:\\n     return False\\n\\ndef find(n):\\n\\n    x = bin(n)[2:]\\n    str = ''\\n    for i in x[::-1]:\\n     if i == '0':\\n      str+='1'\\n      break\\n     else:\\n      str+='0'\\n\\n    return int(str[::-1],2)\\n\\nfor i in range(t):\\n\\n    n = int(input())\"]", "difficulty": "interview"}
{"task_id": "APPS/749", "prompt": "def min_additional_cost(N: int, costs: List[List[int]]) -> int:\n    \"\"\"\n    The Government of Siruseri is no different from any other when it comes to being \"capital-centric\" in its policies. Recently the government decided to set up a nationwide fiber-optic network to take Siruseri into the digital age. And as usual, this decision was implemented in a capital centric manner --- from each city in the country, a fiber optic cable was laid to the capital! Thus, traffic between any two cities had to go through the capital.\n    Soon, it became apparent that this was not quite a clever idea, since any breakdown at the capital resulted in the disconnection of services between other cities. So, in the second phase, the government plans to connect a few more pairs of cities directly by fiber-optic cables. The government has specified that this is to be done in such a way that the disruption of services at any one city will still leave the rest of the country connected.\n    The government has data on the cost of laying fiber optic cables between every pair of cities. You task is to compute the minimum cost of additional cabling required to ensure the requirement described above is met.\n    For example, if Siruseri has $4$ cities numbered $1,2,3$ and $4$ where $1$ is the capital and further suppose that the cost of laying cables between these cities are as given in the table below:\n    \n    Note that the government has already connected the capital with every other city. So, if we connect the cities $2$ and $3$ as well as $3$ and $4$, you can check that disruption of service at any one city will still leave the other cities connected. The cost of connecting these two pairs is $4 + 6 = 10$. The same effect could have been achieved by connecting $2$ and $3$ as well as $2$ and $4$, which would have cost $4 + 5 = 9$. You can check that this is the best you can do.\n    Your task is to write a program that allows the government to determine the minimum cost it has to incur in laying additional cables to fulfil the requirement.\n    \n    -----Input:-----\n    - The first line of the input contains a single integer $N$ indicating the number of cities in Siruseri. You may assume that the capital city is always numbered $1$.\n    - This is followed by $N$ lines of input each containing $N$ integers.\n    - The $j^{th}$ integer on line $i$ is the cost of connecting city $i$ with city $j$. The $j^{th}$ integer on line $i$ will be the same as the $i^{th}$ integer on line $j$ (since the links are bidirectional) and the $i^{th}$ entry on line $i$ will always be $0$ (there is no cost in connecting a city with itself).\n    \n    -----Output:-----\n    A single integer indicating the minimum total cost of the links to be added to ensure that disruption of services at one city does not disconnect the rest of the cities.\n    \n    -----Constraints:-----\n    - $1 \\leq N \\leq 2000$.\n    - $0 \\leq$ costs given in the input $\\leq 100000$\n    \n    -----Sample Input-----\n    4\n    0 7 8 10\n    7 0 4 5\n    8 4 0 6\n    10 5 6 0\n    \n    -----Sample Output-----\n    9\n    \"\"\"\n", "entry_point": "min_additional_cost", "test": "\ndef check(candidate):\n    assert candidate(4, [[0, 7, 8, 10], [7, 0, 4, 5], [8, 4, 0, 6], [10, 5, 6, 0]]) == 9\ncheck(min_additional_cost)\n", "given_tests": ["assert min_additional_cost(4, [[0, 7, 8, 10], [7, 0, 4, 5], [8, 4, 0, 6], [10, 5, 6, 0]]) == 9"], "canonical_solution": "[\"n=int(input())\\r\\nl=[]\\r\\nfor i in range(n):\\r\\n\\tl.append([int(x) for x in input().split()])\\r\\nd=[10**9]*(n)\\r\\nq=set([int(x) for x in range(1,n)])\\r\\nd[1]=0\\r\\n#print(q)\\r\\ndef extract():\\r\\n\\tmini=10**9\\r\\n\\to=0\\r\\n\\tfor i in range(1,len(d)):\\r\\n\\t\\tif d[i]<mini and i in q:\\r\\n\\t\\t\\tmini=d[i]\\r\\n\\t\\t\\to=i\\r\\n\\tq.remove(o)\\r\\n\\treturn o\\r\\nwhile len(q)!=0:\\r\\n\\tx=extract()\\r\\n\\tfor i in range(1,n):\\r\\n\\t\\tif i in q and l[x][i]<d[i]:\\r\\n\\t\\t\\td[i]=l[x][i]\\r\\nprint(sum(d[1:]))\"]", "difficulty": "interview"}
{"task_id": "APPS/613", "prompt": "def count_bubbly_words(M: int, words: List[str]) -> int:\n    \"\"\"\n    -----Problem-----\n    \n    Nikki's latest work is writing a story of letters. However, she finds writing story so boring that, after working for three hours, she realized that all she has written are M long words consisting entirely of letters A and B. Having accepted that she will never finish the story in time, Nikki has decided to at least have some fun with it by counting bubbly words.\n    \n    \n    Now Nikki is connecting pairs of identical letters (A with A, B with B) by drawing lines above the word. A given word is bubbly if each letter can be connected to exactly one other letter in such a way that no two lines intersect. So here is your task. Help Nikki count how many words are bubbly.\n    \n    -----Input-----\n    -\n    The first line of input contains the positive integer M, the number of words written down by Nikki.\n    \n    -\n    Each of the following M lines contains a single word consisting of letters A and B, with length\n    \n    between 2 and 10^5, inclusive. The sum of lengths of all words doesn't exceed 10^6.\n    \n    \n    -----Output-----\n    \n    The first and only line of output must contain the number of bubbly words.\n    \n    \n    -----Constraints-----\n    -\n    1 \u2264 M \u2264 100\n    \n    \n    -----Sample Input-----\n    \n    3\n    \n    ABAB\n    \n    AABB\n    \n    ABBA\n    \n    -----Sample Output-----\n    2\n    \n    -----Explanation-----\n    -\n    ABAB - It is not bubbly as A(indexed 1) will connect to A(indexed 3) by a line and when we try to connect B(indexed 2) with B(indexed 4) by a line then it will intersect with the line b/w A and A.\n    \n    -\n    AABB - It is bubbly as line b/w A and A will not intersect with the line b/w B and B.\n    \n    -\n    ABBA -It is also bubbly as lines will not intersect. We can draw line b/w A and A above the line b/w B and B.\n    p { text-align:justify }\n    \"\"\"\n", "entry_point": "count_bubbly_words", "test": "\ndef check(candidate):\n    assert candidate(3, ['ABAB', 'AABB', 'ABBA']) == 2\ncheck(count_bubbly_words)\n", "given_tests": ["assert count_bubbly_words(3, ['ABAB', 'AABB', 'ABBA']) == 2"], "canonical_solution": "[\"def check(s):\\n arr=[s[0]]\\n l=len(s)\\n f1=0\\n for i in range(1,l):\\n  if arr==[]: arr.append(s[i])\\n  elif arr[-1]!=s[i]:arr.append(s[i])\\n  else: del arr[-1]\\n if arr==[]: return True\\n else: return False\\n \\ncount = 0\\nfor t in range(eval(input())):\\n s=input().strip()\\n if check(s): count+=1\\nprint(count)\", \"count = 0\\nfor t in range(int(input())):\\n l = []\\n s = input()\\n for c in s:\\n  l.append(c)\\n  if (len(l)==1):\\n   continue\\n  else:\\n   if (l[-1]==l[-2]):\\n    l = l[:-2]\\n if (len(l)==0):\\n  count+=1\\nprint(count)\"]", "difficulty": "interview"}
{"task_id": "APPS/837", "prompt": "def sum_of_multiples(T: int, test_cases: List[int]) -> List[int]:\n    \"\"\"\n    Find sum of all the numbers that are multiples of 10 and are less than or equal to a given number \"N\". (quotes for clarity and be careful of integer overflow)\n    \n    -----Input-----\n    Input will start with an integer T the count of test cases, each case will have an integer N.\n    \n    -----Output-----\n    Output each values, on a newline.\n    \n    -----Constraints-----\n    - 1 \u2264 T \u2264 10\n    - 1 \u2264 N \u22641000000000\n    \n    -----Example-----\n    Input:\n    1\n    10\n    \n    Output:\n    10\n    \n    -----Explanation-----\n    Example case 1. Only integer that is multiple 10 that is less than or equal to 10 is 10\n    \"\"\"\n", "entry_point": "sum_of_multiples", "test": "\ndef check(candidate):\n    assert candidate(1, [10]) == [10]\n    assert candidate(2, [10, 20]) == [10, 30]\n    assert candidate(1, [1]) == [0]\n    assert candidate(3, [30, 40, 50]) == [60, 100, 150]\ncheck(sum_of_multiples)\n", "given_tests": ["assert sum_of_multiples(1, [10]) == [10]"], "canonical_solution": "[\"for t in range(eval(input())):\\n n=eval(input())\\n n-=n%10\\n n/=10\\n print(n*(n+1)/2*10)\", \"def tenn():\\n t=eval(input())\\n for i in range(t):\\n  a=eval(input())\\n  r=a/10\\n  t=(r*(r+1))/2\\n  print(t*10)\\ntenn()\\n\", \"t = int(input())\\nl = list()\\n\\nfor i in range(t):\\n n = int(input()) / 10\\n l.append(n)\\n \\nfor n in l:\\n print(int(n * (n + 1) / 2.0 * 10))\\n\", \"\\ndef main():\\n t=int(input())\\n while(t!=0):\\n  t=t-1\\n  N=int(input())\\n  print(5*int(N/10)*(int(N/10)+1))\\n return(0)\\n\\nmain()\", \"t=int(input())\\nwhile t:\\n n=int(input())\\n t-=1\\n r=n/10\\n r=10*(r*(r+1))/2\\n print(r)\"]", "difficulty": "interview"}
{"task_id": "APPS/725", "prompt": "def avoid_arrest(T: int, test_cases: List[Tuple[int, int, int, List[int]]]) -> List[int]:\n    \"\"\"\n    The Little Elephant and his friends from the Zoo of Lviv were returning from the party. But suddenly they were stopped by the policeman Big Hippo, who wanted to make an alcohol test for elephants.\n    There were N elephants ordered from the left to the right in a row and numbered from 0 to N-1. Let R[i] to be the result of breathalyzer test of i-th elephant.\n    Considering current laws in the Zoo, elephants would be arrested if there exists K consecutive elephants among them for which at least M of these K elephants have the maximal test result among these K elephants.\n    Using poor math notations we can alternatively define this as follows. The elephants would be arrested if there exists i from 0 to N-K, inclusive, such that for at least M different values of j from i to i+K-1, inclusive, we have R[j] = max{R[i], R[i+1], ..., R[i+K-1]}.\n    \n    The Big Hippo is very old and the Little Elephant can change some of the results. In a single operation he can add 1 to the result of any elephant. But for each of the elephants he can apply this operation at most once.\n    What is the minimum number of operations that the Little Elephant needs to apply, such that the sequence of results, after all operations will be applied, let elephants to avoid the arrest? If it is impossible to avoid the arrest applying any number of operations, output -1.\n    \n    -----Input-----\n    The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows. The first line of each test case contains three space-separated integers N, K, M. The second line contains N space-separated integers  R[0], R[1], ..., R[N-1] denoting the test results of the elephants.\n    \n    -----Output-----\n    For each test case, output a single line containing the minimum number of operations needed to avoid the arrest.\n    \n    -----Constraints-----\n    - 1 \u2264 T \u2264 10\n    - 1 \u2264 M \u2264 K \u2264 N \u2264 17\n    - 1 \u2264 R[i] \u2264 17\n    \n    -----Example-----\n    Input:\n    4\n    5 3 2\n    1 3 1 2 1\n    5 3 3\n    7 7 7 7 7\n    5 3 3\n    7 7 7 8 8\n    4 3 1\n    1 3 1 2\n    \n    Output:\n    0\n    1\n    1\n    -1\n    \n    -----Explanation-----\n    Example case 1. Let's follow the poor math definition of arrest. We will consider all values of i from 0 to N-K = 2, inclusive, and should count the number of values of j described in the definition. If it less than M = 2 then this value of i does not cause the arrest, otherwise causes.i{R[i],...,R[i+K-1]}max{R[i],...,R[i+K-1]}For which j = i, ..., i+K-1\n    we have R[j] = maxConclusioni=0{1, 3, 1}max = 3R[j] = 3 for j = 1does not cause the arresti=1{3, 1, 2}max = 3R[j] = 3 for j = 1does not cause the arresti=2{1, 2, 1}max = 2R[j] = 2 for j = 3does not cause the arrest\n    So we see that initial test results of the elephants do not cause their arrest. Hence the Little Elephant does not need to apply any operations. Therefore, the answer is 0.\n    Example case 2.We have N = 5, K = 3, M = 3. Let's construct similar table as in example case 1. Here the value of i will cause the arrest if we have at least 3 values of j described in the definition.i{R[i],...,R[i+K-1]}max{R[i],...,R[i+K-1]}For which j = i, ..., i+K-1\n    we have R[j] = maxConclusioni=0{7, 7, 7}max = 7R[j] = 7 for j = 0, 1, 2causes the arresti=1{7, 7, 7}max = 7R[j] = 7 for j = 1, 2, 3causes the arresti=2{7, 7, 7}max = 7R[j] = 7 for j = 2, 3, 4causes the arrest\n    So we see that for initial test results of the elephants each value of i causes their arrest. Hence the Little Elephant needs to apply some operations in order to avoid the arrest. He could achieve his goal by adding 1 to the result R[2]. Then results will be {R[0], R[1], R[2], R[3], R[4]} = {7, 7, 8, 7, 7}. Let's check that now elephants will be not arrested.i{R[i],...,R[i+K-1]}max{R[i],...,R[i+K-1]}For which j = i, ..., i+K-1\n    we have R[j] = maxConclusioni=0{7, 7, 8}max = 8R[j] = 8 for j = 2does not cause the arresti=1{7, 8, 7}max = 8R[j] = 8 for j = 2does not cause the arresti=2{8, 7, 7}max = 8R[j] = 8 for j = 2does not cause the arrest\n    So we see that now test results of the elephants do not cause their arrest. Thus we see that using 0 operations we can't avoid the arrest but using 1 operation can. Hence the answer is 1.\n    Example case 3.We have N = 5, K = 3, M = 3. Let's construct similar table as in example case 1. Here the value of i will cause the arrest if we have at least 3 values of j described in the definition.i{R[i],...,R[i+K-1]}max{R[i],...,R[i+K-1]}For which j = i, ..., i+K-1\n    we have R[j] = maxConclusioni=0{7, 7, 7}max = 7R[j] = 7 for j = 0, 1, 2causes the arresti=1{7, 7, 8}max = 8R[j] = 8 for j = 3does not cause the arresti=2{7, 8, 8}max = 8R[j] = 8 for j = 3, 4does not cause the arrest\n    So we see that for initial test results of the elephants the value of i = 0 causes their arrest. Hence the Little Elephant needs to apply some operations in order to avoid the arrest. He could achieve his goal by adding 1 to the result R[1]. Then results will be {R[0], R[1], R[2], R[3], R[4]} = {7, 8, 7, 8, 8}. Let's check that now elephants will be not arrested.i{R[i],...,R[i+K-1]}max{R[i],...,R[i+K-1]}For which j = i, ..., i+K-1\n    we have R[j] = maxConclusioni=0{7, 8, 7}max = 8R[j] = 8 for j = 1does not cause the arresti=1{8, 7, 8}max = 8R[j] = 8 for j = 1, 3does not cause the arresti=2{7, 8, 8}max = 8R[j] = 8 for j = 3, 4does not cause the arrest\n    So we see that now test results of the elephants do not cause their arrest. Thus we see that using 0 operations we can't avoid the arrest but using 1 operation can. Hence the answer is 1. Note that if we increase by 1 the result R[2] instead of R[1] then the value i = 2 will cause the arrest since {R[2], R[3], R[4]} will be {8, 8, 8} after this operation and we will have 3 values of j from 2 to 4, inclusive, for which R[j] = max{R[2], R[3], R[4]}, namely, j = 2, 3, 4.\n    Example case 4. When M = 1 the Little Elephant can't reach the goal since for each value of i from 0 to N-K we have at least one value of j for which R[j] = max{R[i], R[i+1], ..., R[i+K-1]}.\n    \"\"\"\n", "entry_point": "avoid_arrest", "test": "\ndef check(candidate):\n    assert candidate(4, [(5, 3, 2, [1, 3, 1, 2, 1]), (5, 3, 3, [7, 7, 7, 7, 7]), (5, 3, 3, [7, 7, 7, 8, 8]), (4, 3, 1, [1, 3, 1, 2])]) == [0, 1, 1, -1]\ncheck(avoid_arrest)\n", "given_tests": ["assert avoid_arrest(4, [(5, 3, 2, [1, 3, 1, 2, 1]), (5, 3, 3, [7, 7, 7, 7, 7]), (5, 3, 3, [7, 7, 7, 8, 8]), (4, 3, 1, [1, 3, 1, 2])]) == [0, 1, 1, -1]"], "canonical_solution": "def avoid_arrest(T, test_cases): def check(art, k, m): n = len(art); for i in range(n - k + 1): maxi = max(art[i:i + k]); total = art[i:i + k].count(maxi); if total >= m: return False; return True; results = []; for case in test_cases: n, k, m, arr = case; ans = float('inf'); for mask in range(1 << n): size = bin(mask).count('1'); if ans > size: art = arr.copy(); for i in range(n): if mask & (1 << i): art[i] += 1; if check(art, k, m): ans = size; results.append(ans if ans != float('inf') else -1); return results", "difficulty": "interview"}
{"task_id": "APPS/753", "prompt": "def max_nice_bouquet(T: int, test_cases: List[Tuple[List[int], List[int], List[int]]]) -> List[int]:\n    \"\"\"\n    It's autumn now, the time of the leaf fall.\n    Sergey likes to collect fallen leaves in autumn. In his city, he can find fallen leaves of maple, oak and poplar. These leaves can be of three different colors: green, yellow or red.\n    Sergey has collected some leaves of each type and color. Now he wants to create the biggest nice bouquet from them. He considers the bouquet nice iff all the leaves in it are either from the same type of tree or of the same color (or both). Moreover, he doesn't want to create a bouquet with even number of leaves in it, since this kind of bouquets are considered to attract bad luck. However, if it's impossible to make any nice bouquet, he won't do anything, thus, obtaining a bouquet with zero leaves.\n    Please help Sergey to find the maximal number of leaves he can have in a nice bouquet, which satisfies all the above mentioned requirements.\n    Please note that Sergey doesn't have to use all the leaves of the same color or of the same type. For example, if he has 20 maple leaves, he can still create a bouquet of 19 leaves.\n    \n    -----Input-----\n    IThe first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\"\n    The first line of each test case contains three space-separated integers MG MY MR denoting the number of green, yellow and red maple leaves respectively.\n    The second line contains three space-separated integers OG OY OR denoting the number of green, yellow and red oak leaves respectively.\n    The third line of each test case contains three space-separated integers PG PY PR denoting the number of green, yellow and red poplar leaves respectively.\n    \n    -----Output-----\n    For each test case, output a single line containing the maximal amount of flowers in nice bouquet, satisfying all conditions or 0 if it's impossible to create any bouquet, satisfying the conditions.\n    \n    -----Constraints-----\n    \n    - 1 \u2264 T \u2264 10000\n    - Subtask 1 (50 points): 0 \u2264 MG, MY, MR, OG, OY, OR, PG, PY, PR \u2264 5\n    - Subtask 2 (50 points): 0 \u2264 MG, MY, MR, OG, OY, OR, PG, PY, PR \u2264 109\n    \n    -----Example-----\n    Input:1\n    1 2 3\n    3 2 1\n    1 3 4\n    \n    Output:7\n    \n    -----Explanation-----\n    Example case 1. We can create a bouquet with 7 leaves, for example, by collecting all yellow leaves. This is not the only way to create the nice bouquet with 7 leaves (for example, Sergey can use all but one red leaves), but it is impossible to create a nice bouquet with more than 7 leaves.\n    \"\"\"\n", "entry_point": "max_nice_bouquet", "test": "\ndef check(candidate):\n    assert candidate(1, [([1, 2, 3], [3, 2, 1], [1, 3, 4])]) == [7]\ncheck(max_nice_bouquet)\n", "given_tests": ["assert max_nice_bouquet(1, [([1, 2, 3], [3, 2, 1], [1, 3, 4])]) == [7]"], "canonical_solution": ["for t in range(int(input())): l1=list(map(int,input().split())); l2=list(map(int,input().split())); l3=list(map(int,input().split())); max_bouquet=0; g=l1[0]+l2[0]+l3[0]; y=l1[1]+l2[1]+l3[1]; r=l1[2]+l2[2]+l3[2]; if g%2==0: g-=1; if y%2==0: y-=1; if r%2==0: r-=1; max_bouquet=max(max_bouquet, g, y, r); m=l1[0]+l1[1]+l1[2]; o=l2[0]+l2[1]+l2[2]; p=l3[0]+l3[1]+l3[2]; if m%2==0: m-=1; if o%2==0: o-=1; if p%2==0: p-=1; max_bouquet=max(max_bouquet, m, o, p); print(max_bouquet)"], "difficulty": "interview"}
{"task_id": "APPS/1419", "prompt": "def max_gcd_of_tracks(T: int, test_cases: List[Tuple[int, str, Tuple[int, int, int]]]) -> List[int]:\n    \"\"\"\n    Mr. Wilson was planning to record his new Progressive Rock music album called \"Digits. Cannot. Separate\". Xenny and PowerShell, popular pseudo-number-theoreticists from the Land of Lazarus were called by him to devise a strategy to ensure the success of this new album. Xenny and Powershell took their Piano Lessons and arrived at the Studio in different Trains.\n    Mr. Wilson, creative as usual, had created one single, long music track S. The track consisted of N musical notes. The beauty of each musical note was represented by a decimal digit from 0 to 9.\n    Mr. Wilson told them that he wanted to create multiple musical tracks out of this long song. Since Xenny and Powershell were more into the number theory part of music, they didn\u2019t know much about their real workings. Mr. Wilson told them that a separator could be placed between 2 digits. After placing separators, the digits between 2 separators would be the constituents of this new track and the number formed by joining them together would represent the Quality Value of that track. He also wanted them to make sure that no number formed had greater than M digits.\n    Mr. Wilson had Y separators with him. He wanted Xenny and PowerShell to use at least X of those separators, otherwise he would have to ask them to Drive Home.\n    Xenny and PowerShell knew straight away that they had to put place separators in such a way that the Greatest Common Divisor (GCD) of all the Quality Values would eventually determine the success of this new album. Hence, they had to find a strategy to maximize the GCD.\n    If you find the maximum GCD of all Quality Values that can be obtained after placing the separators, Xenny and PowerShell shall present you with a Porcupine Tree.\n    Note:\n    -\n    You can read about GCD here.\n    \n    -\n    Greatest Common Divisor of 0 and 0 is defined as 0.\n    \n    -----Input-----\n    The first line of input consists of a single integer T - the number of testcases.\n    Each test case is of the following format:\n    First line contains a single integer N - the length of the long musical track.\n    Second line contains the string of digits S.\n    Third line contains 3 space-separated integers - M, X and Y - the maximum number of digits in a number, the minimum number of separators to be used and the maximum number of separators to be used.\n    \n    -----Output-----\n    For each testcase, output a single integer on a new line - the maximum GCD possible after placing the separators.\n    \n    -----Constraints-----\n    Subtask 1: 20 points\n    \n    - 1 \u2264 T \u2264 10\n    - 1 \u2264 N \u2264 18\n    - 1 \u2264 M \u2264 2\n    - 1 \u2264 X \u2264 Y \u2264 (N - 1)\n    \n    Subtask 2: 80 points\n    \n    - 1 \u2264 T \u2264 10\n    - 1 \u2264 N \u2264 300\n    - 1 \u2264 M \u2264 10\n    - 1 \u2264 X \u2264 Y \u2264 (N - 1)\n    \n    For both Subtask 1 and Subtask 2:\n    \n    - 1 \u2264 X \u2264 Y \u2264 (N - 1)\n    - M*(Y+1) \u2265 N\n    - S may contain leading 0s.\n    \n    -----Example-----Input:\n    2\n    3\n    474\n    2 1 1\n    34\n    6311861109697810998905373107116111\n    10 4 25\n    \n    Output:\n    2\n    1\n    \n    -----Explanation-----\n    Test case 1.\n    Since only 1 separator can be placed, we can only have 2 possibilities:\n    \n    a. 4 | 74\n    \n    The GCD in this case is 2.\n    \n    b. 47 | 4\n    \n    The GCD in this case is 1.\n    \n    Hence, the maximum GCD is 2.\n    Test case 2.\n    \n    One of the optimal partitions is:\n    63|118|61|109|69|78|109|98|90|53|73|107|116|111\n    Bonus: Decode the above partition to unlock a hidden treasure.\n    \"\"\"\n", "entry_point": "max_gcd_of_tracks", "test": "\ndef check(candidate):\n    assert candidate(2, [(3, '474', (2, 1, 1)), (34, '6311861109697810998905373107116111', (10, 4, 25))]) == [2, 1]\ncheck(max_gcd_of_tracks)\n", "given_tests": ["assert max_gcd_of_tracks(2, [(3, '474', (2, 1, 1)), (34, '6311861109697810998905373107116111', (10, 4, 25))]) == [2, 1]"], "canonical_solution": ["def gcd (a, b): return a if (b == 0) else gcd (b, a % b)\n\ndp = {}\n\ndef solve (p, k, g, s, m, x, y, n):\n    if ((p, k, g) in dp): return dp[(p, k, g)]\n    ans = 0\n    if (p == n):\n        if k >= x and k <= y:\n            ans = g\n        else:\n            ans = 0\n    else:\n        for i in range (p, n):\n            if (i - p + 1 > m): break\n            temp = solve (i + 1, k + 1, gcd(g, int(s[p:i + 1])), s, m, x, y, n)\n            if (temp > ans): ans = temp\n    dp[(p, k, g)] = ans\n    return ans\n\nwhile t != 0:\n    dp = {}\n    t -= 1\n    n = int(input())\n    s = input()\n    m, x, y = list(map (int, input().split()))\n    x += 1\n    y += 1\n    print(solve (0, 0, 0, s, m, x, y, n))"], "difficulty": "interview"}
{"task_id": "APPS/669", "prompt": "def count_trips(T: int, test_cases: List[Tuple[int, int, int, List[Tuple[int, int]], int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"\n    Nadaca is a country with N$N$ cities. These cities are numbered 1$1$ through N$N$ and connected by M$M$ bidirectional roads. Each city can be reached from every other city using these roads.\n    Initially, Ryan is in city 1$1$. At each of the following K$K$ seconds, he may move from his current city to an adjacent city (a city connected by a road to his current city) or stay at his current city. Ryan also has Q$Q$ conditions (a1,b1),(a2,b2),\u2026,(aQ,bQ)$(a_1, b_1), (a_2, b_2), \\ldots, (a_Q, b_Q)$ meaning that during this K$K$-second trip, for each valid i$i$, he wants to be in city ai$a_i$ after exactly bi$b_i$ seconds.\n    Since you are very good with directions, Ryan asked you to tell him how many different trips he could make while satisfying all conditions. Compute this number modulo 109+7$10^9 + 7$. A trip is a sequence of Ryan's current cities after 1,2,\u2026,K$1, 2, \\ldots, K$ seconds.\n    \n    -----Input-----\n    - The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n    - The first line of each test case contains three space-separated integers N$N$, M$M$ and K$K$.\n    - Each of the next M$M$ lines contains two space-separated integers u$u$ and v$v$ denoting a road between cities u$u$ and v$v$.\n    - The next line contains a single integer Q$Q$.\n    - Q$Q$ lines follow. For each i$i$ (1\u2264i\u2264Q$1 \\le i \\le Q$), the i$i$-th of these lines contains two space-separated integers ai$a_i$ and bi$b_i$.\n    \n    -----Output-----\n    For each test case, print a single line containing one integer \u2014 the number of trips Ryan can make, modulo 109+7$10^9+7$.\n    \n    -----Constraints-----\n    - 1\u2264T\u226450$1 \\le T \\le 50$\n    - 1\u2264N,M,K,Q\u22649,000$1 \\le N, M, K, Q \\le 9,000$\n    - 1\u2264ui,vi\u2264N$1 \\le u_i, v_i \\le N$ for each valid i$i$\n    - ui\u2260vi$u_i \\neq v_i$ for each valid i$i$\n    - there is at most one road between each pair of cities\n    - each city is reachable from every other city\n    - 1\u2264ai\u2264N$1 \\le a_i \\le N$ for each valid i$i$\n    - 0\u2264bi\u2264K$0 \\le b_i \\le K$ for each valid i$i$\n    - the sum of N$N$ over all test cases does not exceed 9,000$9,000$\n    - the sum of K$K$ over all test cases does not exceed 9,000$9,000$\n    - the sum of M$M$ over all test cases does not exceed 9,000$9,000$\n    - the sum of Q$Q$ over all test cases does not exceed 9,000$9,000$\n    \n    -----Subtasks-----\n    Subtask #1 (20 points):\n    - the sum of N$N$ over all test cases does not exceed 400$400$\n    - the sum of K$K$ over all test cases does not exceed 400$400$\n    - the sum of M$M$ over all test cases does not exceed 400$400$\n    - the sum of Q$Q$ over all test cases does not exceed 400$400$\n    Subtask #2 (80 points): original constraints\n    \n    -----Example Input-----\n    3\n    4 3 3\n    1 2\n    1 3\n    1 4\n    0\n    4 3 3\n    1 2\n    1 3\n    1 4\n    1\n    2 2\n    4 3 3\n    1 2\n    1 3\n    1 4\n    1\n    2 1\n    \n    -----Example Output-----\n    28\n    4\n    6\n    \"\"\"\n", "entry_point": "count_trips", "test": "\ndef check(candidate):\n    assert candidate(3, [\n        (4, 3, 3, [(1, 2), (1, 3), (1, 4)], 0, []),\n        (4, 3, 3, [(1, 2), (1, 3), (1, 4)], 1, [(2, 2)]),\n        (4, 3, 3, [(1, 2), (1, 3), (1, 4)], 1, [(2, 1)])\n    ]) == [28, 4, 6]\ncheck(count_trips)\n", "given_tests": ["assert count_trips(3, [\n    (4, 3, 3, [(1, 2), (1, 3), (1, 4)], 0, []),\n    (4, 3, 3, [(1, 2), (1, 3), (1, 4)], 1, [(2, 2)]),\n    (4, 3, 3, [(1, 2), (1, 3), (1, 4)], 1, [(2, 1)])\n]) == [28, 4, 6]\n"], "canonical_solution": "[\"T = int(input()); for _ in range(T): N, M, K = [int(x) for x in input().split()]; UV = [[int(x) for x in input().split()] for _ in range(M)]; Q = int(input()); AB = [[int(x) for x in input().split()] for _ in range(Q)]; X = [[i] for i in range(N)]; for u, v in UV: X[u - 1] += [v - 1]; X[v - 1] += [u - 1]; A = [[1 if i > 0 or j == 0 else 0 for j in range(N)] for i in range(K + 1)]; for a, b in AB: A[b] = [1 if i == a - 1 else 0 for i in range(N)]; if A[0][0] == 1: for k in range(K - 1, -1, -1): for i in range(N): if A[k][i] != 0: A[k][i] = sum(A[k + 1][j] for j in X[i]); print(A[0][0])\"]", "difficulty": "interview"}
{"task_id": "APPS/1095", "prompt": "def min_moves_to_sort(N: int, books: List[int]) -> int:\n    \"\"\"\n    Indraneel has to sort the books in his library. His library has one long shelf. His books are numbered $1$ through $N$ and he wants to rearrange the books so that they appear in the sequence $1,2, ..., N$.\n    He intends to do this by a sequence of moves. In each move he can pick up any book from the shelf and insert it at a different place in the shelf. Suppose Indraneel has $5$ books and they are initially arranged in the order\n    21453214532 \\quad 1 \\quad 4 \\quad 5 \\quad 3\n    Indraneel will rearrange this in ascending order by first moving book $1$ to the beginning of the shelf to get\n    12453124531 \\quad 2 \\quad 4 \\quad 5 \\quad 3\n    Then, moving book $3$ to position $3$, he gets\n    12345123451 \\quad 2 \\quad 3 \\quad 4 \\quad 5\n    Your task is to write a program to help Indraneel determine the minimum number of moves that are necessary to sort his book shelf.\n    \n    -----Input:-----\n    The first line of the input will contain a single integer $N$ indicating the number of books in Indraneel's library. This is followed by a line containing a permutation of $1, 2, ..., N$ indicating the intial state of Indraneel's book-shelf.\n    \n    -----Output:-----\n    A single integer indicating the minimum number of moves necessary to sort Indraneel's book-shelf.\n    \n    -----Constraints:-----\n    - $1 \\leq N \\leq 200000$.\n    - You may also assume that in $50 \\%$ of the inputs, $1 \\leq N \\leq 5000$.\n    \n    -----Sample Input-----\n    5\n    2 1 4 5 3\n    \n    -----Sample Output-----\n    2\n    \"\"\"\n", "entry_point": "min_moves_to_sort", "test": "\ndef check(candidate):\n    assert candidate(5, [2, 1, 4, 5, 3]) == 2\ncheck(min_moves_to_sort)\n", "given_tests": ["assert min_moves_to_sort(5, [2, 1, 4, 5, 3]) == 2"], "canonical_solution": "[\"n=int(input())\\narr=[int(x) for x in input().split()]\\nl=[1]*n\\nif sorted(arr)==arr:\\n    print('0')\\nelse:\\n    for i in range(0,len(arr)):\\n        for j in range(i):\\n            if arr[i]>=arr[j] and l[i]<l[j]+1:\\n                l[i]=l[j]+1\\n    print(n-max(l))\", \"n=int(input())\\narr=[int(x) for x in input().split()]\\nl=[1]*n\\nif n==0 or n==1:\\n    print('0')\\nfor i in range(0,len(arr)):\\n    for j in range(i):\\n        if arr[i]>=arr[j] and l[i]<l[j]+1:\\n            l[i]=l[j]+1\\n\\nprint(n-max(l))\", \"n=int(input())\\narr=[int(x) for x in input().split()]\\nl=[1]*n\\nfor i in range(0,len(arr)):\\n    for j in range(i):\\n        if arr[i]>=arr[j] and l[i]<l[j]+1\\n            l[i]=l[j]+1\\n\\nprint(n-max(l))\"]", "difficulty": "interview"}
{"task_id": "APPS/407", "prompt": "def score_of_parentheses(S: str) -> int:\n    \"\"\"\n    Given a balanced parentheses string S, compute the score of the string based on the following rule:\n    \n    () has score 1\n    AB has score A + B, where A and B are balanced parentheses strings.\n    (A) has score 2 * A, where A is a balanced parentheses string.\n    \n    \n    \n    Example 1:\n    Input: \"()\"\n    Output: 1\n    \n    \n    Example 2:\n    Input: \"(())\"\n    Output: 2\n    \n    \n    Example 3:\n    Input: \"()()\"\n    Output: 2\n    \n    \n    Example 4:\n    Input: \"(()(()))\"\n    Output: 6\n    \n    \n    Note:\n    \n    S is a balanced parentheses string, containing only ( and ).\n    2 <= S.length <= 50\n    \"\"\"\n", "entry_point": "score_of_parentheses", "test": "\ndef check(candidate):\n    assert candidate('()') == 1\n    assert candidate('(())') == 2\n    assert candidate('()()') == 2\n    assert candidate('(()(()))') == 6\ncheck(score_of_parentheses)\n", "given_tests": ["assert score_of_parentheses('()') == 1", "assert score_of_parentheses('(())') == 2", "assert score_of_parentheses('()()') == 2", "assert score_of_parentheses('(()(()))') == 6"], "canonical_solution": "[\"class Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        ans, val = 0, 1\\n        for i in range(len(S) - 1):\\n            if S[i: i+2] == '((': val *= 2\\n            if S[i: i+2] == '()': ans += val\\n            if S[i: i+2] == '))': val //= 2\\n        return ans\", \"class Solution:\\n    def scoreOfParentheses(self, S: str) -> int:\\n        def h(i,j):\\n            if i > j:\\n                return 0\\n            c = 0\\n            ki = i\\n            x = 0\\n            for k in range(i,j+1):\\n                c += 1 if S[k] == '(' else -1\\n                if c == 0:\\n                    x+=max(1,2*h(ki+1,k-1))\\n                    ki = k+1\\n            return x\\n        return h(0,len(S)-1)\"]", "difficulty": "interview"}
{"task_id": "APPS/1591", "prompt": "def factorial_modulo(T: int, numbers: List[int]) -> List[int]:\n    \"\"\"\n    Master Oogway has forseen that a panda named Po will be the dragon warrior, and the master of Chi. But he did not tell anyone about the spell that would make him the master of Chi, and has left Po confused. Now Po has to defeat Kai, who is the super villian, the strongest of them all. Po needs to master Chi, and he finds a spell which unlocks his powerful Chi. But the spell is rather strange. It asks Po to calculate the factorial of a number! Po is very good at mathematics, and thinks that this is very easy. So he leaves the spell, thinking it's a hoax. But little does he know that this can give him the ultimate power of Chi. Help Po by solving the spell and proving that it's not a hoax.\n    \n    -----Input-----\n    First line of input contains an integer T denoting the number of test cases.\n    The next T lines contain an integer N.\n    \n    -----Output-----\n    For each test case, print a single line containing the solution to the spell which is equal to factorial of N, i.e. N!. Since the output could be large, output it modulo 1589540031(Grand Master Oogway's current age).\n    \n    -----Constraints-----\n    - 1 \u2264 T \u2264 100000\n    - 1 \u2264 N \u2264 100000\n    \n    -----Example-----\n    Input:\n    4\n    1\n    2\n    3\n    4\n    \n    Output:\n    1\n    2\n    6\n    24\n    \"\"\"\n", "entry_point": "factorial_modulo", "test": "\ndef check(candidate):\n    assert candidate(4, [1, 2, 3, 4]) == [1, 2, 6, 24]\ncheck(factorial_modulo)\n", "given_tests": ["assert factorial_modulo(4, [1, 2, 3, 4]) == [1, 2, 6, 24]"], "canonical_solution": "[\"arr = []\\narr.append(1)\\n_ = 1\\nwhile _<=100002:\\n arr.append(_*arr[_-1]%1589540031)\\n _+=1\\nfor _ in range(int(input())):\\n print(arr[int(input())])\"]", "difficulty": "interview"}
{"task_id": "APPS/820", "prompt": "def expected_cost(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int]]]]) -> List[float]:\n    \"\"\"\n    The Little Elephant from the Zoo of Lviv is going to the Birthday Party of  the Big Hippo tomorrow. Now he wants to prepare a gift for the Big Hippo.\n    \n    He has N balloons, numbered from 1 to N. The i-th balloon has the color Ci and it costs Pi dollars. The gift for the Big Hippo will be any subset (chosen randomly, possibly empty) of the balloons such that the number of different colors in that subset is at least M.\n    \n    Help Little Elephant to find the expected cost of the gift.\n    \n    -----Input-----\n    The first line of the input contains a single integer T - the number of test cases. T test cases follow. The first line of each test case contains a pair of integers N and M. The next N lines contain N pairs of integers Ci and Pi, one pair per line.\n    \n    -----Output-----\n    In T lines print T real numbers - the answers for the corresponding test cases. Your answer will considered correct if it has at most 10^-6 absolute or relative error.\n    \n    -----Constraints-----\n    - 1 \u2264 T \u2264 40\n    - 1 \u2264 N,  Ci\u2264 40\n    - 1 \u2264 Pi \u2264 1000000\n    - 0 \u2264 M \u2264 K, where K is the number of different colors in the test case.\n    \n    -----Example-----\n    Input:\n    2\n    2 2\n    1 4\n    2 7\n    2 1\n    1 4\n    2 7\n    \n    Output:\n    11.000000000\n    7.333333333\n    \"\"\"\n", "entry_point": "expected_cost", "test": "\ndef check(candidate):\n    assert abs(candidate(2, [(2, 2, [(1, 4), (2, 7)]), (2, 1, [(1, 4), (2, 7)])]) - [11.000000000, 7.333333333]) < 1e-6\ncheck(expected_cost)\n", "given_tests": ["assert abs(expected_cost(2, [(2, 2, [(1, 4), (2, 7)]), (2, 1, [(1, 4), (2, 7)])]) - [11.000000000, 7.333333333]) < 1e-6"], "canonical_solution": "[\"# cook your dish here\\nfor _ in range(int(input())):\\n    n,m = list(map(int,input().split()))\\n    colors = [0]*41; cost = [0]*41\\n    color = 0\\n    for i in range(n):\\n        cc,pp = list(map(int,input().split()))\\n        colors[cc] += 1\\n        cost[cc] += pp\\n    for i in colors:\\n        if i>0: color += 1\\n    dp2 = [[0]*41 for i in range(color+1)]\\n    dp2[0] = [1]*41\\n    for i in range(1,color+1):\\n        for j in range(1,41):\\n            dp2[i][j] = dp2[i][j-1]+dp2[i-1][j-1]*(2**colors[j]-1)\\n    dp1 = [[0]*41 for i in range(color+1)]\\n    for i in range(1,color+1):\\n        for j in range(1,41):\\n            dp1[i][j] = dp1[i][j-1]+dp1[i-1][j-1]*(2**colors[j]-1)+dp2[i-1][j-1]*cost[j]*(2**(colors[j]-1))\\n    num=den=0\\n    for i in range(m,color+1):\\n        num += dp1[i][40]\\n        den += dp2[i][40]\\n    print(num/den)\"]", "difficulty": "interview"}
{"task_id": "APPS/992", "prompt": "def minimum_cost_to_seal(T: int, test_cases: List[Tuple[int, List[Tuple[int, int]], int, List[Tuple[int, int]]]]) -> List[int]:\n    \"\"\"\n    January and February are usually very cold in ChefLand. The temperature may reach -20 and even -30 degrees Celsius. Because of that, many people seal up windows in their houses.\n    Sergey also lives in ChefLand. He wants to seal the window in his house. The window has the shape of a   simple convex polygon with N vertices.\n    For the sealing, there are M kinds of sticky stripes, which are sold in the shops. The stripe of the ith type has the length of Li millimeters and the cost of Ci rubles.\n    The sealing process consists in picking the stripe and sticking it on the border of the window. The stripe can't be cut (it is made of very lasting material) and can only be put straight, without foldings. It is not necessary to put the strip strictly on the window border, it can possibly extend outside the border side of window too (by any possible amount). The window is considered sealed up if every point on its' border is covered with at least one stripe.\n    Now Sergey is curious about the stripes he needs to buy. He wonders about the cheapest cost, at which he can seal his window. Please help him.\n    \n    -----Input-----\n    The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n    The first line of each test case contains a single integer N denoting the number of number of vertices in the polygon denoting Sergey's window.\n    Each of the following N lines contains a pair of space-separated integer numbers Xi Yi, denoting the coordinates of the ith points.\n    The following line contains a single integer M denoting the number of types of sticky stripe which is sold in the shop.\n    Each of the following M lines contains a pair of space-separated integers Li Ci denoting the length and the cost of the sticky stripe of the ith type respectively.\n    \n    -----Output-----\n    For each test case, output a single line containing the minimum cost of sealing up the window.\n    \n    -----Constraints-----\n    - 1 \u2264 T \u2264 10\n    - The coordinates of the window are given either in clockwise or in a counter-clockwise order.\n    - No three or more vertices lie on the same line (i.e. are collinear).\n    - 0 \u2264 Xi, Yi \u2264 106\n    - 1 \u2264 Li, Ci \u2264 106\n    \n    -----Subtasks-----\n    - Subtask #1 (17 points): 3 \u2264 N \u2264 10,  M = 1\n    - Subtask #2 (24 points): 3 \u2264 N \u2264 42, M \u2264 2\n    - Subtask #3 (59 points): 3 \u2264 N \u2264 2000, 1 \u2264 M \u2264 10\n    \n    -----Example-----\n    Input:1\n    4\n    0 0\n    1000 0\n    1000 2000\n    0 2000\n    2\n    1000 10\n    2000 15\n    \n    Output:50\n    \n    -----Explanation-----\n    Example case 1. In this case, Sergey's window is a rectangle with the side lengths of 1000 and 2000. There are two types of the sticky stripes in the shop - the one of the length 1000 with the cost of 10 rubles and with the length of 2000 and the cost of 15 rubles. The optimal solution would be to buy 2 stripes of the first type 2 stripes of the second type. The cost will be 2 \u00d7 15 + 2 \u00d7 10 = 50 rubles.\n    \"\"\"\n", "entry_point": "minimum_cost_to_seal", "test": "\ndef check(candidate):\n    assert candidate(1, [(4, [(0, 0), (1000, 0), (1000, 2000), (0, 2000)], 2, [(1000, 10), (2000, 15)])]) == [50]\ncheck(minimum_cost_to_seal)\n", "given_tests": ["assert minimum_cost_to_seal(1, [(4, [(0, 0), (1000, 0), (1000, 2000), (0, 2000)], 2, [(1000, 10), (2000, 15)])]) == [50]"], "canonical_solution": "[\"from math import sqrt\\nimport sys\\nsys.setrecursionlimit(10**8)\\nintMax = 10**18\\ndef knapsack(rl,l,c,m):\\n if m==0 and rl>0:\\n  return intMax\\n if rl<=0:\\n  return 0\\n return min(c[m-1]+knapsack(rl-l[m-1],l,c,m),knapsack(rl,l,c,m-1))\\nfor _ in range(int(input())):\\n n= int(input())\\n cost=[]\\n length=[]\\n sides=[]\\n for i in range(n):\\n  x,y = map(int,input().split())\\n  if i == 0:\\n   x0 = x\\n   y0 = y\\n   prevx = x\\n   prevy = y\\n  elif i == n-1:\\n   sides.append(sqrt((prevx-x)**2 + (prevy-y)**2))\\n   sides.append(sqrt((x0-x)**2 + (y0-y)**2))\\n  else:\\n   sides.append(sqrt((prevx-x)**2 + (prevy-y)**2))\\n   prevx = x\\n   prevy = y\\n m = int(input())\\n for j in range(m):\\n  li,ci = map(int,input().split())\\n  length.append(li)\\n  cost.append(ci)\\n ans=0\\n #print(sides)\\n for k in sides:\\n  ans= ans + knapsack(k,length,cost,m)\\n print(int(ans))\"]", "difficulty": "interview"}
{"task_id": "APPS/1427", "prompt": "def calculate_distances(N: int, M: int, catchers: List[Tuple[int, int]], S: str) -> List[int]:\n    \"\"\"\n    Today, puppy Tuzik is going to a new dog cinema. He has already left his home and just realised that he forgot his dog-collar! This is a real problem because the city is filled with catchers looking for stray dogs.\n    A city where Tuzik lives in can be considered as an infinite grid, where each cell has exactly four neighbouring cells: those sharing a common side with the cell. Such a property of the city leads to the fact, that the distance between cells (xA, yA) and (xB, yB) equals |xA - xB| + |yA - yB|.\n    Initially, the puppy started at the cell with coordinates (0, 0). There are N dog-catchers located at the cells with the coordinates (xi, yi), where 1 \u2264 i \u2264 N. Tuzik's path can be described as a string S of M characters, each of which belongs to the set {'D', 'U', 'L', 'R'} (corresponding to it moving down, up, left, and right, respectively). To estimate his level of safety, Tuzik wants to know the sum of the distances from each cell on his path to all the dog-catchers. You don't need to output this sum for the staring cell of the path (i.e. the cell with the coordinates (0, 0)).\n    \n    -----Input-----\n    The first line of the input contains two integers N and M.\n    The following N lines contain two integers xi and yi each, describing coordinates of the dog-catchers.\n    The last line of the input contains string S of M characters on the set {'D', 'U', 'L', 'R'}.\n    - 'D' - decrease y by 1\n    - 'U' - increase y by 1\n    - 'L' - decrease x by 1\n    - 'R' - increase x by 1\n    \n    -----Output-----\n    Output M lines: for each cell of the path (except the starting cell), output the required sum of the distances.\n    \n    -----Constraints-----\n    - 1 \u2264 N \u2264 3 \u2715 105\n    - 1 \u2264 M \u2264 3 \u2715 105\n    - -106 \u2264 xi, yi \u2264 106\n    \n    -----Example-----\n    Input:\n    2 3\n    1 2\n    0 1\n    RDL\n    \n    Output:\n    4\n    6\n    6\n    \n    -----Explanation-----\n    \n    Initially Tuzik stays at cell (0, 0). Let's consider his path:\n    \n    - Move 'R' to the cell (1, 0). Distance to the catcher (1, 2) equals 2, distance to the catcher (0, 1) equals 2, so the total distance equals 4\n    - Move 'D' to the cell (1, -1). Distance to the catcher (1, 2) equals 3, distance to the catcher (0, 1) equals 3, so the total distance equals 6\n    - Move 'L' to the cell (0, -1). Distance to the catcher (1, 2) equals 4, distance to the catcher (0, 1) equals 2, so the total distance equals 6\n    \"\"\"\n", "entry_point": "calculate_distances", "test": "\ndef check(candidate):\n    assert candidate(2, 3, [(1, 2), (0, 1)], 'RDL') == [4, 6, 6]\ncheck(calculate_distances)\n", "given_tests": ["assert calculate_distances(2, 3, [(1, 2), (0, 1)], 'RDL') == [4, 6, 6]"], "canonical_solution": "[\"# cook your dish here\\nfrom sys import stdin,stdout\\na,b=list(map(int,stdin.readline().split()))\\nleft=[]\\ntop=[]\\nfor i in range(a):\\n c,d=list(map(int,stdin.readline().split()))\\n left.append(c)\\n top.append(d)\\nleft.sort()\\ntop.sort()\\nfrom bisect import bisect_right as br\\nfrom bisect import bisect_left as bl\\nrow=0\\ncol=0\\ntotal=0\\ncons_x=0\\ncons_y=0\\nfor i in range(len(left)):\\n cons_x+=(abs(left[i]))\\n cons_y+=(abs(top[i]))\\ntotal=cons_x+cons_y\\ncc=stdin.readline().rstrip()\\nfor i in cc:\\n if i==\\\"R\\\":\\n  kk=br(left,col)\\n  cons_x=(cons_x+kk-(a-kk))\\n  col+=1\\n if i==\\\"L\\\":\\n  kk=bl(left,col)\\n  cons_x=(cons_x+(a-kk)-kk)\\n  col-=1\\n if i==\\\"U\\\":\\n  kk=br(top,row)\\n  cons_y=(cons_y+kk-(a-kk))\\n  row+=1\\n if i==\\\"D\\\":\\n  kk=bl(top,row)\\n  cons_y=(cons_y+(a-kk)-kk)\\n  row-=1\\n stdout.write(str(cons_x+cons_y))\\n stdout.write(\\\"\\\\n\\\")\\n  \\n\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/1090", "prompt": "def shortest_subsequence_length(T: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"\n    You are given a sequence of n integers a1, a2, ..., an and an integer d.\n    Find the length of the shortest non-empty contiguous subsequence with sum of elements at least d. Formally, you should find the smallest positive integer k with the following property: there is an integer s (1 \u2264 s \u2264 N-k+1) such that as + as+1 + ... + as+k-1 \u2265 d.\n    \n    -----Input-----\n    \n    - The first line of the input contains a single integer T denoting the number of test cases. The description of T test cases follows.\n    - The first line of each test case contains two space-separated integers n and d.\n    - The second line contains n space-separated integers a1, a2, ..., an.\n    \n    -----Output-----\n    For each test case, print a single line containing one integer \u2014 the length of the shortest contiguous subsequence with sum of elements \u2265 d. If there is no such subsequence, print -1 instead.\n    \n    -----Constraints-----\n    - 1 \u2264 T \u2264 105\n    - 1 \u2264 n \u2264 105\n    - -109 \u2264 d \u2264 109\n    - -104 \u2264 ai \u2264 104\n    - 1 \u2264 sum of n over all test cases \u2264 2 \u00b7 105\n    \n    -----Example-----\n    Input:\n    \n    2\n    5 5\n    1 2 3 1 -5\n    5 1\n    1 2 3 1 -5\n    \n    Output:\n    \n    2\n    1\n    \"\"\"\n", "entry_point": "shortest_subsequence_length", "test": "\ndef check(candidate):\n    assert candidate(2, [(5, 5, [1, 2, 3, 1, -5]), (5, 1, [1, 2, 3, 1, -5])]) == [2, 1]\ncheck(shortest_subsequence_length)\n", "given_tests": ["assert shortest_subsequence_length(2, [(5, 5, [1, 2, 3, 1, -5]), (5, 1, [1, 2, 3, 1, -5])]) == [2, 1]"], "canonical_solution": "[\"# cook your dish here\\nimport collections\\n\\ndef shortestSubarray(A, K):\\n    N = len(A)\\n    P = [0]\\n    for x in A:\\n        P.append(P[-1] + x)\\n    # Want smallest y-x with Py - Px >= K\\n    ans = N+1 # N+1 is impossible\\n    monoq = collections.deque() # opt(y) candidates, represented as indices of P\\n    for y, Py in enumerate(P):\\n        if not monoq:\\n            if Py >= K: return 1\\n        while monoq and Py <= P[monoq[-1]]:\\n            monoq.pop()\\n        while monoq and Py - P[monoq[0]] >= K:\\n            ans = min(ans, y - monoq.popleft())\\n        monoq.append(y)\\n    return ans if ans < N+1 else -1\\n\\nfor t in range(int(input())):\\n    N, D = [int(x) for x in input().split()]\\n    A = [int(x) for x in input().split()]\\n    print(shortestSubarray(A, D))\"]", "difficulty": "interview"}
{"task_id": "APPS/968", "prompt": "def find_path_costs(N: int, parents: List[int], values: List[int]) -> List[int]:\n    \"\"\"\n    You are given a rooted tree on N vertices. The nodes are numbered from 1 to N, and Node 1 is the root. Each node u has an associated value attached to it: Au.\n    For each vertex v, we consider the path going upwards from v to the root. Suppose that path is v1, v2, .., vk, where v1 = v and vk = 1. The cost of any node on this path is equal to the minimum value among all the nodes to its left in the path sequence, including itself. That is, cost(vi) = min1 <= j <= i{Avj}. And the cost of the path is the sum of costs of all the nodes in it.\n    For every node in the tree, find the cost of the path from that node to the root.\n    \n    -----Input-----\n    - The first line of the input contains a single integer, N, denoting the number of nodes in the tree.\n    - The next line contains N-1 integers, the i-th of which denotes the parent of node i+1.\n    - The next line contains N integers, the i-th of which denotes Ai.\n    \n    -----Output-----\n    Output a single line containing N integers, the i-th of which should be the cost of the path from node i to the root.\n    \n    -----Constraints-----\n    - 1 \u2264 N \u2264 100,000\n    - -1,000,000,000 \u2264 Av \u2264 1,000,000,000\n    \n    -----Subtasks-----\n    - Subtask #1 (30 points): 1 \u2264 N \u2264 2000\n    - Subtask #2 (70 points): Original constraints.\n    \n    -----Example-----\n    Input:\n    8\n    1 1 1 1 5 8 6\n    1 2 3 4 5 15 70 10\n    \n    Output:\n    1 3 4 5 6 21 96 26\n    \n    -----Explanation-----\n    For example, take a look at the path from vertex 7: The path is 7 -> 8 -> 6 -> 5 -> 1.\n    Cost(7) has no choice but to be A7. So Cost(7) = 70.\n    Cost(8) will be minimum of A7 and A8, which turns out to be A8. So Cost(8) = 10.\n    Cost(6) = minimum {A7, A8, A6} = minimum {70, 10, 15} = 10.\n    Cost(5) = minimum {70, 10, 15, 5} = 5.\n    Cost(1) = minimum {70, 10, 15, 5, 1} = 1.\n    So, the cost of the path from 7 to the root is 70 + 10 + 10 + 5 + 1 = 96.\n    \"\"\"\n", "entry_point": "find_path_costs", "test": "\ndef check(candidate):\n    assert candidate(8, [1, 1, 1, 1, 5, 8, 6], [1, 2, 3, 4, 5, 15, 70, 10]) == [1, 3, 4, 5, 6, 21, 96, 26]\ncheck(find_path_costs)\n", "given_tests": ["assert find_path_costs(8, [1, 1, 1, 1, 5, 8, 6], [1, 2, 3, 4, 5, 15, 70, 10]) == [1, 3, 4, 5, 6, 21, 96, 26]"], "canonical_solution": "[\"import sys\\nn = int(input())\\nparents = [int(x)-1 for x in input().split()]\\nvalues = list(map(int, input().split()))\\nparents = [0] + parents\\n\\ndef single_node_cost(i):\\n    cost = 0\\n    min_value = sys.maxsize\\n    while i != 0:\\n        min_value = min(min_value, values[i])\\n        cost += min_value\\n        i = parents[i]\\n    cost += min(values[0], min_value)\\n    return cost\\n\\nfor i in range(n):\\n    print(single_node_cost(i), end=' ')\"]", "difficulty": "interview"}
{"task_id": "APPS/1467", "prompt": "def min_lies(t: int, test_cases: List[Tuple[int, List[Tuple[str, int, str]]]]) -> List[int]:\n    \"\"\"\n    Alice and Johnny are playing a simple guessing game. Johnny picks an arbitrary positive integer n (1<=n<=109) and gives Alice exactly k hints about the value of n. It is Alice's task to guess n, based on the received hints.\n    \n    Alice often has a serious problem guessing the value of n, and she's beginning to suspect that Johnny occasionally cheats, that is, gives her incorrect hints.\n    After the last game, they had the following little conversation:\n    \n    - [Alice] Johnny, you keep cheating!\n    \n    - [Johnny] Indeed? You cannot prove it.\n    \n    - [Alice] Oh yes I can. In fact, I can tell you with the utmost certainty that in the last game you lied to me at least *** times.\n    \n    So, how many times at least did Johnny lie to Alice? Try to determine this, knowing only the hints Johnny gave to Alice.\n    \n    -----Input-----\n    The first line of input contains t, the number of test cases (about 20). Exactly t test cases follow.\n    \n    Each test case starts with a line containing a single integer k, denoting the number of hints given by Johnny (1<=k<=100000). Each of the next k lines contains exactly one hint. The i-th hint is of the form:\n    operator li logical_value\n    where operator denotes one of the symbols < , > , or =; li is an integer (1<=li<=109), while logical_value is one of the words: Yes or No. The hint is considered correct if logical_value is the correct reply to the question: \"Does the relation: n operator li hold?\", and is considered to be false (a lie) otherwise.\n    \n    -----Output-----\n    For each test case output a line containing a single integer, equal to the minimal possible number of Johnny's lies during the game.\n    \n    -----Example-----\n    Input:\n    3\n    2\n    < 100 No\n    > 100 No\n    3\n    < 2 Yes\n    > 4 Yes\n    = 3 No\n    6\n    < 2 Yes\n    > 1 Yes\n    = 1 Yes\n    = 1 Yes\n    > 1 Yes\n    = 1 Yes\n    \n    Output:\n    0\n    1\n    2\n    \n    Explanation: for the respective test cases, the number picked by Johnny could have been e.g. n=100, n=5, and n=1.\n    \"\"\"\n", "entry_point": "min_lies", "test": "\ndef check(candidate):\n    assert candidate(3, [(2, [('<', 100, 'No'), ('>', 100, 'No')]), (3, [('<', 2, 'Yes'), ('>', 4, 'Yes'), ('=', 3, 'No')]), (6, [('<', 2, 'Yes'), ('>', 1, 'Yes'), ('=', 1, 'Yes'), ('=', 1, 'Yes'), ('>', 1, 'Yes'), ('=', 1, 'Yes')])]) == [0, 1, 2]\ncheck(min_lies)\n", "given_tests": ["assert min_lies(3, [(2, [('<', 100, 'No'), ('>', 100, 'No')]), (3, [('<', 2, 'Yes'), ('>', 4, 'Yes'), ('=', 3, 'No')]), (6, [('<', 2, 'Yes'), ('>', 1, 'Yes'), ('=', 1, 'Yes'), ('=', 1, 'Yes'), ('>', 1, 'Yes'), ('=', 1, 'Yes')])]) == [0, 1, 2]"], "canonical_solution": "[\"# cook your dish here\\ndef guessingGame(l):\\n    a = []\\n    m = 1000000001\\n    for i in range(len(l)):\\n        k = int(l[i][1])\\n        if (l[i][0] == '<' and l[i][2] == 'Yes'):\\n            a.append((1, 1))\\n            a.append((k, -1))\\n        if (l[i][0] == '<' and l[i][2] == 'No'):\\n            a.append((k, 1))\\n            a.append((m, -1))\\n        if (l[i][0] == '=' and l[i][2] == 'Yes'):\\n            a.append((k, 1))\\n            a.append((k + 1, -1))\\n        if (l[i][0] == '=' and l[i][2] == 'No'):\\n            a.append((1, 1))\\n            a.append((k, -1))\\n            a.append((k + 1, 1))\\n            a.append((m, -1))\\n        if (l[i][0] == '>' and l[i][2] == 'Yes'):\\n            a.append((k + 1, 1))\\n            a.append((m, -1))\\n        if (l[i][0] == '>' and l[i][2] == 'No'):\\n            a.append((1, 1))\\n            a.append((k + 1, -1))\\n    a.sort()\\n    w = 0\\n    r = 0\\n    for i in range(len(a)):\\n        w += a[i][1]\\n        r = max(w, r)\\n    return len(l) - r\\n\\ndef __starting_point():\\n    T = int(input())\\n    answer = []\\n    for _ in range(T):\\n        e = int(input())\\n        temp = []\\n        for q_t in range(e):\\n            q = list(map(str, input().rstrip().split()))\\n            temp.append(q)\\n        result = guessingGame(temp)\\n        print(result)\\n__starting_point()\"]", "difficulty": "interview"}
{"task_id": "APPS/646", "prompt": "def min_string_length(T: int, test_cases: List[str]) -> List[int]:\n    \"\"\"\n    Given a string $s$.\n    You can perform the following operation on given string any number of time.\n    Delete two successive elements of the string if they are same.\n    After performing the above operation you have to return the least possible length of the string.\n    \n    -----Input:-----\n    - First line will contain $T$, number of testcases. Then the testcases follow.\n    - Each testcase contains of a single line of input, a string $s$.\n    \n    -----Output:-----\n    For each testcase, output in a single line answer- minimum length of string possible after performing given operations.\n    \n    -----Constraints-----\n    - $1 \\leq T \\leq 1000$\n    - $2 \\leq length of string \\leq 10^5$\n    $s$ contains only lowercase letters.\n    \n    -----Sample Input:-----\n    3\n    abccd\n    abbac\n    aaaa\n    \n    -----Sample Output:-----\n    3\n    1\n    0\n    \n    -----EXPLANATION:-----\n    - In first case, $\"abd\"$ will be final string.\n    - in second case, $\"c\"$ will be final string\n    \"\"\"\n", "entry_point": "min_string_length", "test": "\ndef check(candidate):\n    assert candidate(3, ['abccd', 'abbac', 'aaaa']) == [3, 1, 0]\ncheck(min_string_length)\n", "given_tests": ["assert min_string_length(3, ['abccd', 'abbac', 'aaaa']) == [3, 1, 0]"], "canonical_solution": "[\"from sys import stdin,stdout\\nimport math,bisect\\nfrom datetime import date\\nfrom collections import Counter,deque,defaultdict\\nL=lambda:list(map(int, stdin.readline().strip().split()))\\nM=lambda:list(map(int, stdin.readline().strip().split()))\\nI=lambda:int(stdin.readline().strip())\\nS=lambda:stdin.readline().strip()\\nC=lambda:stdin.readline().strip().split()\\ndef pr(a):return(\\\"\\\".join(list(map(str,a))))\\n#_________________________________________________#\\n\\ndef solve():\\n    s = list(S())\\n    a=[s[0]]\\n    for i in range(1,len(s)):\\n        if a and a[-1]==s[i]:\\n            a.pop()\\n        else:\\n            a.append(s[i])\\n    print(len(a))\\n    \\nfor _ in range(I()): \\n    solve()\\n\", \"for _ in range(int(input())):\\r\\n    inps = input().strip()\\r\\n    stck = [inps[0]]\\r\\n    for i in range(1, len(inps)):\\r\\n        if len(stck) > 0:\\r\\n            if inps[i] == stck[-1]:\\r\\n                stck.pop()\\r\\n            else:\\r\\n                stck.append(inps[i])\\r\\n        else:\\r\\n            stck.append(inps[i])\\r\\n    print(len(stck))\"]", "difficulty": "interview"}
{"task_id": "APPS/1561", "prompt": "def generate_tiles(T: int, cases: List[int]) -> List[str]:\n    \"\"\"\n    Chef Tobby asked Bhuvan to brush up his knowledge of statistics for a test. While studying some distributions, Bhuvan learns the fact that for symmetric distributions, the mean and the median are always the same.\n    Chef Tobby asks Bhuvan out for a game and tells him that it will utilize his new found knowledge. He lays out a total of 109 small tiles in front of Bhuvan. Each tile has a distinct number written on it from 1 to 109.\n    Chef Tobby gives Bhuvan an integer N and asks him to choose N distinct tiles and arrange them in a line such that the mean of median of all subarrays lies between [N-1, N+1], both inclusive. The median of subarray of even length is the mean of the two numbers in the middle after the subarray is sorted\n    Bhuvan realizes that his book didn\u2019t teach him how to solve this and asks for your help. Can you solve the problem for him?\n    In case, no solution exists, print -1.\n    \n    -----Input section-----\n    First line contains, T, denoting the number of test cases.\n    Each of the next T lines, contain a single integer N.\n    \n    -----Output section-----\n    If no solution, exists print -1.\n    If the solution exists, output N space separated integers denoting the elements of the array A such that above conditions are satisfied. In case, multiple answers exist, you can output any one them.\n    \n    -----Input constraints-----\n    1 \u2264 T \u2264 20\n    1 \u2264 N \u2264 100\n    \n    -----Sample Input-----\n    3\n    1\n    2\n    3\n    \n    -----Sample Output-----\n    1\n    1 2\n    1 2 3\n    \n    -----Explanation-----\n    For test case 3, the subarrays and their median are as follows:\n    - {1}, median = 1\n    - {2}, median = 2\n    - {3}, median = 3\n    - {1, 2}, median = 1.5\n    - {2, 3}, median = 2.5\n    - {1, 2, 3}, median = 2\n    The mean of the medians is 2 which lies in the range [2, 4]\n    \"\"\"\n", "entry_point": "generate_tiles", "test": "\ndef check(candidate):\n    assert candidate(3, [1, 2, 3]) == ['1', '1 2', '1 2 3']\ncheck(generate_tiles)\n", "given_tests": ["assert generate_tiles(3, [1, 2, 3]) == ['1', '1 2', '1 2 3']"], "canonical_solution": "[\"x=int(input())\\nfor a in range(x):\\n n=int(input())\\n L=[str(n)]\\n c=1\\n while(len(L)!=n):\\n  L.append(str(n+c))\\n  if len(L)==n:\\n   break\\n  L.append(str(n-c))\\n\\n  c+=1\\n\\n a=\\\" \\\".join(L)\\n\\n print(a)\\n\", \"t = int(input())\\nfor it in range(t):\\n n = int(input())\\n if n == 1:\\n  print(1, end=' ')\\n elif n%2 == 0:\\n  for i in range(n//2, n//2+n):\\n   print(i, end=' ')\\n else:\\n  for i in range(n//2, n//2+n):\\n   print(i, end=' ')\\n print('')\\n\", \"import sys\\n\\nt = int(sys.stdin.readline().strip())\\n\\nwhile t:\\n n = int(sys.stdin.readline().strip())\\n\\n if n == 1:\\n  st = 1\\n elif n == 2:\\n  st = \\\"1 2\\\"\\n elif n == 3:\\n  st = \\\"1 2 3\\\"\\n else:\\n  \\n  \\n  j = n//2 +1\\n  add = []\\n  for i in range(n):\\n   add.append(str(n-i+j-1))\\n\\n  st = \\\" \\\".join(add)\\n print(st)\\n \\n t-=1\\n\\n\\n\\n\\n\", \"import sys\\nt = int(sys.stdin.readline().strip())\\nc=[]\\nfor i in range(t):\\n c+=[int(sys.stdin.readline().strip())]\\n\\ndef check(s):\\n if s==1:\\n  return \\\"1\\\"\\n m = int(((s-1)/2.0)+0.6)\\n st=\\\"\\\"\\n for i in range(m,m+s):\\n  st=st+\\\"  \\\"+str(i)\\n return st[2:]\\n\\nfor h in c:\\n print(check(h))\"]", "difficulty": "interview"}
{"task_id": "APPS/1348", "prompt": "def shortest_average_path(T: int, test_cases: List[Tuple[int, int, List[Tuple[int, int, int]], Tuple[int, int]]]) -> List[float]:\n    \"\"\"\n    There are a lot of problems related to the shortest paths. Nevertheless, there are not much problems, related to the shortest paths in average.\n    Consider a directed graph G, consisting of N nodes and M edges. Consider a walk from the node A to the node B in this graph. The average length of this walk will be total sum of weight of its' edges divided by number of edges. Every edge counts as many times as it appears in this path.\n    Now, your problem is quite simple. For the given graph and two given nodes, find out the shortest average length of the walk between these nodes. Please note, that the length of the walk need not to be finite, but average walk length will be.\n    \n    -----Input-----\n    The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n    The first line of each test case contains a pair of space-separated integers N and M denoting the number of nodes and the number of edges in the graph.\n    Each of the following M lines contains a triple of space-separated integers Xi Yi Zi, denoting the arc, connecting the node Xi to the node Yi (but not vice-versa!) having the weight of Zi.\n    The next line contains a pair of space separated integers A and B, denoting the first and the last node of the path.\n    \n    -----Output-----\n    For each test case, output a single line containing the length of the shortest path in average.\n    If there is no path at all, output just -1 on the corresponding line of the output.\n    \n    -----Constraints-----\n    - 1 \u2264 N \u2264 500\n    - 1 \u2264 M \u2264 1000\n    - A is not equal to B\n    - 1 \u2264 A, B, Xi, Yi \u2264 N\n    - 1 \u2264 Zi \u2264 100\n    - There are no self-loops and multiple edges in the graph.\n    - 1 \u2264 sum of N over all test cases \u2264 10000\n    - 1 \u2264 sum of M over all test cases \u2264 20000\n    \n    -----Subtasks-----\n    - Subtask #1 (45 points): 1 \u2264 N \u2264 10, 1 \u2264 M \u2264 20; Your answer will be considered correct in case it has an absolute or relative error of no more than 10-2.\n    - Subtask #2 (55 points): no additional constraints; Your answer will be considered correct in case it has an absolute or relative error of no more than 10-6.\n    \n    -----Example-----\n    Input:2\n    3 3\n    1 2 1\n    2 3 2\n    3 2 3\n    1 3\n    3 3\n    1 2 10\n    2 3 1\n    3 2 1\n    1 3\n    \n    Output:1.5\n    1.0\n    \n    -----Explanation-----\n    Example case 1. The walk 1 -> 2 and 2 -> 3 has average length of 3/2 = 1.5. Any other walks in the graph will have more or equal average length than this.\n    \"\"\"\n", "entry_point": "shortest_average_path", "test": "\ndef check(candidate):\n    assert candidate(2, [(3, 3, [(1, 2, 1), (2, 3, 2), (3, 2, 3)], (1, 3)), (3, 3, [(1, 2, 10), (2, 3, 1), (3, 2, 1)], (1, 3))]) == [1.5, 1.0]\ncheck(shortest_average_path)\n", "given_tests": ["assert shortest_average_path(2, [(3, 3, [(1, 2, 1), (2, 3, 2), (3, 2, 3)], (1, 3)), (3, 3, [(1, 2, 10), (2, 3, 1), (3, 2, 1)], (1, 3))]) == [1.5, 1.0]"], "canonical_solution": "[\"from collections import defaultdict; import copy; def dfs(l, r, dct, n): visit = [0 for i in range(n+1)]; arr = [l]; while arr: node = arr.pop(); if node == r: return True; visit[node] = 1; for lnk in dct[node]: if not visit[lnk]: arr.append(lnk); return False; def ok(mid, cst, n, l, r, edges, dct): for i, j in edges: cst[i][j] -= mid; d = [10**9] * (n+1); d[l] = 0; for _ in range(n-1): for i, j in edges: d[j] = min(d[j], d[i] + cst[i][j]); if d[r] <= 0: return 1; for i, j in edges: if d[j] > d[i] + cst[i][j] and dfs(l, i, dct, n) and dfs(j, r, dct, n): return 1; return 0; def shortest_average_path(T, test_cases): results = []; for t in range(T): n, m, edges_data, (l, r) = test_cases[t]; dct = defaultdict(list); cost = [[1000 for _ in range(n+1)] for _ in range(n+1)]; edges = []; for x, y, z in edges_data: edges.append((x, y)); dct[x].append(y); cost[x][y] = min(cost[x][y], z); if not dfs(l, r, dct, n): results.append(-1); continue; lo, hi = 1, 101; for _ in range(100): cst = copy.deepcopy(cost); mid = (lo + hi) / 2; if ok(mid, cst, n, l, r, edges, dct): hi = mid - 1; else: lo = mid + 1; results.append(round(mid, 7)); return results\"]", "difficulty": "interview"}
{"task_id": "APPS/451", "prompt": "def check_reducible_anagrams(S: str, T: str) -> bool:\n    \"\"\"\n    Given two strings S and T, each of which represents a non-negative rational number, return True if and only if they represent the same number. The strings may use parentheses to denote the repeating part of the rational number.\n    In general a rational number can be represented using up to\u00a0three parts: an\u00a0integer part, a\u00a0non-repeating part, and a\u00a0repeating part. The number will be represented\u00a0in one of the following three ways:\n    \n    <IntegerPart> (e.g. 0, 12, 123)\n    <IntegerPart><.><NonRepeatingPart> \u00a0(e.g. 0.5, 1., 2.12, 2.0001)\n    <IntegerPart><.><NonRepeatingPart><(><RepeatingPart><)> (e.g. 0.1(6), 0.9(9), 0.00(1212))\n    \n    The repeating portion of a decimal expansion is conventionally denoted within a pair of round brackets.\u00a0 For example:\n    1 / 6 = 0.16666666... = 0.1(6) = 0.1666(6) = 0.166(66)\n    Both 0.1(6) or 0.1666(6) or 0.166(66) are correct representations of 1 / 6.\n    \n    Example 1:\n    Input: S = \"0.(52)\", T = \"0.5(25)\"\n    Output: true\n    Explanation:\n    Because \"0.(52)\" represents 0.52525252..., and \"0.5(25)\" represents 0.52525252525..... , the strings represent the same number.\n    \n    \n    Example 2:\n    Input: S = \"0.1666(6)\", T = \"0.166(66)\"\n    Output: true\n    \n    \n    Example 3:\n    Input: S = \"0.9(9)\", T = \"1.\"\n    Output: true\n    Explanation:\n    \"0.9(9)\" represents 0.999999999... repeated forever, which equals 1.  [See this link for an explanation.]\n    \"1.\" represents the number 1, which is formed correctly: (IntegerPart) = \"1\" and (NonRepeatingPart) = \"\".\n    \n    \n    \n    Note:\n    \n    Each part consists only of digits.\n    The <IntegerPart>\u00a0will\u00a0not begin with 2 or more zeros.\u00a0 (There is no other restriction on the digits of each part.)\n    1 <= <IntegerPart>.length <= 4\n    0 <= <NonRepeatingPart>.length <= 4\n    1 <= <RepeatingPart>.length <= 4\n    \"\"\"\n", "entry_point": "check_reducible_anagrams", "test": "\ndef check(candidate):\n    assert candidate(\"0.(52)\", \"0.5(25)\") == True\n    assert candidate(\"0.1666(6)\", \"0.166(66)\") == True\n    assert candidate(\"0.9(9)\", \"1.\") == True\ncheck(check_reducible_anagrams)\n", "given_tests": ["assert check_reducible_anagrams(\"0.(52)\", \"0.5(25)\") == True", "assert check_reducible_anagrams(\"0.1666(6)\", \"0.166(66)\") == True", "assert check_reducible_anagrams(\"0.9(9)\", \"1.\") == True"], "canonical_solution": "[\"import math; class Solution: def isRationalEqual(self, S: str, T: str) -> bool: if len(S) == 0 or len(T) == 0: return False; def process(s): if s[-1] == '.': s = s[:-1]; stack, repeat_9 = [], False; for i, x in enumerate(s): if x != ')': stack.append(x); else: tmp = ''; while stack[-1] != '(': tmp += stack.pop(); if len(tmp) == tmp.count('9'): repeat_9 = True; stack.pop(); return ''.join(stack) + tmp[::-1] * (24 // len(tmp)), repeat_9; return ''.join(stack), repeat_9; x, y = process(S), process(T); if x[0].count('.') == 0 or y[0].count('.') == 0: return float(x[0]) == float(y[0]); l = max(len(x[0]), len(y[0])); if x[0][:17] == y[0][:17]: return True; if x[1] or y[1]: m = min(len(x[0].split('.')[1]), len(y[0].split('.')[1])); if round(float(x[0]), m) == round(float(y[0]), m): return True; return False\"]", "difficulty": "interview"}
{"task_id": "APPS/1072", "prompt": "def check_reducible_anagrams(T: int, N: List[int]) -> List[str]:\n    \"\"\"\n    Problem description.\n    Winston and Royce love sharing memes with each other. They express the amount of seconds they laughed ar a meme as the number of \u2018XD\u2019 subsequences in their messages. Being optimization freaks, they wanted to find the string with minimum possible length and having exactly the given number of \u2018XD\u2019 subsequences.\n    \n    -----Input-----\n    - The first line of the input contains an integer T denoting the number of test cases.\n    - Next T lines contains a single integer N, the no of seconds laughed.\n    \n    -----Output-----\n    -\n    For each input, print the corresponding string having minimum length. If there are multiple possible answers, print any.\n    \n    -----Constraints-----\n    - 1 \u2264 T \u2264 1000\n    - 1 \u2264 N \u2264 109\n    - 1 \u2264 Sum of length of output over all testcases \u2264 5*105\n    \n    -----Example-----\n    Input:\n    1\n    9\n    \n    Output:\n    XXXDDD\n    \n    -----Explanation-----\n    Some of the possible strings are - XXDDDXD,XXXDDD,XDXXXDD,XDXDXDD etc. Of these, XXXDDD is the smallest.\n    \"\"\"\n", "entry_point": "check_reducible_anagrams", "test": "\ndef check(candidate):\n    assert candidate(1, [9]) == ['XXXDDD']\ncheck(check_reducible_anagrams)\n", "given_tests": ["assert check_reducible_anagrams(1, [9]) == ['XXXDDD']"], "canonical_solution": "[\"t=int(input())\\nfor i in range(t):\\n n=int(input())\\n r=int(n**(.5))\\n d=n-r*r\\n m=d%r\\n print('X'*m+'D'*(m>0)+'X'*(r-m)+'D'*(r+d//r))\\n\", \"from math import sqrt\\ndef solve():\\n n = int(input())\\n k = int(sqrt(n))\\n y = n - k * k\\n z = y % k\\n if z > 0:\\n  print('X'*z+'D'+'X'*(k - z)+'D'*(k+y//k))\\n else:\\n  print(\\\"X\\\" * k + \\\"D\\\" * (k+y//k))\\n t = int(input())\\nfor tt in range(0, t):\\n solve()\", \"T=int(input())\\nfor _ in range(T):\\n N=int(input())\\n r=int(N**.5)\\n d=N-r*r\\n m=d%r\\n print('X'*m+'D'*(m>0)+'X'*(r-m)+'D'*(r+d//r))\\n\", \"T=int(input())\\nfor _ in range(T):\\n N=int(input())\\n r=int(N**.5)\\n d=N-r*r\\n print('X'*(d%r)+'D'*(d%r>0)+'X'*(r-d%r)+'D'*(r+d//r))\\n\", \"T=int(input())\\nfor _ in range(T):\\n N=int(input())\\n r=int(N**.5)\\n d=N-r*r\\n if d==0:\\n  print('X'*r+'D'*r)\\n else:\\n  print('X'*(d%r)+'D'*(d%r>0)+'X'*(r-d%r)+'D'*(r+d//r))\\n\", \"from math import sqrt as S \\nfor _ in range(int(input())):\\n n=int(input())\\n a1=int(S(n))\\n a2=n//a1\\n rem=n-a1*a2 \\n ans=['X']*a1+['D']*a2\\n if rem:\\n  ans.insert(-rem,'X')\\n print(*ans,sep='')\", \"from math import sqrt as S \\nfor _ in range(int(input())):\\n n=int(input())\\n a1=int(S(n))\\n a2=n//a1\\n rem=n-a1*a2 \\n ans=['X']*a1+['D']*a2\\n if rem:\\n  ans.insert(-rem,'X')\\n print(*ans,sep='')\\n maxi=1 \\n for i in range(2,int(S(n))+1):\\n  if n%i==0 :\\n   maxi=max(maxi,i)\\n  \"]", "difficulty": "interview"}
{"task_id": "APPS/299", "prompt": "def min_cost(grid: List[List[int]]) -> int:\n    \"\"\"\n    Given a m x n grid. Each cell of the grid has a sign pointing to the next cell you should visit if you are currently in this cell. The sign of grid[i][j] can be:\n    \n    1 which means go to the cell to the right. (i.e go from grid[i][j] to grid[i][j + 1])\n    2 which means go to the cell to the left. (i.e go from grid[i][j] to grid[i][j - 1])\n    3 which means go to the lower cell. (i.e go from grid[i][j] to grid[i + 1][j])\n    4 which means go to the upper cell. (i.e go from grid[i][j] to grid[i - 1][j])\n    \n    Notice\u00a0that there could be some invalid signs on the cells of the grid which points outside the grid.\n    You will initially start at the upper left cell (0,0). A valid path in the grid is a path which starts from the upper left\u00a0cell (0,0) and ends at the bottom-right\u00a0cell (m - 1, n - 1) following the signs on the grid. The valid path doesn't have to be the shortest.\n    You can modify the sign on a cell with cost = 1. You can modify the sign on a cell one time only.\n    Return the minimum cost to make the grid have at least one valid path.\n    \n    Example 1:\n    \n    Input: grid = [[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]\n    Output: 3\n    Explanation: You will start at point (0, 0).\n    The path to (3, 3) is as follows. (0, 0) --> (0, 1) --> (0, 2) --> (0, 3) change the arrow to down with cost = 1 --> (1, 3) --> (1, 2) --> (1, 1) --> (1, 0) change the arrow to down with cost = 1 --> (2, 0) --> (2, 1) --> (2, 2) --> (2, 3) change the arrow to down with cost = 1 --> (3, 3)\n    The total cost = 3.\n    \n    Example 2:\n    \n    Input: grid = [[1,1,3],[3,2,2],[1,1,4]]\n    Output: 0\n    Explanation: You can follow the path from (0, 0) to (2, 2).\n    \n    Example 3:\n    \n    Input: grid = [[1,2],[4,3]]\n    Output: 1\n    \n    Example 4:\n    Input: grid = [[2,2,2],[2,2,2]]\n    Output: 3\n    \n    Example 5:\n    Input: grid = [[4]]\n    Output: 0\n    \n    \n    Constraints:\n    \n    m == grid.length\n    n == grid[i].length\n    1 <= m, n <= 100\n    \"\"\"\n", "entry_point": "min_cost", "test": "\ndef check(candidate):\n    assert candidate([[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]) == 3\n    assert candidate([[1,1,3],[3,2,2],[1,1,4]]) == 0\n    assert candidate([[1,2],[4,3]]) == 1\n    assert candidate([[2,2,2],[2,2,2]]) == 3\n    assert candidate([[4]]) == 0\ncheck(min_cost)\n", "given_tests": ["assert min_cost([[1,1,1,1],[2,2,2,2],[1,1,1,1],[2,2,2,2]]) == 3", "assert min_cost([[1,1,3],[3,2,2],[1,1,4]]) == 0", "assert min_cost([[1,2],[4,3]]) == 1", "assert min_cost([[2,2,2],[2,2,2]]) == 3", "assert min_cost([[4]]) == 0"], "canonical_solution": "[\"from collections import deque; def min_cost(grid): directions = [(0, 1), (0, -1), (1, 0), (-1, 0)]; direction_map = {1: (0, 1), 2: (0, -1), 3: (1, 0), 4: (-1, 0)}; m, n = len(grid), len(grid[0]); costs = [[float('inf')] * n for _ in range(m)]; costs[0][0] = 0; queue = deque([(0, 0)]); while queue: x, y = queue.popleft(); for k, (dx, dy) in direction_map.items(): nx, ny = x + dx, y + dy; if 0 <= nx < m and 0 <= ny < n: cost = costs[x][y] + (grid[x][y] != k); if cost < costs[nx][ny]: costs[nx][ny] = cost; if grid[x][y] == k: queue.appendleft((nx, ny)); else: queue.append((nx, ny)); return costs[-1][-1]\"]", "difficulty": "interview"}
{"task_id": "APPS/1565", "prompt": "def find_A_from_B(T: int, test_cases: List[Tuple[int, int, int, List[List[List[int]]]]]) -> List[List[List[int]]]:\n    \"\"\"\n    Suppose there is a X x Y x Z 3D matrix A of numbers having coordinates (i, j, k) where 0 \u2264 i < X, 0 \u2264 j < Y, 0 \u2264 k < Z. Now another X x Y x Z matrix B is defined from A such that the (i, j, k) element of B is the sum of all the the numbers in A in the cuboid defined by the (0, 0, 0) and (i, j, k) elements as the diagonally opposite vertices. In other word (i, j, k) in B is the sum of numbers of A having coordinates (a, b, c) such that 0 \u2264 a \u2264 i, 0 \u2264 b \u2264 j, 0 \u2264 c \u2264 k. The problem is that given B, you have to find out A.\n    \n    -----Input-----\n    The first line of input will contain the number of test cases ( \u2264 10). That many test cases will follow in subsequent lines. The first line of each test case will contain the numbers X Y Z (0 \u2264 X, Y, Z \u2264 100). After that there will be X x Y lines each containing Z numbers of B. The first line contains the numbers (0, 0, 0), (0, 0, 1)..., (0, 0, Z-1). The second line has the numbers (0, 1, 0), (0, 1, 1)..., (0, 1, Z-1) and so on. The (Y+1)th line will have the numbers (1, 0, 0), (1, 0, 1)..., (1, 0, Z-1) and so on.\n    \n    -----Output-----\n    For each test case print the numbers of A in exactly the same fashion as the input.\n    \n    -----Example-----\n    Input:\n    2\n    3 1 1\n    1\n    8\n    22\n    1 2 3\n    0 9 13\n    18 45 51\n    \n    Output:\n    1\n    7\n    14\n    0 9 4\n    18 18 2\n    \"\"\"\n", "entry_point": "find_A_from_B", "test": "\ndef check(candidate):\n    assert candidate(2, [(3, 1, 1, [[[1]], [[8]], [[22]]]), (1, 2, 3, [[[0, 9, 13], [18, 45, 51]]])]) == [[[1], [7], [14]], [[0, 9, 4], [18, 18, 2]]]\ncheck(find_A_from_B)\n", "given_tests": ["assert find_A_from_B(2, [(3, 1, 1, [[[1]], [[8]], [[22]]]), (1, 2, 3, [[[0, 9, 13], [18, 45, 51]]])]) == [[[1], [7], [14]], [[0, 9, 4], [18, 18, 2]]]"], "canonical_solution": "[\"# Problem: http://www.codechef.com/JULY09/submit/CUBESUM/; from typing import List, Tuple; def find_A_from_B(T: int, test_cases: List[Tuple[int, int, int, List[List[List[int]]]]]) -> List[List[List[int]]]: results = []; for case in test_cases: X, Y, Z, B = case; A = [[[0] * Z for _ in range(Y)] for _ in range(X)]; for i in range(X): for j in range(Y): for k in range(Z): result = B[i][j][k]; if i: result -= B[i - 1][j][k]; if j: result -= B[i][j - 1][k]; if k: result -= B[i][j][k - 1]; if i and j: result += B[i - 1][j - 1][k]; if i and k: result += B[i - 1][j][k - 1]; if j and k: result += B[i][j - 1][k - 1]; if i and j and k: result -= B[i - 1][j - 1][k - 1]; A[i][j][k] = result; results.append(A); return results\"]", "difficulty": "interview"}
{"task_id": "APPS/1314", "prompt": "def game_outcome(N: int, M: int, A: List[int], games: List[Tuple[str, int, str]]) -> str:\n    \"\"\"\n    Devu and Churu love to play games a lot. Today, they have an array A consisting of N positive integers. First they listed all N \u00d7 (N+1) / 2 non-empty continuous subarrays of the array A on a piece of paper and then replaced all the subarrays on the paper with the maximum element present in the respective subarray.\n    Devu and Churu decided to play a game with numbers on the paper. They both have decided to make moves turn by turn. In one turn, the player picks some number from the list and discards that number. The one who is not able to make a valid move will be the loser. To make the game more interesting, they decided to put some constraints on their moves.\n    A constraint on a game can be any of following three types :\n    -  > K : They are allowed to choose numbers having values strictly greater than K only.\n    -  < K : They are allowed to choose numbers having values strictly less than K only.\n    -  = K : They are allowed to choose numbers having values equal to K only.\n    \n    Given M constraints and who goes first, you have to tell the outcome of each game. Print 'D' if Devu wins otherwise print 'C' without quotes.\n    Note that M games are independent, that is, they'll rewrite numbers by using array A after each game. (This is the task for the loser of the previous game!)\n    \n    -----Input -----\n    First line of input contains two space separated integers N and M denoting the size of array A and number of game played by them. Next line of input contains N space-separated integers denoting elements of array A. Each of the next M lines of input contains three space-separated parameters describing a game. First two parameter are a character C \u2208 {<, >, =} and an integer K denoting the constraint for that game. The last parameter is a character X \u2208 {D, C} denoting the player who will start the game.\n    \n    ----- Output -----\n    Output consists of a single line containing a string of length M made up from characters D and C only, where ith character in the string denotes the outcome of the ith game.\n    \n    ----- Constraints: -----\n    - 1 \u2264 N, M \u2264 106\n    - 1 \u2264 Ai, K \u2264 109\n    - X \u2208 {D, C}\n    - C \u2208 {<, >, =}\n    \n    -----Subtasks: -----\n    - Subtask 1 : 1 \u2264 N, M \u2264 104 : ( 20 pts )\n    - Subtask 2 : 1 \u2264 N, M \u2264 105 : ( 30 pts )\n    - Subtask 3 : 1 \u2264 N, M \u2264 106 : ( 50 pts )\n    \n    -----Example:-----\n    Input:\n    3 5\n    1 2 3\n    > 1 D\n    < 2 C\n    = 3 D\n    > 4 C\n    < 5 D\n    \n    Output:\n    DCDDC\n    \n    -----Explanation: -----\n    Subarray List :\n    - [1]\n    \n    - [2]\n    \n    - [3]\n    \n    - [1,2]\n    \n    - [2,3]\n    \n    - [1,2,3]\n    \n    Numbers on the paper after replacement :\n    \n    - [1]\n    \n    - [2]\n    \n    - [3]\n    \n    - [2]\n    \n    - [3]\n    \n    - [3]\n    \n    Game 1 : There are only 5 numbers > 1 in the list.\n    Game 2 : There is only 1 number < 2 in the list.\n    Game 3 : There are only 3 numbers = 3 in the list.\n    Game 4 : There are no numbers > 4 in the list. So the first player cannot make his move.\n    Game 5 : There are 6 numbers < 5 in the list.\n    \"\"\"\n", "entry_point": "game_outcome", "test": "\ndef check(candidate):\n    assert candidate(3, 5, [1, 2, 3], [('>', 1, 'D'), ('<', 2, 'C'), ('=', 3, 'D'), ('>', 4, 'C'), ('<', 5, 'D')]) == 'DCDDC'\ncheck(game_outcome)\n", "given_tests": ["assert game_outcome(3, 5, [1, 2, 3], [('>', 1, 'D'), ('<', 2, 'C'), ('=', 3, 'D'), ('>', 4, 'C'), ('<', 5, 'D')]) == 'DCDDC'"], "canonical_solution": "[\"def left_span(arr,n):\\n ans=[0]\\n span=[0]\\n for i in range(1,n):\\n  \\n  while span and arr[i]>arr[span[-1]]:\\n   span.pop()\\n  \\n  if not span:\\n   ans.append(0)\\n   \\n  else:\\n   ans.append(span[-1]+1)\\n  span.append(i)\\n return ans\\n\\ndef right_span(arr,n):\\n ans=[n+1]\\n span=[n-1]\\n for i in range(n-2,-1,-1):\\n  \\n  while span and arr[i]>=arr[span[-1]]:\\n   span.pop()\\n   \\n  if not span:\\n   ans.append(n+1)\\n  else:\\n   ans.append(span[-1]+1)\\n  span.append(i)\\n return ans[::-1]\\nfrom collections import Counter\\nfrom bisect import bisect_left,bisect_right\\nfrom operator import itemgetter\\nn,q=list(map(int,input().split( )))\\narr=list(map(int,input().split( )))\\n\\nleft=left_span(arr,n)\\nright=right_span(arr,n)\\nc=Counter()\\nfor i in range(n):\\n c[arr[i]]+=(right[i]-(i+1))*(i+1-left[i])\\na=sorted(c)\\nf=[]\\nfor v in a:\\n f.append(c[v])\\nprefix_sum=[f[0]]\\nn=len(f)\\nfor i in range(1,n):\\n prefix_sum.append(f[i]+prefix_sum[-1])\\nr=[0]*q\\nfor i in range(q):\\n sign,k,player=list(map(str,input().split( )))\\n k=int(k)\\n if sign==\\\"=\\\":\\n  if k in c:\\n   res=c[k]\\n  else:\\n   res=0\\n elif sign==\\\">\\\":\\n  j=bisect_left(a,k)\\n  if j==n:\\n   res=0\\n  elif a[j]==k:\\n   res=prefix_sum[-1] - prefix_sum[j]\\n  else:\\n   if j>0:\\n    res=prefix_sum[-1] - prefix_sum[j-1]\\n   else:\\n    res=prefix_sum[-1]\\n else:\\n  j=bisect_left(a,k)\\n  if j==0:\\n   res=0\\n  else:\\n   res=prefix_sum[j-1]\\n \\n if res%2==0:\\n  if player==\\\"D\\\":\\n   r[i]=\\\"C\\\"\\n  else:\\n   r[i]=\\\"D\\\"\\n else:\\n  r[i]=player\\nprint(''.join(r))\\n   \\n  \\n\\n\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/986", "prompt": "def arrange_buildings(T: int, test_cases: List[Tuple[int, int]]) -> List[str]:\n    \"\"\"\n    Problem Statement:Captain America and Iron Man are at WAR and the rage inside Iron Man is rising.\n    \n    But Iron Man faces a problem to identify the location of Captain America.\n    \n    There are N buildings situtaed adjacently to each other and Captain America can be at any building.\n    \n    Iron Man has to arrange the Buildings from 1 to N is such a way that Value(i.e abs(Building Number -Position of Building))=K for every building.\n    \n    Can You help Iron Man to Find The Arrangement of the Buildings?\n    \n    P.S- If no arrangement exist, then print\n    \u201cCAPTAIN AMERICA EVADES\u201d.\n    \n    Input Format:\n    The first line of input contains a single integer,T, denoting the number of test cases.\n    \n    Each of the T  subsequent lines contains 2 space-separated integers describing the respective N and K values for a test case.\n    \n    Output Format:\n    On a new line for each test case,\n    \n    Print the lexicographically smallest arrangement;\n    \n    If no absolute arrangement exists, print \u201cCAPTAIN AMERICA EVADES\u201d.\n    \n    Constraints:\n    SubTask#1\n    1<=T<=10\n    \n    1<=N<=10^5\n    \n    0<=K<=N\n    \n    SubTask#2\n    Original Constraints..\n    \n    SubTask#3\n    Original Constraints..\n    \n    Sample Input:\n    3\n    \n    2 1\n    \n    3 0\n    \n    3 2\n    \n    Sample Output:\n    \n    2 1\n    \n    1 2 3\n    \n    CAPTAIN AMERICA EVADES\n    \n    Explanation:\n    Case 1:\n    \n    N=2 and K=1\n    \n    Therefore the arrangement is [2,1].\n    \n    Case 2:\n    \n    N=3 and K=0\n    \n    Therefore arrangement is [1,2,3].\n    \"\"\"\n", "entry_point": "arrange_buildings", "test": "\ndef check(candidate):\n    assert candidate(3, [(2, 1), (3, 0), (3, 2)]) == ['2 1', '1 2 3', 'CAPTAIN AMERICA EVADES']\ncheck(arrange_buildings)\n", "given_tests": ["assert arrange_buildings(3, [(2, 1), (3, 0), (3, 2)]) == ['2 1', '1 2 3', 'CAPTAIN AMERICA EVADES']"], "canonical_solution": "[\"t = int(input())\\nwhile t> 0:\\n t =t -1\\n n,k = list(map(int,input().split()))\\n a = [0]*n\\n done = True\\n\\n def swap(z):\\n  for j in range(0,n):\\n   if a[j] == 0:\\n    a[j] = z\\n    done = True\\n    break\\n   else:\\n    if a[j] > z:\\n     swap(j)\\n     a[j] = z\\n    else:\\n     done = False\\n     break\\n\\n for i in range(0,n):\\n  for j in range(0,n):\\n   if abs(i-j) == k:\\n    if a[j] == 0:\\n     a[j] = i + 1\\n     done = True\\n     break\\n    else:\\n     if a[j] > i + 1:\\n      swap(a[j])\\n      a[j] = i + 1\\n     else:\\n      done = False\\n\\n if 0 in a:\\n  print('CAPTAIN AMERICA EVADES')\\n else:\\n  if done:\\n   for c in a:\\n    print(c, end=' ')\\n   print()\\n  else:\\n   print('CAPTAIN AMERICA EVADES')\\n\\n\\n # for i in range(1,n+1):\\n #   if i - k >=0 :\\n #       if a[abs(i-k-1)] == 0:\\n #           a[abs(i-k-1)] = i\\n #           done = True\\n #       else:\\n #           done = False\\n #           break\\n #   else:\\n #       done = False\\n #       break\\n # if done:\\n #   for c in a:\\n #       print c,\\n #   print\\n # else:\\n #   print \\\"CAPTAIN AMERICA EVADES\\\"\\n\", \"t = int(input())\\n\\nwhile t:\\n t-=1\\n a=[int(i) for i in input().split()]\\n n=int(a[0])\\n k=int(a[1])\\n flag=1\\n if k==0:\\n  res=[i+1 for i in range(n)]\\n elif k>n/2 or n%(2*k)!=0:\\n  flag=0\\n else:\\n  temp1=[i+1 for i in range(k)]\\n  temp2=[i+1 for i in range(k,2*k)]\\n  temp=temp2+temp1\\n  res=[]\\n  x=n/(2*k)\\n  while x:\\n   x-=1\\n   res+=temp\\n   temp = [i+2*k for i in temp]\\n if flag:\\n  res=[str(i) for i in res]\\n  print(\\\" \\\".join(res))\\n else:\\n  print(\\\"CAPTAIN AMERICA EVADES\\\")\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/549", "prompt": "def min_cuts_sky_scrapers(n: int, heights: List[int]) -> int:\n    \"\"\"\n    In a fictitious city of CODASLAM there were many skyscrapers. The mayor of the city decided to make the city beautiful and for this he decided to arrange the skyscrapers in descending order of their height, and the order must be strictly decreasing but he also didn\u2019t want to waste much money so he decided to get the minimum cuts possible. Your job is to output the minimum value of cut that is possible to arrange the skyscrapers in descending order.\n    \n    -----Input-----\n    \n    *First line of input is the number of sky-scrappers in the city\n    *Second line of input is the height of the respective sky-scrappers\n    \n    \n    -----Output-----\n    \n    * Your output should be the minimum value of cut required to arrange these sky-scrappers in descending order.\n    \n    -----Example-----\n    Input:\n    5\n    1 2 3 4 5\n    \n    Output:\n    8\n    \n    By:\n    Chintan,Asad,Ashayam,Akanksha\n    \"\"\"\n", "entry_point": "min_cuts_sky_scrapers", "test": "\ndef check(candidate):\n    assert candidate(5, [1, 2, 3, 4, 5]) == 8\ncheck(min_cuts_sky_scrapers)\n", "given_tests": ["assert min_cuts_sky_scrapers(5, [1, 2, 3, 4, 5]) == 8"], "canonical_solution": "[\"import sys\\n \\nnum=int(sys.stdin.readline())\\ns=sys.stdin.readline().split()\\nsky=list(map(int,s))\\nsky.reverse()\\ncuts=0\\nchange=0\\nt=False\\ni=1\\n \\nwhile i<len(sky):\\n if sky[i]<=sky[i-1]:\\n  for j in range(i-1,-1,-1):\\n   \\n   if sky[j]<=sky[i]-(i-j):\\n    break\\n   else:\\n    change+=sky[j]-(sky[i]-(i-j))\\n    \\n   if change>=sky[i]:\\n    change=sky[i]\\n    t=True\\n    break\\n    \\n  cuts+=change\\n  \\n  if t:\\n   del sky[i]\\n   t=False\\n   i-=1\\n   \\n  else:\\n   for j in range(i-1,-1,-1):\\n    if sky[j]<sky[i]-(i-j):\\n     break\\n    else:\\n     sky[j]=sky[i]-(i-j)\\n i+=1\\n    \\n change=0\\n     \\nprint(cuts)\", \"#!/usr/bin/env python\\n\\ndef main():\\n N = int(input())\\n while True:\\n  try:\\n   X = input()\\n  except:\\n   break\\n  H = list(map(int, X.split()))\\n  C = 0\\n  while H:\\n   e = H.pop(0)\\n   H2, C1, C2 = list(H), e, 0\\n   for i in range(len(H2)):\\n    if H2[i] > e-1:\\n     C2 += H2[i]-(e-1)\\n     H2[i] = e-1\\n   #print C+C2, H2, C+C1, H\\n   if C1 <= C2:\\n    C += C1\\n   else:\\n    C += C2\\n    H = H2\\n  print(C)\\n\\nmain()\\n\\n\", \"import sys\\n\\nnum=int(sys.stdin.readline())\\ns=sys.stdin.readline().split()\\nsky=list(map(int,s))\\nsky.reverse()\\ncuts=0\\nchange=0\\nt=False\\ni=1\\n\\nwhile i<len(sky):\\n if sky[i]<=sky[i-1]:\\n  for j in range(i-1,-1,-1):\\n   \\n   if sky[j]<=sky[i]-(i-j):\\n    break\\n   else:\\n    change+=sky[j]-(sky[i]-(i-j))\\n    \\n   if change>=sky[i]:\\n    change=sky[i]\\n    t=True\\n    break\\n    \\n  cuts+=change\\n  \\n  if t:\\n   del sky[i]\\n   t=False\\n   i-=1\\n   \\n  else:\\n   for j in range(i-1,-1,-1):\\n    if sky[j]<sky[i]-(i-j):\\n     break\\n    else:\\n     sky[j]=sky[i]-(i-j)\\n i+=1\\n    \\n change=0\\n     \\nprint(cuts)\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/558", "prompt": "def earliest_arrival_time(M: int, N: int, rows: List[Tuple[str, int]], cols: List[Tuple[str, int]], start: Tuple[int, int, int], destination: Tuple[int, int]) -> int:\n    \"\"\"\n    The city of Siruseri is impeccably planned. The city is divided into a rectangular array of cells with $M$ rows and $N$ columns. Each cell has a metro station. There is one train running left to right and back along each row, and one running top to bottom and back along each column. Each trains starts at some time $T$ and goes back and forth along its route (a row or a column) forever.\n    Ordinary trains take two units of time to go from one station to the next. There are some fast trains that take only one unit of time to go from one station to the next. Finally, there are some slow trains that take three units of time to go from one station the next. You may assume that the halting time at any station is negligible.\n    Here is a description of a metro system with $3$ rows and $4$ columns:\n    $ $\n    S(1)  F(2)  O(2)  F(4)\n    F(3)    .     .     .     .\n    S(2)    .     .     .     .\n    O(2)    .     .     .     .\n    \n    $ $\n    The label at the beginning of each row/column indicates the type of train (F for fast, O for ordinary, S for slow) and its starting time. Thus, the train that travels along row 1 is a fast train and it starts at time $3$. It starts at station ($1$, $1$) and moves right, visiting the stations along this row at times $3, 4, 5$ and $6$ respectively. It then returns back visiting the stations from right to left at times $6, 7, 8$ and $9$. It again moves right now visiting the stations at times $9, 10, 11$ and $12$, and so on. Similarly, the train along column $3$ is an ordinary train starting at time $2$. So, starting at the station ($3$,$1$), it visits the three stations on column $3$ at times $2, 4$ and $6$, returns back to the top of the column visiting them at times $6,8$ and $10$, and so on.\n    Given a starting station, the starting time and a destination station, your task is to determine the earliest time at which one can reach the destination using these trains.\n    For example suppose we start at station ($2$,$3$) at time $8$ and our aim is to reach the station ($1$,$1$). We may take the slow train of the second row at time $8$ and reach ($2$,$4$) at time $11$. It so happens that at time $11$, the fast train on column $4$ is at ($2$,$4$) travelling upwards, so we can take this fast train and reach ($1$,$4$) at time $12$. Once again we are lucky and at time $12$ the fast train on row $1$ is at ($1$,$4$), so we can take this fast train and reach ($1$, $1$) at time $15$. An alternative route would be to take the ordinary train on column $3$ from ($2$,$3$) at time $8$ and reach ($1$,$3$) at time $10$. We then wait there till time $13$ and take the fast train on row $1$ going left, reaching ($1$,$1$) at time $15$. You can verify that there is no way of reaching ($1$,$1$) earlier than that.\n    \n    -----Input:-----\n    The first line contains two integers $M$ and $N$ indicating the number rows and columns in the metro system. This is followed by $M$ lines, lines $2, 3, \u2026, M+1$, describing the trains along the $M$ rows. The first letter on each line is either F or O or S, indicating whether the train is a fast train, an ordinary train or a slow train. Following this, separated by a blank space, is an integer indicating the time at which this train starts running. The next $N$ lines, lines $M+2, M+3, \u2026, N+M+1$, contain similar descriptions of the trains along the $N$ columns. The last line, line $N+M+2$, contains $5$ integers $a, b, c, d$ and $e$ where ($a$,$b$) is the starting station, $c$ is the starting time and ($d$,$e$) is the destination station.\n    \n    -----Output:-----\n    A single integer indicating the earliest time at which one may reach the destination.\n    \n    -----Constraints:-----\n    - $1 \\leq M, N \\leq 50$.\n    - $1 \\leq a, d \\leq M$\n    - $1 \\leq b, e \\leq N$\n    - $1 \\leq$ all times in input $\\leq 20$\n    \n    -----Sample Input-----\n    3 4\n    F 3\n    S 2\n    O 2\n    S 1\n    F 2\n    O 2\n    F 4\n    2 3 8 1 1\n    \n    -----Sample Output-----\n    15\n    \"\"\"\n", "entry_point": "earliest_arrival_time", "test": "\ndef check(candidate):\n    assert candidate(3, 4, [('F', 3), ('S', 2), ('O', 2)], [('S', 1), ('F', 2), ('O', 2), ('F', 4)], (2, 3, 8), (1, 1)) == 15\ncheck(earliest_arrival_time)\n", "given_tests": ["assert earliest_arrival_time(3, 4, [('F', 3), ('S', 2), ('O', 2)], [('S', 1), ('F', 2), ('O', 2), ('F', 4)], (2, 3, 8), (1, 1)) == 15"], "canonical_solution": "[\"from queue import PriorityQueue\\n\\nm,n=list(map(int,input().split()))\\nrr=[]\\ncc=[]\\nspeed={'S':3,'O':2,'F':1}\\nvisited=set()\\ndp=[]\\n\\ndef qwerty(cur,x,y,f):\\n\\tif f==0:\\n\\t\\tgg=rr[x][1]+y*rr[x][0]\\n\\t\\twhile gg<cur:\\n\\t\\t\\tgg+=(2*(n-1))*rr[x][0]\\n\\t\\treturn gg-cur+rr[x][0]\\n\\telif f==1:\\n\\t\\tgg=rr[x][1]+(2*(n-1)-y)*rr[x][0]\\n\\t\\twhile gg<cur:\\n\\t\\t\\tgg+=(2*(n-1))*rr[x][0]\\n\\t\\treturn gg-cur+rr[x][0]\\n\\telif f==2:\\n\\t\\tgg=cc[y][1]+x*cc[y][0]\\n\\t\\twhile gg<cur:\\n\\t\\t\\tgg+=(2*(m-1))*cc[y][0]\\n\\t\\treturn gg-cur+cc[y][0]\\t\\t\\n\\telif f==3:\\n\\t\\tgg=cc[y][1]+(2*(m-1)-x)*cc[y][0]\\n\\t\\twhile gg<cur:\\n\\t\\t\\tgg+=(2*(m-1))*cc[y][0]\\n\\t\\treturn gg-cur+cc[y][0]\\n\\n\\ndirx=[0, 0, 1, -1]\\ndiry=[1, -1, 0, 0]\\n\\nfor i in range(m):\\n\\to=[x for x in input().split()]\\n\\to[0]=speed[o[0]]\\n\\to[1]=int(o[1])\\n\\trr.append(o)\\n\\n\\nfor i in range(n):\\n\\to=[x for x in input().split()]\\n\\to[0]=speed[o[0]]\\n\\to[1]=int(o[1])\\n\\tcc.append(o)\\n\\n\\nsx,sy,stt,dx,dy=list(map(int,input().split()))\\nsx-=1\\nsy-=1\\ndx-=1\\ndy-=1\\n\\nfor i in range(m):\\n\\tdp.append([10**9]*n)\\n\\ndp[sx][sy]=stt\\npq = PriorityQueue()\\npq.put((stt, sx, sy))\\nwhile not pq.empty():\\n\\t(t,cxx,cyy)=pq.get()\\n\\tif (cxx,cyy) in visited:\\n\\t\\tcontinue\\n\\tvisited.add((cxx,cyy))\\n\\tfor i in range(len(dirx)):\\n\\t\\tnxx=cxx+dirx[i]\\n\\t\\tnyy=cyy+diry[i]\\n\\t\\tif nxx>=0 and nxx<m and nyy>=0 and nyy<n and (nxx,nyy) not in visited:\\n\\t\\t\\tcoo=qwerty(dp[cxx][cyy],cxx,cyy,i)\\n\\t\\t\\tif coo+dp[cxx][cyy]<dp[nxx][nyy]:\\n\\t\\t\\t\\t\\tdp[nxx][nyy]=coo+dp[cxx][cyy]\\n\\t\\t\\t\\t\\tpq.put((dp[nxx][nyy],nxx,nyy))\\n\\nprint(dp[dx][dy])\\n\\n\\n\\n\\n\\n\\n\\n\\t\\n\\n\\n\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/1231", "prompt": "def sum_of_digits_of_powers(T: int, numbers: List[int]) -> List[int]:\n    \"\"\"\n    The chef won a duet singing award at Techsurge & Mridang 2012. From that time he is obsessed with the number 2.\n    \n    He just started calculating the powers of two. And adding the digits of the results.\n    \n    But he got puzzled after a few calculations. So gave you the job to generate the solutions to 2^n and find their sum of digits.\n    \n    -----Input-----\n    N : number of inputs N<=100\n    \n    then N lines with input T<=2000\n    \n    -----Output-----\n    The output for the corresponding input T\n    \n    -----Example-----\n    Input:\n    3\n    5\n    10\n    4\n    \n    Output:\n    5\n    7\n    7\n    \n    Explanation:\n    2^5=32\n    3+2=5\n    2^10=1024\n    1+0+2+4=7\n    2^4=16\n    1+6=7\n    \"\"\"\n", "entry_point": "sum_of_digits_of_powers", "test": "\ndef check(candidate):\n    assert candidate(3, [5, 10, 4]) == [5, 7, 7]\ncheck(sum_of_digits_of_powers)\n", "given_tests": ["assert sum_of_digits_of_powers(3, [5, 10, 4]) == [5, 7, 7]"], "canonical_solution": "[\"from operator import add; from functools import reduce; def sum_of_digits_of_powers(T: int, numbers: List[int]) -> List[int]: choices = []; for x in range(1800): num_str = list(map (int, str (2**x))); suma = reduce (add, num_str); choices.append(suma); results = []; for t in numbers: results.append(choices[t]); return results;\", \"for _ in range(int(input())): i=int(input()); a=str(2**i); sums=0; for d in a: d=int(d); sums+=d; print(sums)\", \"import sys; for i in range(int(input())): n=input(); try: n=int(n); t=2**n; s=0; while t>0: s+=t%10; t//=10; print(s); except: break\", \"n = int(input().rstrip()); while(n > 0): t = int(input().rstrip()); r = 2 ** t; r = list(str(r)); s = 0; for i in r: s = s + int(i); print(s); n = n-1\", \"from sys import stdin; lines = stdin.readlines()[1:]; for line in lines: str_2n = str(2 ** int(line)); sum = 0; for i in str_2n: sum += int(i); print(sum)\", \"import sys; def main(): s = sys.stdin.readline; t = int(s()); for t in range(t): n = int(s()); comp = str(2**n); sum = 0; for i in comp: sum+=int(i); print(sum); def __starting_point(): main(); __starting_point()\", \"import sys; line = sys.stdin.readline(); n=int(line); while n: try: line = sys.stdin.readline(); t=int(line); except: break; x=2**t; sum=0; while x: sum+=x%10; x/=10; print(\\\"\\\\n%d\\\"%sum); n-=1\", \"testcases = int(input()); while testcases: n = int(input()); print(sum([int(digit) for digit in str(2**n)])); testcases -= 1\", \"#!/usr/bin/env python; T = int(input()); for t in range(T): N = int(input()); print(sum(map(int, str(2**N)))); ''  X = 2**N; print '2^%d=%d' % (N, X); X = map(int, str(X)); print '%s=%d' % ('+'.join(map(str, X)), sum(X)); ''; N = int(input()); for i in range(N): res = str(2 ** int(input())); ans = 0; for i in res: ans += ord(i) - ord('0'); print(ans)\"]", "difficulty": "interview"}
{"task_id": "APPS/1159", "prompt": "def string_game_winner(T: int, test_cases: List[str]) -> List[str]:\n    \"\"\"\n    Abhi and his friends (Shanky,Anku and Pandey) love to play with strings. Abhi invented a simple game. He will give a string S to his friends. Shanky and Anku will play the game while Pandey is just a spectator. Shanky will traverse the string from beginning (left to right) while Anku will traverse from last (right to left). Both have to find the first character they encounter during their traversal,that appears only once in the entire string. Winner will be one whose character is alphabetically more superior(has higher ASCII value). When it is not possible to decide the winner by comparing their characters, Pandey will be the winner.\n    \n    -----Input-----\n    The first line of the input contains an integer T denoting the number of test cases. The description of T test cases follows.\n    \n    Each test case contains a string S having only lowercase alphabets ( a..z ).\n    \n    -----Output-----\n    For each test case, output a single line containing \"SHANKY\" if Shanky is the winner or \"ANKU\" if Anku is the winner or \"PANDEY\" if the winner is Pandey. Output your answer without quotes.\n    \n    -----Constraints-----\n    - 1 \u2264 T \u2264 100\n    - 1 < |S| \u2264 10^5\n    \n    -----Example-----\n    Input:\n    3\n    google\n    breakraekb\n    aman\n    \n    Output:\n    SHANKY\n    PANDEY\n    ANKU\n    \n    -----Explanation-----\n    Example case 2. Both Shanky and Anku can not find any such character. Hence it is not possible to decide the winner between these two. So Pandey is the winner.\n    \"\"\"\n", "entry_point": "string_game_winner", "test": "\ndef check(candidate):\n    assert candidate(3, ['google', 'breakraekb', 'aman']) == ['SHANKY', 'PANDEY', 'ANKU']\ncheck(string_game_winner)\n", "given_tests": ["assert string_game_winner(3, ['google', 'breakraekb', 'aman']) == ['SHANKY', 'PANDEY', 'ANKU']"], "canonical_solution": "[\"def string_game_winner(T: int, test_cases: List[str]) -> List[str]: results = []; for S in test_cases: freq = {}; for ch in S: freq[ch] = freq.get(ch, 0) + 1; shanky_char, anku_char = None, None; for ch in S: if freq[ch] == 1: shanky_char = ch; break; for ch in reversed(S): if freq[ch] == 1: anku_char = ch; break; if shanky_char is None or anku_char is None: results.append('PANDEY'); elif shanky_char > anku_char: results.append('SHANKY'); elif anku_char > shanky_char: results.append('ANKU'); else: results.append('PANDEY'); return results\"]", "difficulty": "interview"}
{"task_id": "APPS/66", "prompt": "def distribute_gifts(t: int, test_cases: List[Tuple[int, List[int], List[int]]]) -> List[Tuple[List[int], List[int]]]:\n    \"\"\"\n    Kuroni has $n$ daughters. As gifts for them, he bought $n$ necklaces and $n$ bracelets:  the $i$-th necklace has a brightness $a_i$, where all the $a_i$ are pairwise distinct (i.e. all $a_i$ are different),  the $i$-th bracelet has a brightness $b_i$, where all the $b_i$ are pairwise distinct (i.e. all $b_i$ are different).\n    \n    Kuroni wants to give exactly one necklace and exactly one bracelet to each of his daughters. To make sure that all of them look unique, the total brightnesses of the gifts given to each daughter should be pairwise distinct. Formally, if the $i$-th daughter receives a necklace with brightness $x_i$ and a bracelet with brightness $y_i$, then the sums $x_i + y_i$ should be pairwise distinct. Help Kuroni to distribute the gifts.\n    \n    For example, if the brightnesses are $a = [1, 7, 5]$ and $b = [6, 1, 2]$, then we may distribute the gifts as follows:  Give the third necklace and the first bracelet to the first daughter, for a total brightness of $a_3 + b_1 = 11$. Give the first necklace and the third bracelet to the second daughter, for a total brightness of $a_1 + b_3 = 3$. Give the second necklace and the second bracelet to the third daughter, for a total brightness of $a_2 + b_2 = 8$.\n    \n    Here is an example of an invalid distribution:   Give the first necklace and the first bracelet to the first daughter, for a total brightness of $a_1 + b_1 = 7$. Give the second necklace and the second bracelet to the second daughter, for a total brightness of $a_2 + b_2 = 8$. Give the third necklace and the third bracelet to the third daughter, for a total brightness of $a_3 + b_3 = 7$.\n    \n    This distribution is invalid, as the total brightnesses of the gifts received by the first and the third daughter are the same. Don't make them this upset!\n    \n    \n    -----Input-----\n    \n    The input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 100$) \u00a0\u2014 the number of test cases. The description of the test cases follows.\n    \n    The first line of each test case contains a single integer $n$ ($1 \\le n \\le 100$) \u00a0\u2014 the number of daughters, necklaces and bracelets.\n    \n    The second line of each test case contains $n$ distinct integers $a_1, a_2, \\dots, a_n$ ($1 \\le a_i \\le 1000$) \u00a0\u2014 the brightnesses of the necklaces.\n    \n    The third line of each test case contains $n$ distinct integers $b_1, b_2, \\dots, b_n$ ($1 \\le b_i \\le 1000$) \u00a0\u2014 the brightnesses of the bracelets.\n    \n    \n    -----Output-----\n    \n    For each test case, print a line containing $n$ integers $x_1, x_2, \\dots, x_n$, representing that the $i$-th daughter receives a necklace with brightness $x_i$. In the next line print $n$ integers $y_1, y_2, \\dots, y_n$, representing that the $i$-th daughter receives a bracelet with brightness $y_i$.\n    \n    The sums $x_1 + y_1, x_2 + y_2, \\dots, x_n + y_n$ should all be distinct. The numbers $x_1, \\dots, x_n$ should be equal to the numbers $a_1, \\dots, a_n$ in some order, and the numbers $y_1, \\dots, y_n$ should be equal to the numbers $b_1, \\dots, b_n$ in some order.\n    \n    It can be shown that an answer always exists. If there are multiple possible answers, you may print any of them.\n    \n    \n    -----Example-----\n    Input\n    2\n    3\n    1 8 5\n    8 4 5\n    3\n    1 7 5\n    6 1 2\n    \n    Output\n    1 8 5\n    8 4 5\n    5 1 7\n    6 2 1\n    \n    \n    \n    -----Note-----\n    \n    In the first test case, it is enough to give the $i$-th necklace and the $i$-th bracelet to the $i$-th daughter. The corresponding sums are $1 + 8 = 9$, $8 + 4 = 12$, and $5 + 5 = 10$.\n    \n    The second test case is described in the statement.\n    \"\"\"\n", "entry_point": "distribute_gifts", "test": "\ndef check(candidate):\n    assert candidate(2, [(3, [1, 8, 5], [8, 4, 5]), (3, [1, 7, 5], [6, 1, 2])]) == [([1, 8, 5], [8, 4, 5]), ([5, 1, 7], [6, 2, 1])]\ncheck(distribute_gifts)\n", "given_tests": ["assert distribute_gifts(2, [(3, [1, 8, 5], [8, 4, 5]), (3, [1, 7, 5], [6, 1, 2])]) == [([1, 8, 5], [8, 4, 5]), ([5, 1, 7], [6, 2, 1])]"], "canonical_solution": "[\"#list(map(int,input().split()))\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    aa=list(map(int,input().split()))\\n    bb=list(map(int,input().split()))\\n    aa.sort()\\n    bb.sort()\\n    print(*aa)\\n    print(*bb)\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    a = sorted(list(map(int, input().split())))\\n    s = sorted(list(map(int, input().split())))\\n    print(*a)\\n    print(*s)\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    ar1 = list(map(int, input().split()))\\n    ar2 = list(map(int, input().split()))\\n    ar1.sort()\\n    ar2.sort()\\n    print(*ar1)\\n    print(*ar2)\", \"import math, collections, sys\\ninput = sys.stdin.readline\\ndef solve():\\n    n=int(input())\\n    a = list(map(int, input().split()))\\n    b= list(map(int, input().split()))\\n    a.sort()\\n    b.sort()\\n    print(*a)\\n    print(*b)\\nfor _ in range(int(input())):\\n    solve()\", \"import math,sys\\nfrom collections import Counter, defaultdict, deque\\nfrom sys import stdin, stdout\\ninput = stdin.readline\\nli = lambda:list(map(int,input().split()))\\n\\ndef solve():\\n    n=int(input())\\n    a=li()\\n    b=li()\\n    a.sort()\\n    b.sort()\\n    print(*a)\\n    print(*b)\\n\\nfor _ in range(int(input())):\\n    solve()\", \"import sys\\nreader = (s.rstrip() for s in sys.stdin)\\ninput = reader.__next__\\n\\ndef solve():\\n    n = int(input())\\n    a = list(map(int, input().split()))\\n    b = list(map(int, input().split()))\\n    a.sort()\\n    b.sort()\\n    print(*a)\\n    print(*b)\\n\\nt = int(input())\\nfor i in range(t):\\n    solve()\\n\\n\", \"for _ in range(int(input())):\\n    n = int(input())\\n    l1 = list(map(int,input().split()))\\n    l2 = list(map(int,input().split()))\\n    l1.sort()\\n    l2.sort()\\n    print(*l1, sep= \\\" \\\")\\n    print(*l2, sep= \\\" \\\")\", \"t = int(input())\\nfor i in range(t):\\n    n = int(input())\\n    a = map(int, input().split())\\n    b = map(int, input().split())\\n    print(*sorted(a))\\n    print(*sorted(b))\"]", "difficulty": "interview"}
{"task_id": "APPS/1610", "prompt": "def subsets_parity(n: int, k: int) -> str:\n    \"\"\"\n    # Task\n    You are given integer `n` determining set S = {1, 2, ..., n}. Determine if the number of k-element subsets of S is `ODD` or `EVEN` for given integer k.\n    \n    # Example\n    \n    For `n = 3, k = 2`, the result should be `\"ODD\"`\n    \n    In this case, we have 3 2-element subsets of {1, 2, 3}:\n    \n    `{1, 2}, {1, 3}, {2, 3}`\n    \n    For `n = 2, k = 1`, the result should be `\"EVEN\"`.\n    \n    In this case, we have 2 1-element subsets of {1, 2}:\n    \n    `{1}, {2}`\n    \n    `Don't bother with naive solution - numbers here are really big.`\n    \n    # Input/Output\n    \n    \n    - `[input]` integer `n`\n    \n    `1 <= n <= 10^9`\n    \n    \n    - `[input]` integer `k`\n    \n    `1 <= k <= n`\n    \n    \n    - `[output]` a string\n    \n    `\"EVEN\"` or `\"ODD\"` depending if the number of k-element subsets of S = {1, 2, ..., n} is ODD or EVEN.\n    \"\"\"\n    return 'EVEN' if ~n & k else 'ODD'\n", "entry_point": "subsets_parity", "test": "\ndef check(candidate):\n    assert candidate(3, 2) == 'ODD'\n    assert candidate(2, 1) == 'EVEN'\n    assert candidate(1, 1) == 'ODD'\n    assert candidate(20, 10) == 'EVEN'\n    assert candidate(48, 12) == 'EVEN'\ncheck(subsets_parity)\n", "given_tests": ["assert subsets_parity(3, 2) == 'ODD'"], "canonical_solution": "[\"def subsets_parity(n, k):\\n    return 'EVEN' if ~n & k else 'ODD'\", \"subsets_parity=lambda n,k:~n&k and\\\"EVEN\\\"or\\\"ODD\\\"\", \"subsets_parity=s=lambda n,k:n<k and\\\"EVEN\\\"or n<2and\\\"ODD\\\"or(lambda b:s(n&~b,k&~b))(1<<n.bit_length()-1)\", \"#Courtesy of giants :D\\ndef subsets_parity(n,k):\\n    N,K = bin(n)[2:][::-1], bin(k)[2:][::-1]\\n    for i in range(len(K)):\\n        if K[i] > N[i]:\\n            return 'EVEN'\\n    return 'ODD'\", \"#using lucas's theorem https://en.wikipedia.org/wiki/Lucas%27s_theorem\\n\\ndef to_bin(n):\\n    k = 0\\n    while n >= 2**k: k += 1\\n    s = \\\"\\\"\\n    for i in range(k - 1, -1, -1):\\n        if n - 2**i >= 0: \\n            s += \\\"1\\\"\\n            n -= 2**i\\n        else: s += \\\"0\\\"\\n    return s\\n\\ndef subsets_parity(n, k):\\n    s1 = to_bin(n)\\n    s2 = to_bin(k)\\n    for i in range(-1, -len(s2) - 1, -1):\\n        if s1[i] == \\\"0\\\" and s2[i] == \\\"1\\\": return \\\"EVEN\\\"\\n    return \\\"ODD\\\"\", \"def subsets_parity(n,k):\\n    string_set = \\\"{:02b}\\\".format(n)\\n    length = len(string_set)\\n    string_subset = \\\"{:02b}\\\".format(k).zfill(length)\\n    for i in range(0, length):\\n        if not int(string_set[i]) and int(string_subset[i]):\\n            return \\\"EVEN\\\"\\n            break\\n    else:\\n        return \\\"ODD\\\"\", \"import math\\n\\ndef f1(n):\\n    x,s=1,0\\n    while 2**x<=n:\\n        s=s+ math.floor(n/2**x)\\n        x=x+1\\n    return (s)\\n\\ndef subsets_parity(n,k):\\n    if n==k:\\n        return \\\"ODD\\\"\\n    if n>0 and k>0 and n-k>0:\\n        if f1(n) == f1(k) + f1(n-k):\\n            return \\\"ODD\\\"\\n        else:\\n            return \\\"EVEN\\\"\\n        \\n    \\n\", \"def subsets_parity(n,k):\\n    while k:\\n        if not n & 1 and k & 1: return 'EVEN'\\n        n, k = n // 2, k // 2\\n    return 'ODD'\", \"def c(n):\\n    m = 0\\n    while n > 0:\\n        n = n // 2\\n        m += n\\n    return m\\n\\ndef subsets_parity(n,k):\\n    return \\\"EVEN\\\" if (c(n)-c(k)-c(n-k))>0 else \\\"ODD\\\"\", \"def subsets_parity(n,k):\\n    return 'ODD' if n==k|(n-k) else 'EVEN'\"]", "difficulty": "interview"}
{"task_id": "APPS/1183", "prompt": "def occurrences_with_dp_and_bruteforce(t: int, test_cases: List[Tuple[int, List[int], int, int, List[int]]]) -> List[Tuple[int, int, int]]:\n    \"\"\"\n    Problem description.\n    \n    This problem is simple and will introduce you to the Dynamic Programming.\n    \n    You will be given an array and a key value.\n    \n    You will have to find out the occurrences of the key value depending upon the query using Brute Force and Top Down Dynamic Programming.\n    \n    -----Brute-Force: -----\n    You will check the query, and calculate the occurrences.\n    \n    \n    -----DP: -----\n    \n    You will check the query; check whether the memoized solution is already available.\n    \n    If the memoized solution is available, no need to calculate the number of occurrences again.\n    \n    If the memoized solution is not available, then calculate the number of  occurrences and memoize it for future use.\n    \n    -----Pseudo Code for DP:-----\n    countOccurences(key,from):\n    \n    if (from = size of array) then\n    return 0\n    endif\n    if dp[from] is availabe then\n    return dp[from]\n    endif\n    if( array[from] == key) then\n    dp[from] = 1+countOccurences(key,from+1)\n    else\n    dp[from] = countOccurences(key,from+1)\n    endif\n    return dp[from]\n    \n    \n    -----Input:-----\n    \n    The first line of input is the number of test cases (t).\n    \n    The first line of each test case is the number of array elements (n).\n    \n    The next will contain n space separated integers.\n    \n    The next line will have the key element (k).\n    \n    The next will have number of queries (q).\n    \n    The next q lines will contain an integer A such that 0<=A < n.\n    \n    You have to find out the number of occurrences from a to end of the array using both brute force and DP.\n    \n    Everything will fit into the range of int.\n    \n    -----Output:-----\n    \n    For each test case, the output will have q lines with 3 space separated integers.\n    The first will be the number of occurrences, other will be the loop count/function calls,\n    using brute force and the last will be the number of loop count/function calls using DP.\n    \n    -----Sample Input:-----\n    1\n    10\n    1 2 3 1 2 3 1 2 3 1\n    3\n    5\n    2\n    4\n    6\n    8\n    2\n    \n    -----Sample output:-----\n    3 8 9\n    2 6 1\n    1 4 1\n    1 2 1\n    3 8 1\n    \n    -----Explanation:-----\n    \n    For the first query, we have to find the number of occurrences of 3 from index 2.\n    \n    Using the brute force, the loop will check each element from index 2 to 9. Thus the loop count is 8.\n    \n    Using DP, the method countOccurences(key,from) will be called like this :\n    \n    countOccurences(3,2)->countOccurences(3,3)->countOccurences(3,4)->countOccurences(3,5)\n    ->countOccurences(3,6)->countOccurences(3,7)->countOccurences(3,8)\n    ->countOccurences(3,9)->countOccurences(3,10).\n    \n    \n    When the countOccurences(3,10) is called, it will return 0. Total 9 function calls.\n    \n    For the second query, the brute force will do the same as above.\n    \n    But the DP will check whether solution for countOccurences(3,4) is available or not.\n    \n    As it was calculated while solving the first query, it won\u2019t solve it again and will directly give the answer.\n    \n    Total 1 function calls.\n    \"\"\"\n", "entry_point": "occurrences_with_dp_and_bruteforce", "test": "\ndef check(candidate):\n    assert candidate(1, [(10, [1, 2, 3, 1, 2, 3, 1, 2, 3, 1], 3, 5, [2, 4, 6, 8, 2])]) == [(3, 8, 9), (2, 6, 1), (1, 4, 1), (1, 2, 1), (3, 8, 1)]\ncheck(occurrences_with_dp_and_bruteforce)\n", "given_tests": ["assert occurrences_with_dp_and_bruteforce(1, [(10, [1, 2, 3, 1, 2, 3, 1, 2, 3, 1], 3, 5, [2, 4, 6, 8, 2])]) == [(3, 8, 9), (2, 6, 1), (1, 4, 1), (1, 2, 1), (3, 8, 1)]"], "canonical_solution": "[\"for __ in range(eval(input())): x = eval(input()) a = list(map(int,input().split())) key = eval(input()) query = eval(input()) maxvisited = x #maximum visted value j = x-1 ans = [] val = 0 while j>=0: if a[j]==key: ans.append(val+1) val = val +1 else: ans.append(val) j-=1 ans.reverse() #print ans for ii in range(query): W = eval(input()) print(ans[W], end=' ') print(x-W, end=' ') #print maxvisited, W if maxvisited>W: print(maxvisited-W+1) maxvisited = W else: print('1')\", \"for __ in range(eval(input())): x = eval(input()) a = list(map(int,input().split())) key = eval(input()) query = eval(input()) maxvisited = x #maximum visted value j = x-1 ans = [] val = 0 while j>=0: if a[j]==key: ans.append(val+1) val = val +1 else: ans.append(val) j-=1 ans.reverse() #print ans, len(ans) for ii in range(query): W = eval(input()) print(ans[W], end=' ') print(x-W, end=' ') #print maxvisited, W if maxvisited>W: if True: tt = 1 #if not ii: tt = 1 print(maxvisited-W+tt) maxvisited = W else: print('1')\", \"for t in range(int(input())): n=int(input()) a=list(map(int,input().split())) k=int(input()) dp=[0]*n if (a[0]==k): dp[0]=1 for i in range(1,n): if (a[i]==k): dp[i]=dp[i-1]+1 else: dp[i]=dp[i-1] dp_index=n for q in range(int(input())): x=int(input()) if (x==0): print(dp[-1], end=' ') else: print(dp[-1]-dp[x-1], end=' ') print(n-x, end=' ') if (x<dp_index): print(dp_index-x+1) dp_index=x else: print(1)\"]", "difficulty": "interview"}
{"task_id": "APPS/786", "prompt": "def nth_magic_number(t: int, test_cases: List[int]) -> List[int]:\n    \"\"\"\n    The chef was not happy with the binary number system, so he designed a new machine which is having 6 different states, i.e. in binary there is a total of 2 states as 0 and 1. Now, the chef is confused about how to correlate this machine to get an interaction with Integer numbers, when N(Integer number) is provided to the system, what will be the Nth number that system will return(in Integer form), help the chef to design this system.\n    \n    -----Input:-----\n    - First-line will contain $T$, the number of test cases. Then the test cases follow.\n    - Each test case contains a single line of input, $N$.\n    \n    -----Output:-----\n    For each test case, output in a single line answer given by the system.\n    \n    -----Constraints-----\n    - $1 \\leq T \\leq 10^5$\n    - $1 \\leq N \\leq 10^5$\n    \n    -----Sample Input:-----\n    2\n    3\n    5\n    \n    -----Sample Output:-----\n    7\n    37\n    \n    -----EXPLANATION:-----\n    Initial numbers for system = [1, 6, 7, 36, 37, 42, 43, 216, \u2026..\n    For 1) 3rd Number for the system will be 7.\n    For 2) 5th Number for the system will be 37.\n    \"\"\"\n    results = []\n    for n in test_cases:\n        binary_rep = bin(n)[2:]\n        magic_number = 0\n        power = 1\n        for digit in reversed(binary_rep):\n            if digit == '1':\n                magic_number += power\n            power *= 6\n        results.append(magic_number)\n    return results\n","entry_point": "nth_magic_number", "test": "\ndef check(candidate):\n    assert candidate(2, [3, 5]) == [7, 37]\ncheck(nth_magic_number)\n", "given_tests": ["assert nth_magic_number(2, [3, 5]) == [7, 37]"], "canonical_solution": "[\"from sys import stdin, stdout; l = [1, 6, 7]; c = 1; for x in range(3, 100001): a = l[c] * 6 if x % 2 == 1 else l[-1] + 1; l.append(a); c += x % 2; n = int(stdin.readline()); for _ in range(n): s = int(stdin.readline()); print(l[s - 1])\"]", "difficulty": "interview"}
{"task_id": "APPS/112", "prompt": "def find_zombie_lair(n: int, grid: List[List[int]]) -> Tuple[int, List[Tuple[int, int]]]:\n    \"\"\"\n    Now that Heidi has made sure her Zombie Contamination level checker works, it's time to strike! This time, the zombie lair is a strictly convex polygon on the lattice. Each vertex of the polygon occupies a point on the lattice. For each cell of the lattice, Heidi knows the level of Zombie Contamination \u2013 the number of corners of the cell that are inside or on the border of the lair.\n    \n    Given this information, Heidi wants to know the exact shape of the lair to rain destruction on the zombies. Help her!\n    \n    [Image]\n    \n    \n    -----Input-----\n    \n    The input contains multiple test cases.\n    \n    The first line of each test case contains one integer N, the size of the lattice grid (5 \u2264 N \u2264 500). The next N lines each contain N characters, describing the level of Zombie Contamination of each cell in the lattice. Every character of every line is a digit between 0 and 4.\n    \n    Cells are given in the same order as they are shown in the picture above: rows go in the decreasing value of y coordinate, and in one row cells go in the order of increasing x coordinate. This means that the first row corresponds to cells with coordinates (1, N), ..., (N, N) and the last row corresponds to cells with coordinates (1, 1), ..., (N, 1).\n    \n    The last line of the file contains a zero. This line should not be treated as a test case. The sum of the N values for all tests in one file will not exceed 5000.\n    \n    \n    -----Output-----\n    \n    For each test case, give the following output:\n    \n    The first line of the output should contain one integer V, the number of vertices of the polygon that is the secret lair. The next V lines each should contain two integers, denoting the vertices of the polygon in the clockwise order, starting from the lexicographically smallest vertex.\n    \n    \n    -----Examples-----\n    Input\n    8\n    00000000\n    00000110\n    00012210\n    01234200\n    02444200\n    01223200\n    00001100\n    00000000\n    5\n    00000\n    01210\n    02420\n    01210\n    00000\n    7\n    0000000\n    0122100\n    0134200\n    0013200\n    0002200\n    0001100\n    0000000\n    0\n    \n    Output\n    4\n    2 3\n    2 4\n    6 6\n    5 2\n    4\n    2 2\n    2 3\n    3 3\n    3 2\n    3\n    2 5\n    4 5\n    4 2\n    \n    \n    \n    -----Note-----\n    \n    It is guaranteed that the solution always exists and is unique. It is guaranteed that in the correct solution the coordinates of the polygon vertices are between 2 and N - 2. A vertex (x_1, y_1) is lexicographically smaller than vertex (x_2, y_2) if x_1 < x_2 or $x_{1} = x_{2} \\wedge y_{1} < y_{2}$.\n    \"\"\"\n", "entry_point": "find_zombie_lair", "test": "\ndef check(candidate):\n    assert candidate(8, [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 2, 2, 1, 0], [0, 1, 2, 3, 4, 2, 0, 0], [0, 2, 4, 4, 4, 2, 0, 0], [0, 1, 2, 2, 3, 2, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]) == (4, [(2, 3), (2, 4), (6, 6), (5, 2)])\n    assert candidate(5, [[0, 0, 0, 0, 0], [0, 1, 2, 1, 0], [0, 2, 4, 2, 0], [0, 1, 2, 1, 0], [0, 0, 0, 0, 0]]) == (4, [(2, 2), (2, 3), (3, 3), (3, 2)])\n    assert candidate(7, [[0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 2, 1, 0, 0], [0, 1, 3, 4, 2, 0, 0], [0, 0, 1, 3, 2, 0, 0], [0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0]]) == (3, [(2, 5), (4, 5), (4, 2)])\ncheck(find_zombie_lair)\n", "given_tests": ["assert find_zombie_lair(8, [[0, 0, 0, 0, 0, 0, 0, 0], [0, 0, 0, 0, 0, 1, 1, 0], [0, 0, 0, 1, 2, 2, 1, 0], [0, 1, 2, 3, 4, 2, 0, 0], [0, 2, 4, 4, 4, 2, 0, 0], [0, 1, 2, 2, 3, 2, 0, 0], [0, 0, 0, 1, 1, 0, 0, 0], [0, 0, 0, 0, 0, 0, 0, 0]]) == (4, [(2, 3), (2, 4), (6, 6), (5, 2)])", "assert find_zombie_lair(5, [[0, 0, 0, 0, 0], [0, 1, 2, 1, 0], [0, 2, 4, 2, 0], [0, 1, 2, 1, 0], [0, 0, 0, 0, 0]]) == (4, [(2, 2), (2, 3), (3, 3), (3, 2)])", "assert find_zombie_lair(7, [[0, 0, 0, 0, 0, 0, 0], [0, 1, 2, 2, 1, 0, 0], [0, 1, 3, 4, 2, 0, 0], [0, 0, 1, 3, 2, 0, 0], [0, 0, 0, 2, 2, 0, 0], [0, 0, 0, 1, 1, 0, 0], [0, 0, 0, 0, 0, 0, 0]]) == (3, [(2, 5), (4, 5), (4, 2)])"], "canonical_solution": "[\"import math\\n\\ndef lexComp(a, b):\\n if a[0] != b[0]:\\n return -1 if a[0] < b[0] else 1\\n if a[1] != b[1]:\\n return -1 if a[1] < b[1] else 1\\n return 0\\n\\ndef turn(a, b, c):\\n return (b[0] - a[0]) * (c[1] - b[1]) - (b[1] - a[1]) * (c[0] - b[0])\\n\\ndef dist2(a, b):\\n return (a[0] - b[0]) ** 2 + (a[1] - b[1]) ** 2\\n\\ndef solve(n):\\n a = [list(map(int, input())) for _ in range(n)]\\n points = []\\n for i in range(n):\\n for j in range(n):\\n if a[i][j] == 1:\\n curPoints = []\\n for dx in range(0, 2):\\n for dy in range(0, 2):\\n ok = True\\n for ddx in range(0, 2):\\n for ddy in range(0, 2):\\n x, y = i - 1 + dx + ddx, j - 1 + dy + ddy\\n if 0 <= x < n and 0 <= y < n and a[x][y] == 0:\\n ok = False\\n if ok:\\n curPoints.append((i + dx, j + dy))\\n points.append(curPoints[0])\\n points = list(set(points))\\n for i in range(1, len(points)):\\n if lexComp(points[0], points[i]) > 0:\\n points[0], points[i] = points[i], points[0]\\n points[1:] = sorted(points[1:], key=lambda p: (math.atan2(p[1] - points[0][1], p[0] - points[0][0]), dist2(p, points[0])))\\n hull = []\\n for p in points:\\n while len(hull) >= 2 and turn(hull[-2], hull[-1], p) <= 0:\\n hull.pop()\\n hull.append(p)\\n hull = [(p[1], n - p[0]) for p in hull] \\n hull = hull[::-1] \\n start = 0 \\n for i in range(1, len(hull)): \\n if lexComp(hull[i], hull[start]) < 0: \\n start = i \\n newHull = hull[start:] \\n newHull.extend(hull[:start]) \\n hull = newHull \\n print(len(hull)) \\n for p in hull: \\n print(p[0], p[1])\\nwhile True:\\n n = int(input())\\n if n == 0:\\n break\\n solve(n)\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/1449", "prompt": "def count_balanced_substrings(T: int, strings: List[str]) -> List[int]:\n    \"\"\"\n    A Little Elephant from the Zoo of Lviv likes lucky strings, i.e., the strings that consist only of the lucky digits 4 and 7.\n    The Little Elephant calls some string T of the length M balanced if there exists at least one integer X (1 \u2264 X \u2264 M) such that the number of digits 4 in the substring T[1, X - 1] is equal to the number of digits 7 in the substring T[X, M]. For example, the string S = 7477447 is balanced since S[1, 4] = 7477 has 1 digit 4 and S[5, 7] = 447 has 1 digit 7. On the other hand, one can verify that the string S = 7 is not balanced.\n    The Little Elephant has the string S of the length N. He wants to know the number of such pairs of integers (L; R) that 1 \u2264 L \u2264 R \u2264 N and the substring S[L, R]  is balanced. Help him to find this number.\n    Notes.\n    \n    Let S be some lucky string. Then\n    \n    - |S| denotes the length of the string S;\n    \n    - S[i] (1 \u2264 i \u2264 |S|) denotes the ith character of S (the numeration of characters starts from 1);\n    \n    -  S[L, R] (1 \u2264 L \u2264 R \u2264 |S|) denotes the string with the following sequence of characters: S[L], S[L + 1], ..., S[R], and is called a substring of S. For L > R we mean by S[L, R] an empty string.\n    \n    -----Input-----\n    The first line of the input file contains a single integer T, the number of test cases. Each of the following T lines contains one string, the string S for the corresponding test case. The input file does not contain any whitespaces.\n    \n    -----Output-----\n    For each test case output a single line containing the answer for this test case.\n    \n    -----Constraints-----\n    1 \u2264 T \u2264 10\n    \n    1 \u2264 |S| \u2264 100000\n    \n    S consists only of the lucky digits 4 and 7.\n    \n    \n    -----Example-----\n    Input:\n    4\n    47\n    74\n    477\n    4747477\n    \n    Output:\n    2\n    2\n    3\n    23\n    \n    -----Explanation-----\n    \n    In the first test case balance substrings are S[1, 1] = 4 and S[1, 2] = 47.\n    In the second test case balance substrings are S[2, 2] = 4 and S[1, 2] = 74.\n    Unfortunately, we can't provide you with the explanations of the third and the fourth test cases. You should figure it out by yourself. Please, don't ask about this in comments.\n    \"\"\"\n", "entry_point": "count_balanced_substrings", "test": "\ndef check(candidate):\n    assert candidate(4, ['47', '74', '477', '4747477']) == [2, 2, 3, 23]\ncheck(count_balanced_substrings)\n", "given_tests": ["assert count_balanced_substrings(4, ['47', '74', '477', '4747477']) == [2, 2, 3, 23]"], "canonical_solution": "[\"x=eval(input())\\nfor x in range(0,x):\\n\\tans=0\\n\\td=input()\\n\\ta=0\\n\\tcont=0\\n\\tfor i in range(0,len(d)):\\n\\t\\ta+=len(d)-i\\n\\t\\tif d[i]=='7':\\n\\t\\t\\tans+=1+cont\\n\\t\\t\\tcont+=1\\n\\t\\telse:\\n\\t\\t\\tcont=0\\n\\tans=a-ans\\n\\tprint(ans)\\n\", \"for _ in range(int(input())):\\n\\ts = input()\\n\\ta = s.split('4')\\n\\tsum1 = 0\\n\\tfor k in a:\\n\\t\\tsum1 = sum1 + (len(k)*(len(k)+1))/2\\n\\tl = len(s) *(len(s)+1) / 2\\n\\tprint(l - sum1)\", \"#import psyco\\n#psyco.full()\\n\\nfor _ in range(int(input())):\\n    s=input().strip()\\n    ways=0\\n    l=len(s)\\n    \\n    index=[]\\n    for i in range(l):\\n        if s[i]=='4':\\n            index.append(i)\\n    if len(index)==0:\\n        print(0)\\n    else:\\n        ways=0\\n        ways+=(index[0]+1-0)*(l-index[0])\\n        for i in range(1,len(index)):\\n            ways+=(index[i]-index[i-1])*(l-index[i])\\n                \\n        print(ways)\", \"tcase=int(eval(input()))\\ni=0\\nwhile(tcase):\\n    tcase-=1\\n    a=str(input())\\n    j=0\\n    i=0\\n    rem=0\\n    length=len(a)\\n    ans=(length*(length+1))/2\\n    #print ans,\\n    while(i<length):\\n        if(a[i]=='7'):\\n            rem+=(i-j+1)\\n            #print i,j,\\n        else:\\n            j=i+1\\n        i+=1\\n    ans-= rem;\\n    print(ans);\\n\\n\", \"#import psyco\\n#psyco.full()\\n\\nfor _ in range(int(input())):\\n    s=input().strip()\\n    ways=0\\n    l=len(s)\\n    \\n    index=[]\\n    for i in range(l):\\n        if s[i]=='4':\\n            index.append(i)\\n    ways=0        \\n    for i in range(len(index)):\\n        if i==0:\\n            ways+=(index[i]+1-0)*(l-index[i])\\n        else:\\n            ways+=(index[i]-index[i-1])*(l-index[i])\\n            \\n    print(ways)\", \"t=int(input().strip())\\nfor i in range(t):\\n    word=input().strip()\\n    n=len(word)\\n    s=n*(n+1)/2\\n    t7=0\\n    for j in range(n):\\n        if word[j]=='7': t7+=1\\n        else:\\n            s-=t7*(t7+1)/2\\n            t7=0\\n    s-=t7*(t7+1)/2\\n    print(s)\\n    \\n\", \"t=int(input().strip())\\nfor i in range(t):\\n    word=input().strip()\\n    n=len(word)\\n    s=n*(n+1)/2\\n    t7=0\\n    for j in range(n):\\n        if word[j]=='7': t7+=1\\n        else:\\n            s-=t7*(t7+1)/2\\n            t7=0\\n    s-=t7*(t7+1)/2\\n    print(s)\\n    \\n\"]", "difficulty": "interview"}
{"task_id": "APPS/866", "prompt": "def find_best_friend_voting(T: int, test_cases: List[Tuple[int, List[int]]]) -> List[Union[List[int], int]]:\n    \"\"\"\n    There are n chef's in Chefland. There is a festival in Chefland in which each chef is asked to vote a person as his best friend. Obviously, a person can't vote himself as his best friend.  Note that the best friend relationship is not necessarily bi-directional, i.e. it might be possible that x is best friend of y, but y is not a best friend of x.\n    \n    Devu was the election commissioner who conducted this voting. Unfortunately, he was sleeping during the voting time. So, he could not see the actual vote of each person, instead after the voting, he counted the number of votes of each person and found that number of votes of i-th person was equal to ci.\n    \n    Now he is wondering whether this distribution of votes corresponds to some actual voting or some fraudulent voting has happened. If the current distribution of votes does not correspond to any real voting, print -1. Otherwise, print any one of the possible voting which might have lead to the current distribution. If there are more than one possible ways of voting leading to the current distribution, you can print any one of them.\n    \n    -----Input-----\n    - First line of the input contains a single integer T denoting number of test cases.\n    - First line of each test case, contains a single integer n.\n    - Second line of each test case, contains n space separated integers denoting array c.\n    \n    -----Output-----\n    For each test case,\n    \n    - If there is no real voting corresponding to given distribution of votes, print -1 in a single line.\n    - Otherwise, print n space separated integers denoting a possible voting leading to current distribution of votes. i-th integer should denote the index of the person (1 based indexing) whom i-th person has voted as his best friend.\n    \n    -----Constraints and Subtasks-----\n    - 1 \u2264 T \u2264 500\n    - 1 \u2264 n \u2264 50\n    - 0 \u2264 ci \u2264 n\n    \n    -----Example-----\n    Input:\n    3\n    3\n    1 1 1\n    3\n    3 0 0\n    3\n    2 2 0\n    \n    Output:\n    2 3 1\n    -1\n    -1\n    \n    -----Explanation-----\n    Example 1: In this example, each person has received one vote. One possible example of real voting leading to this distribution is {2, 3, 1}. In this distribution, number of votes of all three persons are equal to 1. Also it is real voting because no person votes himself as his best friend.\n    \n    You can also output another possible distribution {3, 1, 2} too.\n    \n    Example 2: There is no real voting  corresponding to this voting distribution.\n    \n    Example 3: There is no real voting  corresponding to this voting distribution.\n    \"\"\"\n", "entry_point": "find_best_friend_voting", "test": "\ndef check(candidate):\n    assert candidate(3, [(3, [1, 1, 1]), (3, [3, 0, 0]), (3, [2, 2, 0])]) == [[2, 3, 1], -1, -1]\ncheck(find_best_friend_voting)\n", "given_tests": ["assert find_best_friend_voting(3, [(3, [1, 1, 1]), (3, [3, 0, 0]), (3, [2, 2, 0])]) == [[2, 3, 1], -1, -1]"], "canonical_solution": "[\"t=int(input())\\nfor _ in range(t):\\n n=int(input())\\n l=list(map(int,input().split()))\\n if sum(l)!=n or max(l)==n:\\n  print('-1')\\n else:\\n  d=dict()\\n  ans=[-1]*n\\n  for i in range(0,n):\\n   d[i]=1\\n  for i in range(n):\\n   if l[i]!=0:\\n    count=l[i]\\n    for k,v in list(d.items()):\\n     if count>0 and v==1 and i!=k:\\n      d[k]=0\\n      ans[k]=i+1\\n      count-=1\\n  ind=-1\\n  for i in range(0,len(ans)):\\n   if ans[i]==-1:\\n    ind=i\\n  if ind==-1:\\n   print(*ans)\\n  else:\\n   for i in range(len(ans)):\\n    if ans[i]!=ind+1:\\n     \\n    \\n     ans[ind]=ans[i]\\n     ans[i]=ind+1\\n     break\\n   print(*ans)\\n   \\n    \\n   \\n  \\n\\n      \\n \\n    \\n\\n \\n\", \"t=int(input())\\nfor _ in range(t):\\n n=int(input())\\n l=list(map(int,input().split()))\\n if sum(l)!=n or max(l)==n:\\n  print('-1')\\n else:\\n  ans=[]\\n  for i in range(n):\\n   for j in range(l[i]):\\n    ans.append(i+1)\\n  #final_ans=[-1]*n\\n  for i in range(len(ans)):\\n   if ans[i]==i+1:\\n    \\n    for j in range(len(ans)):\\n     if ans[j]!=i+1 :\\n      ans[i],ans[j]=ans[j],ans[i]\\n      break\\n  print(*ans)\\n   \\n    \\n   \\n  \\n\\n      \\n \\n    \\n\\n \\n\", \"for _ in range(int(input())):\\n n = int(input())\\n c = [int(i) for i in input().split()]\\n if n == 1:\\n  print(-1)\\n  continue\\n if sum(c) != n or n in c:\\n  print(-1)\\n  continue\\n res = []\\n for p in range(n):\\n  for q in range(c[p]):\\n   res.append(p+1)\\n for p in range(len(res)):\\n  if res[p] == p+1:\\n   for q in range(len(res)):\\n    if res[q] != p+1:\\n     res[p], res[q] = res[q], res[p]\\n     break\\n print(*res)\\n\", \"for _ in range(int(input())):\\n n=int(input())\\n a=list(map(int,input().split()))\\n if sum(a)!=n or max(a)==n:\\n  print(-1)\\n  continue\\n else:\\n  rg=[]\\n  for i in range(n):\\n   if a[i]>0:\\n    rg.append([i,a[i]])\\n  new=[0 for _ in range(n)]\\n  new[rg[0][0]]=rg[-1][0]+1\\n  rg[-1][1]-=1\\n  for i in range(1,len(rg)):\\n   new[rg[i][0]]=rg[i-1][0]+1\\n   rg[i-1][1]-=1\\n  j=0 \\n  i=0\\n  while i<=n-1:\\n   if new[i]==0:\\n    if rg[j][1]>0:\\n     new[i]=rg[j][0]+1\\n     rg[j][1]-=1\\n     i+=1\\n    else:\\n     j+=1\\n    if rg[j][1]==0:\\n     j+=1\\n   else:\\n    i+=1\\n\\n\\n   \\n  print(*new)\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/1005", "prompt": "def closest_farthest_values(N: int, values: List[int], edges: List[Tuple[int, int]], Q: int, queries: List[Tuple[str, int, int]]) -> List[int]:\n    \"\"\"\n    Takaki Tono is a Computer Programmer in Tokyo. His boss at work shows him an online puzzle, which if solved would earn the solver a full expense paid trip to Los Angeles, California. Takaki really wants to solve this, as the love of his life, Akari, lives in Los Angeles and he hasn't met her since four years. Upon reading the puzzle he realizes that it is a query based problem. The problem is as follows :-\n    \n    You are given a Tree T with N nodes numbered from 1 to N, with each node numbered z having a positive integer Az written on it. This integer denotes the value of the node. You have to process Q queries, of the following forms :-\n    1) C x y : Report the closest two values in the unique path from x to y i.e compute min(|Ap - Aq|) where p and q are two distinct nodes on the unique path from x to y.\n    \n    2) F x y : Report the farthest two values in the unique path from x to y i.e. compute max(|Ap - Aq|) where p and q are two distinct nodes on the unique path from x to y.\n    \n    It is also mentioned that x is not equal to y in any query and that no two nodes have the same value printed on them. Also, |x| denotes the absolute value of x.\n    \n    Takaki is perplexed and requires your help to solve this task? Can you help him out?\n    \n    -----Input-----\n    The first line of the input contains an integer N denoting the number of nodes in tree T.\n    The second line comprises N space separated integers denoting A, where the i-th integer denotes Ai.\n    The next N-1 lines each comprise two space separated integers u and v, denoting that node u and node v\n    are connected by an edge. It is guaranteed that the final graph will be a connected tree.\n    The next line contains a single integer Q, denoting number of queries.\n    The next Q lines comprise the queries. Each such line is of the format C x y or F x y.\n    \n    -----Output-----\n    For each query, print the required output as mentioned above.\n    \n    -----Constraints-----\n    - 2 \u2264 N \u2264 35000\n    - 1 \u2264 Ai \u2264 109\n    - 1 \u2264 Q \u2264 35000\n    - 1 \u2264 u, v \u2264 N\n    - No two nodes have the same value printed on them.\n    - x is not equal to y in any query.\n    \n    -----Subtasks-----\n    \n    -----Subtasks-----Subtask #1 (15 points)\n    - N, Q \u2264 1000Subtask #2 (20 points)\n    - Only Type F queries are present.Subtask #3 (65 points)\n    - Original constraints\n    \n    -----Example-----\n    Input:5\n    1 2 7 4 5\n    1 2\n    2 3\n    2 4\n    2 5\n    7\n    C 1 5\n    F 1 5\n    C 2 4\n    C 1 2\n    F 1 3\n    F 3 4\n    F 2 4\n    \n    Output:1\n    4\n    2\n    1\n    6\n    5\n    2\n    \n    -----Explanation-----\n    Given below is the tree corresponding to the sample input. Each node has two numbers written in it.\n    The first number represents the node index and the second number indicates node value.\n    \"\"\"\n", "entry_point": "closest_farthest_values", "test": "\ndef check(candidate):\n    assert candidate(5, [1, 2, 7, 4, 5], [(1, 2), (2, 3), (2, 4), (2, 5)], 7, [('C', 1, 5), ('F', 1, 5), ('C', 2, 4), ('C', 1, 2), ('F', 1, 3), ('F', 3, 4), ('F', 2, 4)]) == [1, 4, 2, 1, 6, 5, 2]\ncheck(closest_farthest_values)\n", "given_tests": ["assert closest_farthest_values(5, [1, 2, 7, 4, 5], [(1, 2), (2, 3), (2, 4), (2, 5)], 7, [('C', 1, 5), ('F', 1, 5), ('C', 2, 4), ('C', 1, 2), ('F', 1, 3), ('F', 3, 4), ('F', 2, 4)]) == [1, 4, 2, 1, 6, 5, 2]"], "canonical_solution": "[\"MAXX = 10**9+1\\nN = eval(input())\\nnodes = list(map(int, input().split(\\\" \\\")))\\nedges = [set() for _ in range(N)]\\nfor _ in range(N-1):\\n    a, b = list(map(int, input().split(\\\" \\\")))\\n    edges[a-1].add(b-1)\\n    edges[b-1].add(a-1)\\npath = [[] for _ in range(N)]\\nvisited, tovisit = set(), [(0, 0)]\\nwhile tovisit:\\n    p, v = tovisit.pop()\\n    if v not in visited:\\n        path[v] = path[p] + [v]\\n        visited.add(v)\\n        news = edges[v] - visited\\n        tovisit.extend([(v, x) for x in news])\\n# print path\\n\\nQ = eval(input())\\nfor _ in range(Q):\\n    q, a, b = input().split(\\\" \\\")\\n    a, b = int(a)-1, int(b)-1\\n    i = 1\\n    while i < min(len(path[a]), len(path[b])):\\n        if path[a][i] != path[b][i]: break\\n        i += 1\\n    s = path[a][i-1:] + path[b][i:]\\n\\n    # print s\\n    if q == \\\"C\\\":\\n        s = sorted([nodes[i] for i in s])\\n        d = s[-1] - s[0]\\n        for i in range(len(s)-1):\\n            d = min(d, s[i+1]-s[i])\\n        print(d)\\n    else:\\n        M = 0\\n        m = MAXX\\n        for i in range(len(s)):\\n            M = max(M, nodes[s[i]])\\n            m = min(m, nodes[s[i]])\\n        print(M - m)\\n    # print M[(s, l)] - m[(s, l)]\", \"\\n\\nN = eval(input())\\nnodes = list(map(int, input().split(\\\" \\\")))\\nedges = [set() for _ in range(N)]\\nfor _ in range(N-1):\\n    a, b = list(map(int, input().split(\\\" \\\")))\\n    edges[a-1].add(b-1)\\n    edges[b-1].add(a-1)\\npath = [[] for _ in range(N)]\\nvisited, tovisit = set(), [(0, 0)]\\nwhile tovisit:\\n    p, v = tovisit.pop()\\n    if v not in visited:\\n        path[v] = path[p] + [v]\\n        visited.add(v)\\n        news = edges[v] - visited\\n        tovisit.extend([(v, x) for x in news])\\n# print path\\n\\nQ = eval(input())\\nfor _ in range(Q):\\n    q, a, b = input().split(\\\" \\\")\\n    a, b = int(a)-1, int(b)-1\\n    i = 1\\n    while i < min(len(path[a]), len(path[b])):\\n        if path[a][i] != path[b][i]: break\\n        i += 1\\n    s = path[a][i-1:] + path[b][i:]\\n    s = sorted([nodes[i] for i in s])\\n    # print s\\n    if q == \\\"C\\\":\\n        d = s[-1] - s[0]\\n        for i in range(len(s)-1):\\n            d = min(d, s[i+1]-s[i])\\n        print(d)\\n    else:\\n        print(s[-1] - s[0])\\n    # print M[(s, l)] - m[(s, l)]\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/586", "prompt": "def team_scores(T: int, cases: List[Tuple[int, int, List[Tuple[str, int]], List[Tuple[str, int]]]]) -> List[List[Tuple[str, int]]]:\n    \"\"\"\n    Teacher Sungjae wanted to hold a programming competition for his students where every participant need to be included into  team. The participants submitted their team names before the deadline. After the competition ran for half an hour, (It is assured that each registered team will submit absolutely once within half an hour) Sungjae mistakenly pressed a button that changed the order of the registered team names. Now in the submission list, order of the characters in the team's name doesn't matter. That means $abc$, $acb$, $bac$, $bca$, $cab$, $cba$ refers to the same team. The competition ran for two hours and then ended. Sungjae now counting each of the team's score and wants to print the registered team names and score. The scoreboard should be ordered based on scores in decreasing order and if two teams have same score, Sangjae would follow lexicographical order.\n    $N$.$B$. frequency of each character's in a registered team's name will not match with another team.\n    That means two teams named $xoxo$ and $oxox$ is not possible. Because both of them have the same frequency of each of the characters (two 'o' and two 'x'). Similarly $abb$ and $bab$ is not possible (because both of them have one 'a' and two 'b').\n    It is ensured that only possible test cases will be given.\n    \n    -----Input:-----Input:\n    -\n    First line will contain $T$, number of testcases. Then the testcases follow.\n    -\n    The first line of each test case contains two integers , $N$ and $R$ - total number of submissions and the number of submissions within first half an hour.\n    -\n    Then $R$  lines follow: the i'th line contains a string $ti$, registered names of the teams and an integer $pi$, points they got on that submission.\n    -\n    Then $N-R$  lines follow: the i-th line contains a string $ti$- the i-th team's name (in any order) in lowercase letter only and $pi$ -points they got on that submission.\n    \n    -----Output:-----Output:\n    For each testcase,print the scoreboard.\n    That means print the teams name and their point according to their score in decreasing order and if some of them have same score,print the teams name in lexicographical order\n    \n    -----Constraints-----Constraints\n    - $1 \\leq T \\leq 10$\n    - $1 \\leq R \\leq N \\leq 1000$\n    - $1 \\leq ti \\leq 1000$\n    - $1 \\leq pi \\leq 10^6$\n    Sum of points ($pi$) of a team will not cross $10^9$.\n    \n    -----Sample Input:-----Sample Input:\n    1\n    10 5\n    amigoes  1\n    bannermen 1\n    monarchy 4\n    outliers 5\n    iniciador 10\n    aegimos 2\n    iiiacdnor 1\n    eilorstu 1\n    gimosae 3\n    mnachroy 7\n    \n    -----Sample Output:-----Sample Output:\n    iniciador 11\n    monarchy 11\n    amigoes 6\n    outliers 6\n    bannermen 1\n    \n    -----Explanation:-----Explanation:\n    \n    $It$ $is$ $assured$ $that$ $each$ $team$ $will$ $submit$ $once$ $within$ $first$ $half$ $an$ $hour$.That means -\n    \n    that kind of submissions isn't possible within first half an hour.\n    Dataset can be huge. Use faster I/O method.\n    \"\"\"\n", "entry_point": "team_scores", "test": "\ndef check(candidate):\n    assert candidate(1, [(10, 5, [('amigoes', 1), ('bannermen', 1), ('monarchy', 4), ('outliers', 5), ('iniciador', 10)], [('aegimos', 2), ('iiiacdnor', 1), ('eilorstu', 1), ('gimosae', 3), ('mnachroy', 7)])]) == [['iniciador', 11], ['monarchy', 11], ['amigoes', 6], ['outliers', 6], ['bannermen', 1]]\ncheck(team_scores)\n", "given_tests": ["assert team_scores(1, [(10, 5, [('amigoes', 1), ('bannermen', 1), ('monarchy', 4), ('outliers', 5), ('iniciador', 10)], [('aegimos', 2), ('iiiacdnor', 1), ('eilorstu', 1), ('gimosae', 3), ('mnachroy', 7)])]) == [['iniciador', 11], ['monarchy', 11], ['amigoes', 6], ['outliers', 6], ['bannermen', 1]]"], "canonical_solution": "[\"# cook your dish here\\nfor t in range(int(input())):\\n    n,k=map(int,input().split())\\n    a=[]\\n    sr=[]\\n    for i in range(k):\\n        x,y=input().split()\\n        y=int(y)\\n        a.append([10**10-y,x])\\n        sr.append(sorted(x))\\n    for i in range(n-k):\\n        x,y=input().split()\\n        y=int(y)\\n        x=sorted(x)\\n        for j in range(k):\\n            if x==sr[j]:\\n                a[j][0]-=y\\n                break\\n    a.sort()\\n    for i in a:\\n        print(i[1],abs(i[0]-10**10))\", \"for _ in range(int(input())):\\n    n,r=map(int,input().split())\\n    s=[]\\n    d=dict()\\n    for i in range(r):\\n        a,b=map(str,input().split())\\n        s.append([int(b),a])\\n        a=list(a)\\n        a.sort()\\n        d[''.join(a)]=i\\n    for i in range(n-r):\\n        a,b=map(str,input().split())\\n        a=list(a)\\n        a.sort()\\n        s[d[''.join(a)]][0]+=int(b)\\n    s.sort(key=lambda x:x[1], reverse=True)\\n    s.sort(key=lambda x:x[0])\\n    for i in range(-1,-r-1,-1):\\n        print(s[i][1],s[i][0])\", \"for _ in range(int(input())):\\n    n,r=map(int,input().split())\\n    s=[]\\n    d=dict()\\n    for i in range(r):\\n        a,b=map(str,input().split())\\n        s.append([int(b),a])\\n        a=list(a)\\n        a.sort()\\n        d[''.join(a)]=i\\n    for i in range(n-r):\\n        a,b=map(str,input().split())\\n        a=list(a)\\n        a.sort()\\n        s[d[''.join(a)]][0]+=int(b)\\n    s.sort(key=lambda x:x[1], reverse=True)\\n    s.sort(key=lambda x:x[0])\\n    for i in range(-1,-r-1,-1):\\n        print(s[i][1],s[i][0])\", \"# cook your dish here\\nfor _ in range(int(input())):\\n    n, r = map(int, input().split())\\n    reg_teams = [input().split() for _ in range(r)]\\n    after = [input().split() for _ in range(n - r)]\\n    check1 = [[''.join(sorted(list(s))), int(p), s] for s, p in reg_teams]\\n    check2 = {}\\n    for a in after:\\n        cur = \\\"\\\".join(sorted(list(a[0])))\\n        if cur in check2.keys():\\n            check2[cur] += int(a[1])\\n        else:\\n            check2[cur] = int(a[1])\\n    for c in check1:\\n        if c[0] in check2.keys():\\n            c[1] += check2[c[0]]\\n\\n    check1.sort(key = lambda z: z[2])\\n    check1.sort(key = lambda z: z[1], reverse = True)\\n    for c in check1:\\n        print(c[2], c[1])\"]", "difficulty": "interview"}
{"task_id": "APPS/1478", "prompt": "def find_maximum_period(T: int, cases: List[Tuple[int, List[int]]]) -> List[Union[int, str]]:\n    \"\"\"\n    Let's define a periodic infinite sequence S$S$ (0$0$-indexed) with period K$K$ using the formula Si=(i%K)+1$S_i = (i \\% K) + 1$.\n    Chef has found a sequence of positive integers A$A$ with length N$N$ buried underground. He suspects that it is a contiguous subsequence of some periodic sequence. Unfortunately, some elements of A$A$ are unreadable. Can you tell Chef the longest possible period K$K$ of an infinite periodic sequence which contains A$A$ (after suitably filling in the unreadable elements) as a contiguous subsequence?\n    \n    -----Input-----\n    - The first line of the input contains a single integer T$T$ denoting the number of test cases. The description of T$T$ test cases follows.\n    - The first line of each test case contains a single integer N$N$.\n    - The second line contains N$N$ space-separated integers A1,A2,\u2026,AN$A_1, A_2, \\dots, A_N$. Unreadable elements are denoted by \u22121$-1$.\n    \n    -----Output-----\n    For each test case, print a single line.\n    - If the period can be arbitrarily large, this line should contain a single string \"inf\".\n    - Otherwise, if A$A$ cannot be a contiguous subsequence of a periodic sequence, it should contain a single string \"impossible\".\n    - Otherwise, it should contain a single integer \u2014 the maximum possible period.\n    \n    -----Constraints-----\n    - 1\u2264T\u2264100$1 \\le T \\le 100$\n    - 2\u2264N\u2264105$2 \\le N \\le 10^5$\n    - the sum of N$N$ over all test cases does not exceed 106$10^6$\n    - for each valid i$i$, 1\u2264Ai\u2264106$1 \\le A_i \\le 10^6$ or Ai=\u22121$A_i = -1$\n    \n    -----Subtasks-----\n    Subtask #1 (50 points):\n    - 2\u2264N\u22641,000$2 \\le N \\le 1,000$\n    - the sum of N$N$ over all test cases does not exceed 10,000$10,000$\n    Subtask #2 (50 points): original constraints\n    \n    -----Example Input-----\n    3\n    3\n    -1 -1 -1\n    5\n    1 -1 -1 4 1\n    4\n    4 6 7 -1\n    \n    -----Example Output-----\n    inf\n    4\n    impossible\n    \"\"\"\n", "entry_point": "find_maximum_period", "test": "\ndef check(candidate):\n    assert candidate(3, [(3, [-1, -1, -1]), (5, [1, -1, -1, 4, 1]), (4, [4, 6, 7, -1])]) == ['inf', '4', 'impossible']\ncheck(find_maximum_period)\n", "given_tests": ["assert find_maximum_period(3, [(3, [-1, -1, -1]), (5, [1, -1, -1, 4, 1]), (4, [4, 6, 7, -1])]) == ['inf', '4', 'impossible']"], "canonical_solution": "[\"# cook your dish here\\nfrom math import gcd\\nfor _ in range(int(input())):\\n    n,a,k,min_k,e = int(input()),[int(i) for i in input().split()],0,0,-1   \\n    for j in range(n):\\n     if(a[j] != -1):break            \\n    for i in range(j,n):\\n     if min_k==0:min_k,e = a[i],a[i]+1 \\n     else:\\n      if min_k < a[i]:min_k = a[i]                \\n      if(a[i] == -1):pass\\n      else:\\n       if(a[i] == e):pass\\n       else:\\n        if( k == 0):k = e-a[i]\\n        else:\\n         new_k = e-a[i]\\n         if(new_k < 0):k = -1\\n         else:k = gcd(k,new_k)\\n        if(k<min_k or k<0): k = -1; break\\n      if k != 0 and a[i]!=-1: e = a[i]%k+1\\n      else:e += 1             \\n    if(k == -1):print(\\\"impossible\\\")\\n    elif k == 0 :print(\\\"inf\\\")\\n    else:print(k)  \", \"# cook your dish here\\nfrom math import gcd\\nfor _ in range(int(input())):\\n    n,a,k,min_k,e = int(input()),[int(i) for i in input().split()],0,0,-1   \\n    for j in range(n):\\n     if(a[j] != -1):break            \\n    for i in range(j,n):\\n     if min_k==0:min_k,e = a[i],a[i]+1 \\n     else:\\n      if min_k < a[i]:min_k = a[i]                \\n      if(a[i] == -1):pass\\n      else:\\n       if(a[i] == e):pass\\n       else:\\n        if( k == 0):k = e-a[i]\\n        else:\\n         new_k = e-a[i]\\n         if(new_k < 0):k = -1\\n         else:k = gcd(k,new_k)\\n        if(k<min_k or k<0): k = -1; break\\n      if k != 0 and a[i]!=-1: e = a[i]%k+1\\n      else:e += 1             \\n    if(k == -1):print(\\\"impossible\\\")\\n    elif k == 0 :print(\\\"inf\\\")\\n    else:print(k)  \", \"from math import gcd\\nfor _ in range(int(input())):\\n    n,a,k,min_k,e = int(input()),[int(i) for i in input().split()],0,0,-1   \\n    for j in range(n):\\n     if(a[j] != -1):break            \\n    for i in range(j,n):\\n     if min_k==0:min_k,e = a[i],a[i]+1 \\n     else:\\n      if min_k < a[i]:min_k = a[i]                \\n      if(a[i] == -1):pass\\n      else:\\n       if(a[i] == e):pass\\n       else:\\n        if( k == 0):k = e-a[i]\\n        else:\\n         new_k = e-a[i]\\n         if(new_k < 0):k = -1\\n         else:k = gcd(k,new_k)\\n        if(k<min_k or k<0): k = -1; break\\n      if k != 0 and a[i]!=-1: e = a[i%k]+1\\n      else:e += 1             \\n    if(k == -1):print(\\\"impossible\\\")\\n    elif k == 0 :print(\\\"inf\\\")\\n    else:print(k)  \"]", "difficulty": "interview"}
{"task_id": "APPS/1353", "prompt": "def verify_logs(T: int, cases: List[Tuple[int, List[Tuple[int, int, int, int, int]]]]) -> List[str]:\n    \"\"\"\n    You are in the future. It's the time of autonomous cars. Switching lanes is a pretty difficult task for autonomous cars, and you have the logs from an experiment you had run with two cars. You want to verify whether the logs are corrupted, or could be valid.\n    In that experiment, you had a highway consisting of two lanes. These were represented by 2 rows of an infinite grid. The cell (1, 1) is the top left cell which is the starting point of the first lane. Cell (2, 1) is the bottom left cell of the grid which is the starting point of the second lane.\n    There are two cars, 1 and 2 that start from the cell (1, 1) and (2, 1).\n    At each instant, a car has the following choices.\n    - Stay at the current position.\n    - Move one cell to the right.\n    - Switch Lanes. When a car switches its lane, it stays in the same column. That is, from (1, i) it could go to (2, i), or from (2, i) it could go to (1, i). But both both cars shouldn't end up at the same cell at any point. Note that there could have been a car which had moved at the very instant that you move into it.\n    Consider one such scenario of driving cars.\n    Time $t = 0$\n    1.....\n    2.....\n    \n    Time $t = 1$. Car 2 advances one cell right. Car 1 stays at the same place.\n    1.....\n    .2....\n    \n    Time $t = 2$. Car 2 stays at its place. Car 1 switches the lane.\n    ......\n    12....\n    \n    Time $t = 3$. Car 2 moves one cell to the right.  Car 1 also moves one cell to the right.\n    ......\n    .12...\n    \n    Time $t = 4$. Both the cars stay in the same place.\n    ......\n    .12...\n    \n    You are given positions of the car at $n$ instants. Your task is to check whether this situation is feasible or not.\n    \n    -----Input-----\n    - The first line of the input contains an integer $T$ denoting the number of test cases. The description of the test cases follows.\n    - The first line of each test case contains an integer $n$ denoting the number of instants where the positions of the cars were recorded.\n    - Each of next $n$ lines contains 5 space separated integers denoting $t_i, x_i, y_i, X_i, Y_i$ denoting time, $x$ and $y$ coordinate of the first car, and that of second car.\n    \n    -----Output-----\n    For each test case, output either yes or no according to the answer to the problem.\n    \n    -----Constraints-----\n    - $1 \\le T \\le 10^5$\n    - $1 \\le n \\leq 10^5$\n    - $1 \\le t_i, y_i, X_i, Y_i \\leq 10^9$\n    - $1 \\leq x_i \\leq 2$\n    - $t_i < t_{i+1}$\n    - Sum of $n$ over all the test cases doesn't exceed $10^6$\n    \n    -----Example Input-----\n    2\n    3\n    1 1 1 2 2\n    2 2 1 2 2\n    4 2 2 2 3\n    1\n    1 1 3 2 2\n    \n    -----Example Output-----\n    yes\n    no\n    \"\"\"\n", "entry_point": "verify_logs", "test": "\ndef check(candidate):\n    assert candidate(2, [(3, [(1, 1, 1, 2, 2), (2, 2, 1, 2, 2), (4, 2, 2, 2, 3)]), (1, [(1, 1, 3, 2, 2)])]) == ['yes', 'no']\ncheck(verify_logs)\n", "given_tests": ["assert verify_logs(2, [(3, [(1, 1, 1, 2, 2), (2, 2, 1, 2, 2), (4, 2, 2, 2, 3)]), (1, [(1, 1, 3, 2, 2)])]) == ['yes', 'no']"], "canonical_solution": "[\"# cook your dish here\\ndef check(px,x):\\n if px[1]==x[1]:\\n  return (x[2]-px[2])<=(x[0]-px[0]) and (x[2]>=px[2])\\n else:\\n  return (x[2]-px[2]+1)<=(x[0]-px[0]) and (x[2]>=px[2])\\n  \\ndef checkdouble(px,x):\\n if px[3]==x[3]:\\n  return (x[4]-px[4])<=(x[0]-px[0]) and (x[4]>=px[4])\\n else:\\n  return (x[4]-px[4]+1)<=(x[0]-px[0]) and (x[4]>=px[4])\\n  \\n\\nfor _ in range(int(input())):\\n px=[0,1,1,2,1]\\n g=True\\n for _ in range(int(input())):\\n  x=list(map(int,input().split()))\\n  if x[1]==x[3] and x[2]==x[4]:\\n   g=False\\n  if not g:\\n   continue\\n  g=check(px,x)\\n  if g:\\n   g=checkdouble(px,x)\\n  px=x\\n if not g:\\n  print(\\\"no\\\")\\n else:\\n  print(\\\"yes\\\")\\n \\n \\n \\n \\n \\n \\n\", \"def check(px,x):\\n if px[1]==x[1]:\\n  return (x[2]-px[2])<=(x[0]-px[0]) and (x[2]>=px[2])\\n else:\\n  return (x[2]-px[2]+1)<=(x[0]-px[0]) and (x[2]>=px[2])\\n  \\ndef checkdouble(px,x):\\n if px[3]==x[3]:\\n  return (x[4]-px[4])<=(x[0]-px[0]) and (x[4]>=px[4])\\n else:\\n  return (x[4]-px[4]+1)<=(x[0]-px[0]) and (x[4]>=px[4])\\n  \\n\\nfor _ in range(int(input())):\\n px=[0,1,1,2,1]\\n g=True\\n for _ in range(int(input())):\\n  x=list(map(int,input().split()))\\n  if x[1]==x[3] and x[2]==x[4]:\\n   g=False\\n  if not g:\\n   continue\\n  g=check(px,x)\\n  if g:\\n   g=checkdouble(px,x)\\n  px=x\\n if not g:\\n  print(\\\"no\\\")\\n else:\\n  print(\\\"yes\\\")\\n\", \"def check1(t,x,y,px,py):\\n if x==px:\\n  return y-py<=t and py<=y\\n return y-py+1<=t and py<=y\\ndef check(px,x):\\n t=x[0]-px[0]\\n return (check1(t,x[1],x[2],px[1],px[2])\\n  and check1(t,x[3],x[4],px[3],px[4]))\\nfor _ in range(int(input())):\\n px=[0,1,1,2,1]\\n g=True\\n for _ in range(int(input())):\\n  x=list(map(int,input().split()))\\n  if x[1]==x[3] and x[2]==x[4]:\\n   g=False\\n  if g:\\n   g=check(px,x)\\n  px=x\\n if g:\\n  print(\\\"yes\\\")\\n else:\\n  print(\\\"no\\\") \", \"def time(x1,y1,x2,y2):\\n if x1==x2:\\n  return y2-y1\\n return y2-y1+1\\n\\nans=['no','yes'] \\nfor _ in range(int(input())):\\n t, fx, fy, sx, sy, f=0, 1, 1, 2, 1, 1\\n for _ in range (int(input())):\\n  a=[int(x) for x in input().split()]\\n  if f:\\n   if a[1]==a[3] and a[2]==a[4]:\\n    f=0\\n    continue\\n   if fy>a[2] or sy>a[4]:\\n    f=0\\n    continue\\n   t1=time(fx,fy,a[1],a[2])\\n   t2=time(sx,sy,a[3],a[4])\\n   _t=a[0]-t\\n   if t1>_t or t2>_t:\\n    f=0\\n  t, fx, fy, sx, sy=a\\n print(ans[f])\\n \\n\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/1563", "prompt": "def reverse_sum(N: int, cases: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    A reversed arabic no is one whose digits have been written in the reversed order. However in this any trailing zeroes are omitted. The task at hand here is a simple one. You need to add two numbers which have been written in reversed arabic and return the output back in reversed arabic form, assuming no zeroes were lost while reversing.\n    \n    \n    -----Input-----\n    The input consists of N cases. The first line of the input contains only a positive integer N. Then follow the cases. Each case consists of exactly one line with two positive integers seperated by space. These are the reversednumbers you are to add.\n    \n    \n    -----Output-----\n    For each case, print exactly one line containing only one integer- the reversed sum of two reversed numbers. Omit any leading zeroes in the output.\n    \n    \n    -----Example-----\n    Input:\n    1\n    24 1\n    \n    Output:\n    34\n    \"\"\"\n", "entry_point": "reverse_sum", "test": "\ndef check(candidate):\n    assert candidate(1, [(24, 1)]) == [34]\ncheck(reverse_sum)\n", "given_tests": ["assert reverse_sum(1, [(24, 1)]) == [34]"], "canonical_solution": "[\"n = int(input())\\nfor index in range(0, n):\\n a, b = list(map(str, input().split()))\\n a = int(a[::-1])\\n b = int(b[::-1])\\n a = str(a + b)\\n a = int(a[::-1])\\n print(a)\", \"for _ in range(int(input())):\\n n,m=input().split()\\n n=int(n[::-1])\\n m=int(m[::-1])\\n ans=str(n+m)[::-1]\\n print(int(ans))\", \"T = int(input())\\nfor ca in range(0, T):\\n x, y = (input()).split(' ')\\n z = int(str(int(x[::-1]) + int(y[::-1]))[::-1])\\n print(z)\\n\", \"#! /usr/bin/python\\n\\nt = int(input())\\n\\nfor i in range(t):\\n inp = input().split()\\n a = list(inp[0])\\n b = list(inp[1])\\n\\n a.reverse()\\n b.reverse()\\n \\n x = int(''.join(a))\\n y = int(''.join(b))\\n\\n c = list(str(x+y))\\n c.reverse()\\n \\n z = int(''.join(c))\\n print(z)\\n\", \"t = int(input(\\\"\\\"));\\nfor i in range(t):\\n s1,s2 = (input(\\\"\\\").split());\\n s1=str(int(s1))\\n s2=str(int(s2))\\n s1 = s1[::-1];\\n s2 = s2[::-1];\\n sum = int(s1) + int(s2) ;\\n sum = str(sum)\\n sum = sum[::-1];\\n print(int(sum))\", \"for case in range(int(input())):\\n a,b = input().split()\\n print(str(int(a[::-1]) + int(b[::-1]))[::-1].lstrip(\\\"0\\\"))\", \"case = int(input())\\nfor i in range(0, case):\\n try:\\n  l = [elem for elem in input().split()]\\n  res = int(l[0][::-1]) + int(l[1][::-1])\\n  print(int(str(res)[::-1]))\\n except:\\n  break\", \"case = int(input())\\nfor i in range(0, case):\\n try:\\n  l = [elem for elem in input().split()]\\n  res = int(l[0][::-1]) + int(l[1][::-1])\\n  print(int(str(res)[::-1]))\\n except:\\n  break\\n\", \"N=int(input())\\ni=0\\nwhile i<N:\\n a=input()\\n a=list(a)\\n a.reverse()\\n a=''.join(a)\\n a=a.split()\\n a=int(a[0])+int(a[1])\\n a=list(str(a))\\n a.reverse()\\n a=''.join(a)\\n a=str(int(a))\\n i=i+1\\n print(a)\\n\", \"for tst in range(int(input())):\\n m, n = input().split()\\n m = m[::-1]\\n n = n[::-1]\\n m = int(m)\\n n = int(n)\\n x = m+n\\n x = str(x)\\n x = x[::-1]\\n x = int(x)\\n print(x)\\n\", \"#/usr/bin/python\\n\\ndef main():\\n test = int(input())\\n for i in range(test):\\n  x = input()\\n  l = x.split()\\n  a = str(l[0])\\n  b = str(l[1])\\n  a = a[::-1]\\n  b = b[::-1]\\n  c = int(a) + int(b)\\n  s = str(c)\\n  s = s[::-1]\\n  print(int(s))\\n\\ndef __starting_point():\\n  main()\\n\\n\\n__starting_point()\", \"t=int(input())\\nfor i in range(t):\\n a=input().split()\\n print(int(repr(int(a[0][::-1])+int(a[1][::-1]))[::-1]))\\n\", \"for i in range(int(input())):\\n x = input()\\n a = x.split()[0]\\n b = x.split()[1]\\n print(str(int(str(int(a[::-1]) + int(b[::-1]))[::-1])))\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/1132", "prompt": "def count_valid_sequences(T: int, cases: List[int]) -> List[int]:\n    \"\"\"\n    Shaun was given $N$ pairs of parenthesis ( )  by his teacher who gave him a difficult task.The task consists of two steps. First,Shaun should colour all $N$ pairs of parenthesis each with different color but opening and closing bracket of a particular pair should be of same colour. Then,Shaun should report to his teacher the number of ways he can arrange all $2*N$ brackets such that sequence form is valid. Teacher defined valid sequence by these rules:\n    - Any left parenthesis '(' must have a corresponding right parenthesis ')'.\n    - Any right parenthesis ')' must have a corresponding left parenthesis '('.\n    - Left parenthesis '(' must go before the corresponding right parenthesis ')'.\n    Note: Shaun could match opening and closing brackets of different colours.\n    Since number of ways can be large, Shaun would report the answer as modulo 1000000007 ($10^9 + 7$).\n    \n    -----Input:-----\n    - First line will contain $T$, number of testcases. Then the testcases follow.\n    - Each testcase contains of a single line of input, one integer $N$.\n    \n    -----Output:-----\n    For each testcase, output in a single line answer given by Shaun to his teacher modulo 1000000007.\n    \n    -----Constraints-----\n    - $1 \\leq T \\leq 100000$\n    - $1 \\leq N \\leq 100000$\n    \n    -----Sample Input:-----\n    3\n    1\n    2\n    3\n    \n    -----Sample Output:-----\n    1\n    6\n    90\n    \n    -----EXPLANATION:-----\n    Here numbers from $1$ to $N$ have been used to denote parenthesis.A unique number corresponds to a unique pair of parenthesis.\n    -In the first test case , you can use only one color to color the parenthesis  you could arrange it only in one way i.e, 1 1\n    -In the second test case  you can use two colors and the possible ways of arranging it are\n    1 1 2 2\n    1 2 2 1\n    1 2 1 2\n    2 2 1 1\n    2 1 1 2\n    2 1 2 1\n    \"\"\"\n", "entry_point": "count_valid_sequences", "test": "\ndef check(candidate):\n    assert candidate(3, [1, 2, 3]) == [1, 6, 90]\ncheck(count_valid_sequences)\n", "given_tests": ["assert count_valid_sequences(3, [1, 2, 3]) == [1, 6, 90]"], "canonical_solution": "[\"mod = 1000000007\\r\\nfac = [1,1]\\r\\nmaxn = (10**5)+5\\r\\nfor i in range(2,maxn):\\r\\n    x = (fac[-1]*i)%mod\\r\\n    fac.append(x)\\r\\n\\r\\npre = [1]\\r\\nfor i in range(2,maxn):\\r\\n    x = 2*i-1\\r\\n    x = (pre[-1]*x)%mod\\r\\n    pre.append(x)\\r\\n\\r\\nfor _ in range(int(input())):\\r\\n    n = int(input())\\r\\n    x = fac[n]\\r\\n    y = pre[n-1]\\r\\n    print((x*y)%mod)\", \"def getdp():\\n    nonlocal mod,maxx\\n    for i in range(2,maxx):\\n        n = 2*(i-1) + 1 \\n        n = (n * (n+1))//2 \\n        dp[i] = (dp[i-1]*n)%mod \\n\\nmod = 1000000007\\nmaxx = 100001\\ndp=[1]*maxx\\ngetdp()\\nt=int(input())\\nwhile t>0 :\\n    n=int(input())\\n    print(dp[n])\\n    t-=1\", \"import atexit\\r\\nimport io\\r\\nimport sys\\r\\nimport math\\r\\nfrom collections import defaultdict,Counter\\r\\n\\r\\n# _INPUT_LINES = sys.stdin.read().splitlines()\\r\\n# input = iter(_INPUT_LINES).__next__\\r\\n# _OUTPUT_BUFFER = io.StringIO()\\r\\n# sys.stdout = _OUTPUT_BUFFER\\r\\n\\r\\n# @atexit.register\\r\\n# def write():\\r\\n#     sys.__stdout__.write(_OUTPUT_BUFFER.getvalue())\\r\\n\\r\\n# sys.stdout=open(\\\"CP2/output.txt\\\",'w')\\r\\n# sys.stdin=open(\\\"CP2/input.txt\\\",'r')\\r\\n\\r\\nm=pow(10,9)+7\\r\\nt=int(input())\\r\\nl=[0]*100001\\r\\nl[1]=1\\r\\nfor i in range(2,100001):\\r\\n    l[i]=(((i*l[i-1])%m)*(2*i-1))%m\\r\\nfor i in range(t):\\r\\n    n=int(input())\\r\\n    print(l[n])\\r\\n\", \"m = 10**9+7;a = [0]*(10**5+10);a[0] = 1\\nfor i in range(1,10**5+5):a[i] = (a[i-1]*(i*(2*i-1)%m)%m)\\nfor _ in range(int(input())):print(a[int(input())])\", \"a = list(map(int, open(0)))[1:]\\r\\nN = max(a) + 1\\r\\nb = [1] * N\\r\\nfor i in range(1, N):\\r\\n j = 2 * i\\r\\n b[i] = b[i - 1] * j * (j - 1) // 2 % (10**9 + 7)\\r\\n\\r\\nfor n in a:\\r\\n print(b[n])\\r\\n\", \"# generate the array\\nm = 10**9+7\\na = [0]*(10**5+10)\\na[0] = 1\\nfor i in range(1,10**5+5):\\n\\ta[i] = (a[i-1]*(i*(2*i-1)%m)%m)\\n\\nfor _ in range(int(input())):\\n\\tn = int(input())\\n\\tprint(a[n])\", \"N = 100001\\na = [1] * N\\nfor i in range(1, N):\\n j = 2 * i\\n a[i] = a[i - 1] * j * (j - 1) // 2 % (10**9 + 7)\\n\\nfor s in[*open(0)][1:]:\\n print(a[int(s)])\\n\", \"fac = 1\\nfacts = [1]\\nfor i in range(1,100000):\\n    fac = (fac*(2*i+1)*(i+1))%1000000007\\n    facts.append(fac)\\n\\nT = int(input())\\n\\nfor _ in range(T):\\n    N = int(input())\\n    print(facts[N-1])\", \"e=10**9+7\\nn=100000\\nl=[1]\\nfor i in range(1,n+1):\\n    x=(i*(2*i-1))%e\\n    l.append((x*l[-1])%e)\\nt=int(input())\\nfor _ in range(t):\\n    n=int(input())\\n    print(l[n])\\n\"]", "difficulty": "interview"}
{"task_id": "APPS/2227", "prompt": "def find_regular_bracket_subsequence(n: int, k: int, s: str) -> str:\n    \"\"\"\n    A bracket sequence is a string containing only characters \"(\" and \")\". A regular bracket sequence is a bracket sequence that can be transformed into a correct arithmetic expression by inserting characters \"1\" and \"+\" between the original characters of the sequence. For example, bracket sequences \"()()\" and \"(())\" are regular (the resulting expressions are: \"(1)+(1)\" and \"((1+1)+1)\"), and \")(\", \"(\" and \")\" are not.\n    \n    Subsequence is a sequence that can be derived from another sequence by deleting some elements without changing the order of the remaining elements.\n    \n    You are given a regular bracket sequence $s$ and an integer number $k$. Your task is to find a regular bracket sequence of length exactly $k$ such that it is also a subsequence of $s$.\n    \n    It is guaranteed that such sequence always exists.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers $n$ and $k$ ($2 \\le k \\le n \\le 2 \\cdot 10^5$, both $n$ and $k$ are even) \u2014 the length of $s$ and the length of the sequence you are asked to find.\n    \n    The second line is a string $s$ \u2014 regular bracket sequence of length $n$.\n    \n    \n    -----Output-----\n    \n    Print a single string \u2014 a regular bracket sequence of length exactly $k$ such that it is also a subsequence of $s$.\n    \n    It is guaranteed that such sequence always exists.\n    \n    \n    -----Examples-----\n    Input\n    6 4\n    ()(())\n    \n    Output\n    ()()\n    \n    Input\n    8 8\n    (()(()))\n    \n    Output\n    (()(()))\n    \"\"\"", "entry_point": "find_regular_bracket_subsequence", "test": "\ndef check(candidate):\n    assert find_regular_bracket_subsequence(6, 4, \"()(())\") == '()()'\n    assert find_regular_bracket_subsequence(8, 8, \"(()(()))\") == '(()(()))'\n    assert find_regular_bracket_subsequence(20, 10, \"((()))()((()()(())))\") == '((()))()()'\n    assert find_regular_bracket_subsequence(40, 30, \"((((((((()()()))))))))((())((()())))(())\") == '((((((((()()()))))))))(())()()'\n    assert find_regular_bracket_subsequence(2, 2, \"()\") == '()'\ncheck(find_regular_bracket_subsequence)\n", "given_tests": ["assert find_regular_bracket_subsequence(6, 4, \"()(())\") == '()()'", "assert find_regular_bracket_subsequence(8, 8, \"(()(()))\") == '(()(()))'"], "canonical_solution": "[\"n, k = map(int, input().split())\\na = [0] * n\\nb = ['0'] * n\\nc = []\\ns = input()\\nfor i in range(n):\\n    if k != 0:\\n        if s[i] == '(':\\n            c.append(i)\\n        else:\\n            d = c.pop()\\n            a[i] = 1\\n            a[d] = 1\\n            k -= 2\\nfor i in range(n):\\n    if a[i] == 1:\\n        print(s[i], end = '')\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2310", "prompt": "def open_door(n: int, x: int) -> str:\n    \"\"\"\n    Important: All possible tests are in the pretest, so you shouldn't hack on this problem. So, if you passed pretests, you will also pass the system test.\n    \n    You are an adventurer currently journeying inside an evil temple. After defeating a couple of weak monsters, you arrived at a square room consisting of tiles forming an n \u00d7 n grid, surrounded entirely by walls. At the end of the room lies a door locked with evil magical forces. The following inscriptions are written on the door:\n    \n    The sound of clashing rocks will awaken the door!\n    \n    Being a very senior adventurer, you immediately realize what this means. In the room next door lies an infinite number of magical rocks. There are four types of rocks:   '^': this rock moves upwards;  '<': this rock moves leftwards;  '>': this rock moves rightwards;  'v': this rock moves downwards.\n    \n    To open the door, you first need to place the rocks on some of the tiles (one tile can be occupied by at most one rock). Then, you select a single rock that you have placed and activate it. The activated rock will then move in its direction until it hits another rock or hits the walls of the room (the rock will not move if something already blocks it in its chosen direction). The rock then deactivates. If it hits the walls, or if there have been already 10^7 events of rock becoming activated, the movements end. Otherwise, the rock that was hit becomes activated and this procedure is repeated.\n    \n    If a rock moves at least one cell before hitting either the wall or another rock, the hit produces a sound. The door will open once the number of produced sounds is at least x. It is okay for the rocks to continue moving after producing x sounds.\n    \n    The following picture illustrates the four possible scenarios of moving rocks.\n    \n    \n    \n    Moves at least one cell, then hits another rock. A sound is produced, the hit rock becomes activated.\n    \n    [Image]\n    \n    Moves at least one cell, then hits the wall (i.e., the side of the room). A sound is produced, the movements end.\n    \n    [Image]\n    \n    Does not move because a rock is already standing in the path. The blocking rock becomes activated, but no sounds are produced.\n    \n    [Image]\n    \n    Does not move because the wall is in the way. No sounds are produced and the movements end.\n    \n    [Image]\n    \n    Assume there's an infinite number of rocks of each type in the neighboring room. You know what to do: place the rocks and open the door!\n    \n    \n    -----Input-----\n    \n    The first line will consists of two integers n and x, denoting the size of the room and the number of sounds required to open the door. There will be exactly three test cases for this problem:\n    \n    n = 5, x = 5;  n = 3, x = 2;  n = 100, x = 10^5.\n    \n    All of these testcases are in pretest.\n    \n    \n    -----Output-----\n    \n    Output n lines. Each line consists of n characters \u2014 the j-th character of the i-th line represents the content of the tile at the i-th row and the j-th column, and should be one of these:\n    \n    '^', '<', '>', or 'v': a rock as described in the problem statement.  '.': an empty tile.\n    \n    Then, output two integers r and c (1 \u2264 r, c \u2264 n) on the next line \u2014 this means that the rock you activate first is located at the r-th row from above and c-th column from the left. There must be a rock in this cell.\n    \n    If there are multiple solutions, you may output any of them.\n    \n    \n    -----Examples-----\n    Input\n    5 5\n    \n    Output\n    >...v\n    v.<..\n    ..^..\n    >....\n    ..^.<\n    1 1\n    \n    Input\n    3 2\n    \n    Output\n    >vv\n    ^<.\n    ^.<\n    1 3\n    \n    \n    \n    -----Note-----\n    \n    Here's a simulation of the first example, accompanied with the number of sounds produced so far.\n    \n    $8$ 0 sound\n    \n    [Image] 1 sound\n    \n    $8$ 2 sounds\n    \n    $8$ 3 sounds\n    \n    $8$ 4 sounds\n    \n    $8$ still 4 sounds\n    \n    In the picture above, the activated rock switches between the '^' rock and the '<' rock. However, no sound is produced since the '^' rock didn't move even a single tile. So, still 4 sound.\n    \n    [Image] 5 sounds\n    \n    At this point, 5 sound are already produced, so this solution is already correct. However, for the sake of example, we will continue simulating what happens.\n    \n    [Image] 6 sounds\n    \n    [Image] 7 sounds\n    \n    [Image] still 7 sounds\n    \n    [Image] 8 sounds\n    \n    And the movement stops. In total, it produces 8 sounds. Notice that the last move produced sound.\n    \n    Here's a simulation of the second example:\n    \n    [Image] 0 sound\n    \n    [Image] 1 sound\n    \n    [Image] 2 sounds\n    \n    Now, the activated stone will switch continuously from one to another without producing a sound until it reaches the 10^7 limit, after which the movement will cease.\n    \n    [Image]\n    \n    In total, it produced exactly 2 sounds, so the solution is correct.\n    \"\"\"\n", "entry_point": "open_door", "test": "\ndef check(candidate):\n    assert candidate(5, 5) == '>...v\\nv.<..\\n..^..\\n>....\\n..^.<\\n1 1'\n    assert candidate(3, 2) == '>vv\\n^<.\\n^.<\\n1 3'\ncheck(open_door)\n", "given_tests": ["assert open_door(5, 5) == '>...v\\nv.<..\\n..^..\\n>....\\n..^.<\\n1 1'", "assert open_door(3, 2) == '>vv\\n^<.\\n^.<\\n1 3'"], "canonical_solution": "[\"r, c = list(map(int, input().split()))\\nif r == 3:\\n    print('>vv')\\n    print('^<.')\\n    print('^.<')\\n    print('1 3')\\nelif r == 5:\\n    print('>...v')\\n    print('v.<..')\\n    print('..^..')\\n    print('>....')\\n    print('..^.<')\\n    print('1 1')\\nelif r == 100:\\n    for i in range(25):\\n        print('>'*50+'.>'*24+'.v')\\n        print('^'+'<.'*25+'<'*49)\\n        print('v.'+'<.'*24+'<'*50)\\n        print('>'*49+'.>'*25+'^')\\n    print('1 1')\\nelse:\\n    d = []\\n    d[1] = 1\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2140", "prompt": "def restore_array(n: int, b: List[int]) -> Union[str, Tuple[str, List[int]]]:\n    \"\"\"\n    While discussing a proper problem A for a Codeforces Round, Kostya created a cyclic array of positive integers $a_1, a_2, \\ldots, a_n$. Since the talk was long and not promising, Kostya created a new cyclic array $b_1, b_2, \\ldots, b_{n}$ so that $b_i = (a_i \\mod a_{i + 1})$, where we take $a_{n+1} = a_1$. Here $mod$ is the modulo operation. When the talk became interesting, Kostya completely forgot how array $a$ had looked like. Suddenly, he thought that restoring array $a$ from array $b$ would be an interesting problem (unfortunately, not A).\n    \n    \n    -----Input-----\n    \n    The first line contains a single integer $n$ ($2 \\le n \\le 140582$) \u2014 the length of the array $a$.\n    \n    The second line contains $n$ integers $b_1, b_2, \\ldots, b_{n}$ ($0 \\le b_i \\le 187126$).\n    \n    \n    -----Output-----\n    \n    If it is possible to restore some array $a$ of length $n$ so that $b_i = a_i \\mod a_{(i \\mod n) + 1}$ holds for all $i = 1, 2, \\ldots, n$, print \u00abYES\u00bb in the first line and the integers $a_1, a_2, \\ldots, a_n$ in the second line. All $a_i$ should satisfy $1 \\le a_i \\le 10^{18}$. We can show that if an answer exists, then an answer with such constraint exists as well.\n    \n    It it impossible to restore any valid $a$, print \u00abNO\u00bb in one line.\n    \n    You can print each letter in any case (upper or lower).\n    \n    \n    -----Examples-----\n    Input\n    4\n    1 3 1 0\n    \n    Output\n    YES\n    1 3 5 2\n    \n    Input\n    2\n    4 4\n    \n    Output\n    NO\n    \n    \n    \n    -----Note-----\n    \n    In the first example:  $1 \\mod 3 = 1$  $3 \\mod 5 = 3$  $5 \\mod 2 = 1$  $2 \\mod 1 = 0$\n    \"\"\"\n", "entry_point": "restore_array", "test": "\ndef check(candidate):\n    assert candidate(4, [1, 3, 1, 0]) == ('YES', [1, 3, 5, 2])\n    assert candidate(2, [4, 4]) == 'NO'\n    assert candidate(5, [5, 4, 3, 2, 1]) == ('YES', [5, 20, 16, 13, 11])\n    assert candidate(10, [3, 3, 3, 5, 6, 9, 3, 1, 7, 3]) == ('YES', [38, 35, 32, 29, 24, 9, 52, 49, 48, 41])\n    assert candidate(100, [57, 5, 28, 44, 99, 10, 66, 93, 76, 32, 67, 92, 67, 81, 33, 3, 6, 6, 67, 10, 41, 72, 5, 71, 27, 22, 21, 54, 21, 59, 36, 62, 43, 39, 28, 49, 55, 65, 21, 73, 87, 40, 0, 62, 67, 59, 40, 18, 56, 71, 15, 97, 73, 73, 2, 61, 54, 44, 6, 52, 25, 34, 13, 20, 18, 13, 25, 51, 19, 66, 63, 87, 50, 63, 82, 60, 11, 11, 54, 58, 88, 20, 33, 40, 85, 68, 13, 74, 37, 51, 63, 32, 45, 20, 30, 28, 32, 64, 82, 19]) == ('YES', [332, 275, 270, 242, 99, 4629, 4619, 4553, 4460, 4384, 4352, 4285, 4193, 4126, 4045, 4012, 4009, 4003, 3997, 3930, 3920, 3879, 3807, 3802, 3731, 3704, 3682, 3661, 3607, 3586, 3527, 3491, 3429, 3386, 3347, 3319, 3270, 3215, 3150, 3129, 3056, 2969, 2929, 2929, 2867, 2800, 2741, 2701, 2683, 2627, 2556, 2541, 2444, 2371, 2298, 2296, 2235, 2181, 2137, 2131, 2079, 2054, 2020, 2007, 1987, 1969, 1956, 1931, 1880, 1861, 1795, 1732, 1645, 1595, 1532, 1450, 1390, 1379, 1368, 1314, 1256, 1168, 1148, 1115, 1075, 990, 922, 909, 835, 798, 747, 684, 652, 607, 587, 557, 529, 497, 433, 351])\n    assert candidate(5, [1, 2, 3, 4, 5]) == ('YES', [20, 19, 17, 14, 5])\n    assert candidate(2, [0, 0]) == ('YES', [1, 1])\n    assert candidate(3, [1, 3, 0]) == ('YES', [7, 3, 7])\n    assert candidate(2, [100000, 100000]) == 'NO'\n    assert candidate(5, [1, 0, 0, 1, 1]) == ('YES', [3, 2, 2, 1, 4])\ncheck(restore_array)\n", "given_tests": ["assert restore_array(4, [1, 3, 1, 0]) == ('YES', [1, 3, 5, 2])", "assert restore_array(2, [4, 4]) == 'NO'"], "canonical_solution": "[\"n = int(input())\\nb = list(map(int, input().split()))\\nm, M = min(b), max(b)\\nif m == M:\\n    if M == 0:\\n        print('YES')\\n        print(' '.join(['1' for i in range(n)]))\\n    else:\\n        print('NO')\\nelse:\\n    print('YES')\\npos = list([i for i in range(n) if b[i] == M and b[i - 1] < M])[0]\\na = [0 for i in range(n)]\\na[pos] = M\\na[pos - 1] = (M << 1) + b[pos - 1]\\nfor i in range(2, n):\\n    a[pos - i] = a[pos - i + 1] + b[pos - i]\\nprint(*a)\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2247", "prompt": "def expectation_steps(n: int, edges: List[Tuple[int, int]]) -> float:\n    \"\"\"\n    Momiji has got a rooted tree, consisting of n nodes. The tree nodes are numbered by integers from 1 to n. The root has number 1. Momiji decided to play a game on this tree.\n    \n    The game consists of several steps. On each step, Momiji chooses one of the remaining tree nodes (let's denote it by v) and removes all the subtree nodes with the root in node v from the tree. Node v gets deleted as well. The game finishes when the tree has no nodes left. In other words, the game finishes after the step that chooses the node number 1.\n    \n    Each time Momiji chooses a new node uniformly among all the remaining nodes. Your task is to find the expectation of the number of steps in the described game.\n    \n    \n    -----Input-----\n    \n    The first line contains integer n (1 \u2264 n \u2264 10^5) \u2014 the number of nodes in the tree. The next n - 1 lines contain the tree edges. The i-th line contains integers a_{i}, b_{i} (1 \u2264 a_{i}, b_{i} \u2264 n;\u00a0a_{i} \u2260 b_{i}) \u2014 the numbers of the nodes that are connected by the i-th edge.\n    \n    It is guaranteed that the given graph is a tree.\n    \n    \n    -----Output-----\n    \n    Print a single real number \u2014 the expectation of the number of steps in the described game.\n    \n    The answer will be considered correct if the absolute or relative error doesn't exceed 10^{ - 6}.\n    \n    \n    -----Examples-----\n    Input\n    2\n    1 2\n    \n    Output\n    1.50000000000000000000\n    \n    Input\n    3\n    1 2\n    1 3\n    \n    Output\n    2.00000000000000000000\n    \n    \n    \n    -----Note-----\n    \n    In the first sample, there are two cases. One is directly remove the root and another is remove the root after one step. Thus the expected steps are: 1 \u00d7 (1 / 2) + 2 \u00d7 (1 / 2) = 1.5\n    \n    In the second sample, things get more complex. There are two cases that reduce to the first sample, and one case cleaned at once. Thus the expected steps are: 1 \u00d7 (1 / 3) + (1 + 1.5) \u00d7 (2 / 3) = (1 / 3) + (5 / 3) = 2\n    \"\"\"\n", "entry_point": "expectation_steps", "test": "\ndef check(candidate):\n    assert candidate(2, [(1, 2)]) == 1.50000000000000000000\n    assert candidate(3, [(1, 2), (1, 3)]) == 2.00000000000000000000\n    assert candidate(10, [(1, 2), (2, 3), (3, 4), (1, 5), (2, 6), (6, 7), (4, 8), (6, 9), (9, 10)]) == 3.81666666666666690000\n    assert candidate(6, [(1, 3), (2, 4), (5, 6), (3, 6), (5, 4)]) == 2.45000000000000020000\ncheck(expectation_steps)\n", "given_tests": ["assert expectation_steps(2, [(1, 2)]) == 1.50000000000000000000", "assert expectation_steps(3, [(1, 2), (1, 3)]) == 2.00000000000000000000"], "canonical_solution": "[\"# https://codeforces.com/problemset/problem/280/C\\nfrom collections import defaultdict, deque\\nimport sys\\n\\nnodes = int(sys.stdin.readline())\\nedges = defaultdict(list)\\nfor line in sys.stdin:\\n    a, b = line.split()\\n    a = int(a)\\n    b = int(b)\\n    edges[a].append(b)\\n    edges[b].append(a)\\nbfs = deque([(1, 1)])\\ndepths = {}\\nwhile bfs:\\n    nid, depth = bfs.popleft()\\n    if nid in depths:\\n        continue\\n    depths[nid] = depth\\n    for n2 in edges[nid]:\\n        bfs.append((n2, depth + 1))\\nprint(sum(1.0 / d for d in sorted(depths.values(), reverse=True)))\"]", "difficulty": "competition"}
{"task_id": "APPS/2123", "prompt": "def find_best_carrot(n: int, a: List[int]) -> List[int]:\n    \"\"\"\n    Oleg the bank client and Igor the analyst are arguing again. This time, they want to pick a gift as a present for their friend, ZS the coder. After a long thought, they decided that their friend loves to eat carrots the most and thus they want to pick the best carrot as their present.\n    \n    There are n carrots arranged in a line. The i-th carrot from the left has juiciness a_{i}. Oleg thinks ZS loves juicy carrots whereas Igor thinks that he hates juicy carrots. Thus, Oleg would like to maximize the juiciness of the carrot they choose while Igor would like to minimize the juiciness of the carrot they choose.\n    \n    To settle this issue, they decided to play a game again. Oleg and Igor take turns to play the game. In each turn, a player can choose a carrot from either end of the line, and eat it. The game ends when only one carrot remains. Oleg moves first. The last remaining carrot will be the carrot that they will give their friend, ZS.\n    \n    Oleg is a sneaky bank client. When Igor goes to a restroom, he performs k moves before the start of the game. Each move is the same as above (eat a carrot from either end of the line). After Igor returns, they start the game with Oleg still going first.\n    \n    Oleg wonders: for each k such that 0 \u2264 k \u2264 n - 1, what is the juiciness of the carrot they will give to ZS if he makes k extra moves beforehand and both players play optimally?\n    \n    \n    -----Input-----\n    \n    The first line of input contains a single integer n (1 \u2264 n \u2264 3\u00b710^5)\u00a0\u2014 the total number of carrots.\n    \n    The next line contains n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9). Here a_{i} denotes the juiciness of the i-th carrot from the left of the line.\n    \n    \n    -----Output-----\n    \n    Output n space-separated integers x_0, x_1, ..., x_{n} - 1. Here, x_{i} denotes the juiciness of the carrot the friends will present to ZS if k = i.\n    \n    \n    -----Examples-----\n    Input\n    4\n    1 2 3 5\n    \n    Output\n    3 3 5 5\n    \n    Input\n    5\n    1000000000 1000000000 1000000000 1000000000 1\n    \n    Output\n    1000000000 1000000000 1000000000 1000000000 1000000000\n    \n    \n    \n    -----Note-----\n    \n    For the first example,\n    \n    When k = 0, one possible optimal game is as follows: Oleg eats the carrot with juiciness 1. Igor eats the carrot with juiciness 5. Oleg eats the carrot with juiciness 2. The remaining carrot has juiciness 3.\n    \n    When k = 1, one possible optimal play is as follows: Oleg eats the carrot with juiciness 1 beforehand. Oleg eats the carrot with juiciness 2. Igor eats the carrot with juiciness 5. The remaining carrot has juiciness 3.\n    \n    When k = 2, one possible optimal play is as follows: Oleg eats the carrot with juiciness 1 beforehand. Oleg eats the carrot with juiciness 2 beforehand. Oleg eats the carrot with juiciness 3. The remaining carrot has juiciness 5.\n    \n    When k = 3, one possible optimal play is as follows: Oleg eats the carrot with juiciness 1 beforehand. Oleg eats the carrot with juiciness 2 beforehand. Oleg eats the carrot with juiciness 3 beforehand. The remaining carrot has juiciness 5.\n    \n    Thus, the answer is 3, 3, 5, 5.\n    \n    For the second sample, Oleg can always eat the carrot with juiciness 1 since he always moves first. So, the remaining carrot will always have juiciness 1000000000.\n    \"\"\"\n", "entry_point": "find_best_carrot", "test": "\ndef check(candidate):\n    assert candidate(4, [1, 2, 3, 5]) == [3, 3, 5, 5]\n    assert candidate(5, [1000000000, 1000000000, 1000000000, 1000000000, 1]) == [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]\n    assert candidate(4, [1, 12, 3, 5]) == [12, 3, 12, 12]\n    assert candidate(5, [1, 3, 2, 2, 4]) == [2, 3, 2, 4, 4]\n    assert candidate(5, [1, 2, 3, 2, 1]) == [2, 3, 2, 3, 3]\n    assert candidate(1, [1941283]) == [1941283]\n    assert candidate(3, [2, 8, 2]) == [2, 8, 8]\n    assert candidate(3, [6, 4, 6]) == [4, 6, 6]\n    assert candidate(3, [5, 8, 7]) == [7, 8, 8]\n    assert candidate(40, [2, 2, 88, 88, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 7, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 7, 88, 88, 88, 88, 88, 88, 88, 88]\n    assert candidate(10, [1, 10, 1, 1, 1, 1, 1, 1, 1, 1]) == [1, 1, 1, 1, 1, 1, 10, 1, 10, 10]\ncheck(find_best_carrot)\n", "given_tests": ["assert find_best_carrot(4, [1, 2, 3, 5]) == [3, 3, 5, 5]", "assert find_best_carrot(5, [1000000000, 1000000000, 1000000000, 1000000000, 1]) == [1000000000, 1000000000, 1000000000, 1000000000, 1000000000]"], "canonical_solution": "[\"def evens(A):\\n    n = len(A)\\n    l = n//2-1; r = n//2\\n    if len(A)%2 == 1: l+= 1\\n    ans = [max(A[l], A[r])]\\n    while r < n-1:\\n        l-= 1; r+= 1\\n        ans.append(max(ans[-1], A[l], A[r]))\\n    return ans\\n\\ndef interleave(A, B):\\n    q = []\\n    for i in range(len(B)): q+= [A[i], B[i]]\\n    if len(A) != len(B): q.append(A[-1])\\n    return q\\n\\nn = int(input())\\nA = list(map(int,input().split()))\\nM = [min(A[i],A[i+1]) for i in range(n-1)]\\nansA = evens(A)\\nansM = evens(M) if n>1 else []\\nif n%2 == 0: print(*interleave(ansA, ansM[1:]), max(A))\\nelse: print(*interleave(ansM, ansA[1:]), max(A))\"]", "difficulty": "competition"}
{"task_id": "APPS/2168", "prompt": "def calculate_shortest_paths_sum(n: int, matrix: List[List[int]], x: List[int]) -> List[int]:\n    \"\"\"\n    Greg has a weighed directed graph, consisting of n vertices. In this graph any pair of distinct vertices has an edge between them in both directions. Greg loves playing with the graph and now he has invented a new game:  The game consists of n steps.  On the i-th step Greg removes vertex number x_{i} from the graph. As Greg removes a vertex, he also removes all the edges that go in and out of this vertex.  Before executing each step, Greg wants to know the sum of lengths of the shortest paths between all pairs of the remaining vertices. The shortest path can go through any remaining vertex. In other words, if we assume that d(i, v, u) is the shortest path between vertices v and u in the graph that formed before deleting vertex x_{i}, then Greg wants to know the value of the following sum: $\\sum_{v, u, v \\neq u} d(i, v, u)$.\n    \n    Help Greg, print the value of the required sum before each step.\n    \n    \n    -----Input-----\n    \n    The first line contains integer n (1 \u2264 n \u2264 500) \u2014 the number of vertices in the graph.\n    \n    Next n lines contain n integers each \u2014 the graph adjacency matrix: the j-th number in the i-th line a_{ij} (1 \u2264 a_{ij} \u2264 10^5, a_{ii} = 0) represents the weight of the edge that goes from vertex i to vertex j.\n    \n    The next line contains n distinct integers: x_1, x_2, ..., x_{n} (1 \u2264 x_{i} \u2264 n) \u2014 the vertices that Greg deletes.\n    \n    \n    -----Output-----\n    \n    Print n integers \u2014 the i-th number equals the required sum before the i-th step.\n    \n    Please, do not use the %lld specifier to read or write 64-bit integers in C++. It is preferred to use the cin, cout streams of the %I64d specifier.\n    \n    \n    -----Examples-----\n    Input\n    1\n    0\n    1\n    \n    Output\n    0\n    Input\n    2\n    0 5\n    4 0\n    1 2\n    \n    Output\n    9 0\n    Input\n    4\n    0 3 1 1\n    6 0 400 1\n    2 4 0 1\n    1 1 1 0\n    4 1 2 3\n    \n    Output\n    17 23 404 0\n    \"\"\"\n", "entry_point": "calculate_shortest_paths_sum", "test": "\ndef check(candidate):\n    assert candidate(1, [[0]], [1]) == [0]\n    assert candidate(2, [[0, 5], [4, 0]], [1, 2]) == [9, 0]\n    assert candidate(4, [[0, 3, 1, 1], [6, 0, 400, 1], [2, 4, 0, 1], [1, 1, 1, 0]], [4, 1, 2, 3]) == [17, 23, 404, 0]\n    assert candidate(4, [[0, 57148, 51001, 13357], [71125, 0, 98369, 67226], [49388, 90852, 0, 66291], [39573, 38165, 97007, 0]], [2, 3, 1, 4]) == [723897, 306638, 52930, 0]\n    assert candidate(5, [[0, 27799, 15529, 16434, 44291], [47134, 0, 90227, 26873, 52252], [41605, 21269, 0, 9135, 55784], [70744, 17563, 79061, 0, 73981], [70529, 35681, 91073, 52031, 0]], [5, 2, 3, 1, 4]) == [896203, 429762, 232508, 87178, 0]\n    assert candidate(6, [[0, 72137, 71041, 29217, 96749, 46417], [40199, 0, 55907, 57677, 68590, 78796], [83463, 50721, 0, 30963, 31779, 28646], [94529, 47831, 98222, 0, 61665, 73941], [24397, 66286, 2971, 81613, 0, 52501], [26285, 3381, 51438, 45360, 20160, 0]], [6, 3, 2, 4, 5, 1]) == [1321441, 1030477, 698557, 345837, 121146, 0]\n    assert candidate(7, [[0, 34385, 31901, 51111, 10191, 14089, 95685], [11396, 0, 8701, 33277, 1481, 517, 46253], [51313, 2255, 0, 5948, 66085, 37201, 65310], [21105, 60985, 10748, 0, 89271, 42883, 77345], [34686, 29401, 73565, 47795, 0, 13793, 66997], [70279, 49576, 62900, 40002, 70943, 0, 89601], [65045, 1681, 28239, 12023, 40414, 89585, 0]], [3, 5, 7, 6, 1, 2, 4]) == [1108867, 1016339, 729930, 407114, 206764, 94262, 0]\n    assert candidate(8, [[0, 74961, 47889, 4733, 72876, 21399, 63105, 48239], [15623, 0, 9680, 89133, 57989, 63401, 26001, 29608], [42369, 82390, 0, 32866, 46171, 11871, 67489, 54070], [23425, 80027, 18270, 0, 28105, 42657, 40876, 29267], [78793, 18701, 7655, 94798, 0, 88885, 71424, 86914], [44835, 76636, 11553, 46031, 13617, 0, 16971, 51915], [33037, 53719, 43116, 52806, 56897, 71241, 0, 11629], [2119, 62373, 93265, 69513, 5770, 90751, 36619, 0]], [3, 7, 6, 5, 8, 1, 2, 4]) == [1450303, 1188349, 900316, 531281, 383344, 219125, 169160, 0]\n    assert candidate(9, [[0, 85236, 27579, 82251, 69479, 24737, 87917, 15149, 52311], [59640, 0, 74687, 34711, 3685, 30121, 4961, 7552, 83399], [33376, 68733, 0, 81357, 18042, 74297, 15466, 29476, 5865], [7493, 5601, 3321, 0, 20263, 55901, 45756, 55361, 87633], [26751, 17161, 76681, 40376, 0, 39745, 50717, 56887, 90055], [18885, 76353, 47089, 43601, 21561, 0, 60571, 33551, 53753], [74595, 877, 71853, 93156, 97499, 70876, 0, 22713, 63961], [67725, 25309, 56358, 92376, 40641, 35433, 39781, 0, 97482], [81818, 12561, 85961, 81445, 3941, 76799, 31701, 43725, 0]], [6, 2, 9, 3, 5, 7, 1, 4, 8]) == [2106523, 1533575, 1645151, 1255230, 946667, 618567, 287636, 147737, 0]\ncheck(calculate_shortest_paths_sum)\n", "given_tests": ["assert calculate_shortest_paths_sum(1, [[0]], [1]) == [0]", "assert calculate_shortest_paths_sum(2, [[0, 5], [4, 0]], [1, 2]) == [9, 0]", "assert calculate_shortest_paths_sum(4, [[0, 3, 1, 1], [6, 0, 400, 1], [2, 4, 0, 1], [1, 1, 1, 0]], [4, 1, 2, 3]) == [17, 23, 404, 0]"], "canonical_solution": "[\"import sys\\nfrom array import array  # noqa: F401\\n\\nn = int(input())\\nmatrix = [array('i', list(map(int, input().split()))) for _ in range(n)]\\naa = tuple([int(x) - 1 for x in input().split()])\\nans = [''] * n\\n\\nfor i in range(n-1, -1, -1):\\n    x = aa[i]\\n\\n    for a in range(n):\\n        for b in range(n):\\n            if matrix[a][b] > matrix[a][x] + matrix[x][b]:\\n                matrix[a][b] = matrix[a][x] + matrix[x][b]\\n\\n    val, overflow = 0, 0\\n    for a in aa[i:]:\\n        for b in aa[i:]:\\n            val += matrix[a][b]\\n        if val > 10**9:\\n            overflow += 1\\n            val -= 10**9\\n\\n    ans[i] = str(10**9 * overflow + val)\\n\\nprint(' '.join(ans))\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2159", "prompt": "def find_max_interest_value(n: int, T: int, tasks: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Polycarp is making a quest for his friends. He has already made n tasks, for each task the boy evaluated how interesting it is as an integer q_{i}, and the time t_{i} in minutes needed to complete the task.\n    \n    An interesting feature of his quest is: each participant should get the task that is best suited for him, depending on his preferences. The task is chosen based on an interactive quiz that consists of some questions. The player should answer these questions with \"yes\" or \"no\". Depending on the answer to the question, the participant either moves to another question or goes to one of the tasks that are in the quest. In other words, the quest is a binary tree, its nodes contain questions and its leaves contain tasks.\n    \n    We know that answering any of the questions that are asked before getting a task takes exactly one minute from the quest player. Polycarp knows that his friends are busy people and they can't participate in the quest for more than T minutes. Polycarp wants to choose some of the n tasks he made, invent the corresponding set of questions for them and use them to form an interactive quiz as a binary tree so that no matter how the player answers quiz questions, he spends at most T minutes on completing the whole quest (that is, answering all the questions and completing the task). Specifically, the quest can contain zero questions and go straight to the task. Each task can only be used once (i.e., the people who give different answers to questions should get different tasks).\n    \n    Polycarp wants the total \"interest\" value of the tasks involved in the quest to be as large as possible. Help him determine the maximum possible total interest value of the task considering that the quest should be completed in T minutes at any variant of answering questions.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers n and T (1 \u2264 n \u2264 1000, 1 \u2264 T \u2264 100) \u2014 the number of tasks made by Polycarp and the maximum time a quest player should fit into.\n    \n    Next n lines contain two integers t_{i}, q_{i} (1 \u2264 t_{i} \u2264 T, 1 \u2264 q_{i} \u2264 1000) each \u2014 the time in minutes needed to complete the i-th task and its interest value.\n    \n    \n    -----Output-----\n    \n    Print a single integer \u2014 the maximum possible total interest value of all the tasks in the quest.\n    \n    \n    -----Examples-----\n    Input\n    5 5\n    1 1\n    1 1\n    2 2\n    3 3\n    4 4\n    \n    Output\n    11\n    \n    Input\n    5 5\n    4 1\n    4 2\n    4 3\n    4 4\n    4 5\n    \n    Output\n    9\n    \n    Input\n    2 2\n    1 1\n    2 10\n    \n    Output\n    10\n    \n    \n    \n    -----Note-----\n    \n    In the first sample test all the five tasks can be complemented with four questions and joined into one quest.\n    \n    In the second sample test it is impossible to use all the five tasks, but you can take two of them, the most interesting ones.\n    \n    In the third sample test the optimal strategy is to include only the second task into the quest.\n    \n    Here is the picture that illustrates the answers to the sample tests. The blue circles represent the questions, the two arrows that go from every circle represent where a person goes depending on his answer to that question. The tasks are the red ovals. [Image]\n    \"\"\"\n", "entry_point": "find_max_interest_value", "test": "\ndef check(candidate):\n    assert candidate(5, 5, [(1, 1), (1, 1), (2, 2), (3, 3), (4, 4)]) == 11\n    assert candidate(5, 5, [(4, 1), (4, 2), (4, 3), (4, 4), (4, 5)]) == 9\n    assert candidate(2, 2, [(1, 1), (2, 10)]) == 10\n    assert candidate(10, 1, [(1, 732), (1, 649), (1, 821), (1, 756), (1, 377), (1, 216), (1, 733), (1, 420), (1, 857), (1, 193)]) == 857\n    assert candidate(26, 5, [(2, 377), (3, 103), (1, 547), (2, 700), (3, 616), (5, 363), (2, 316), (5, 260), (3, 385), (2, 460), (4, 206), (4, 201), (3, 236), (1, 207), (1, 400), (2, 382), (2, 365), (1, 633), (1, 775), (4, 880), (1, 808), (1, 871), (3, 518), (1, 805), (3, 771), (3, 598)]) == 6977\n    assert candidate(42, 4, [(1, 897), (2, 883), (1, 766), (1, 169), (3, 671), (3, 751), (2, 204), (2, 550), (3, 873), (2, 348), (2, 286), (1, 413), (1, 551), (4, 821), (2, 573), (1, 423), (4, 59), (3, 881), (2, 450), (1, 206), (3, 181), (3, 218), (3, 870), (2, 906), (1, 695), (1, 162), (3, 370), (3, 580), (2, 874), (2, 864), (3, 47), (3, 126), (2, 494), (4, 21), (3, 791), (4, 520), (4, 917), (2, 244), (4, 74), (3, 348), (4, 416), (3, 581)]) == 4698\n    assert candidate(70, 4, [(1, 83), (3, 923), (2, 627), (4, 765), (3, 74), (4, 797), (4, 459), (2, 682), (1, 840), (2, 414), (4, 797), (3, 832), (3, 203), (2, 939), (4, 694), (1, 157), (3, 544), (1, 169), (3, 100), (4, 69), (1, 851), (3, 605), (4, 562), (1, 718), (3, 74), (3, 740), (2, 655), (2, 804), (2, 218), (4, 186), (4, 999), (3, 989), (2, 407), (4, 702), (2, 15), (1, 509), (4, 376), (4, 260), (1, 533), (2, 514), (3, 520), (4, 737), (2, 877), (2, 383), (1, 556), (3, 745), (2, 659), (2, 636), (2, 443), (4, 819), (2, 382), (4, 660), (1, 376), (2, 410), (3, 379), (4, 996), (3, 944), (4, 949), (2, 485), (3, 434), (3, 786), (3, 367), (4, 403), (3, 330), (3, 625), (2, 302), (3, 673), (3, 794), (3, 411), (1, 256)]) == 4946\n    assert candidate(17, 1, [(1, 632), (1, 996), (1, 665), (1, 432), (1, 565), (1, 350), (1, 857), (1, 183), (1, 982), (1, 910), (1, 938), (1, 155), (1, 176), (1, 168), (1, 419), (1, 814), (1, 487)]) == 996\n    assert candidate(10, 9, [(1, 518), (3, 971), (5, 862), (2, 71), (8, 138), (4, 121), (6, 967), (1, 518), (9, 754), (7, 607)]) == 4773\n    assert candidate(1, 2, [(1, 1)]) == 1\ncheck(find_max_interest_value)\n", "given_tests": ["assert find_max_interest_value(5, 5, [(1, 1), (1, 1), (2, 2), (3, 3), (4, 4)]) == 11", "assert find_max_interest_value(5, 5, [(4, 1), (4, 2), (4, 3), (4, 4), (4, 5)]) == 9", "assert find_max_interest_value(2, 2, [(1, 1), (2, 10)]) == 10"], "canonical_solution": "[\"from collections import defaultdict\\n\\n\\ndef __starting_point():\\n    n, T = [int(_) for _ in input().split()]\\n    data = defaultdict(list)\\n    for i in range(n):\\n        t, q = [int(_) for _ in input().split()]\\n        data[T - t].append(q)\\n\\n    prev_level = []\\n    for level_id in range(1, T + 1):\\n        level = sorted(data[T - level_id] + prev_level, reverse=True) \\n        if T - level_id <= 10:\\n            max_size = 2 ** (T - level_id)\\n            level = level[:max_size]\\n        if len(level) % 2 == 1:\\n            level.append(0)\\n        prev_level = [\\n            level[i] + level[i + 1]\\n            for i in range(0, len(level), 2)\\n        ]\\n    print(prev_level[0])\\n\\n__starting_point()\"]", "difficulty": "competition"}
{"task_id": "APPS/2199", "prompt": "def calculate_max_happiness(n: int, k: int, roads: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Writing light novels is the most important thing in Linova's life. Last night, Linova dreamed about a fantastic kingdom. She began to write a light novel for the kingdom as soon as she woke up, and of course, she is the queen of it.\n    \n    [Image]\n    \n    There are $n$ cities and $n-1$ two-way roads connecting pairs of cities in the kingdom. From any city, you can reach any other city by walking through some roads. The cities are numbered from $1$ to $n$, and the city $1$ is the capital of the kingdom. So, the kingdom has a tree structure.\n    \n    As the queen, Linova plans to choose exactly $k$ cities developing industry, while the other cities will develop tourism. The capital also can be either industrial or tourism city.\n    \n    A meeting is held in the capital once a year. To attend the meeting, each industry city sends an envoy. All envoys will follow the shortest path from the departure city to the capital (which is unique).\n    \n    Traveling in tourism cities is pleasant. For each envoy, his happiness is equal to the number of tourism cities on his path.\n    \n    In order to be a queen loved by people, Linova wants to choose $k$ cities which can maximize the sum of happinesses of all envoys. Can you calculate the maximum sum for her?\n    \n    \n    -----Input-----\n    \n    The first line contains two integers $n$ and $k$ ($2\\le n\\le 2 \\cdot 10^5$, $1\\le k< n$) \u00a0\u2014 the number of cities and industry cities respectively.\n    \n    Each of the next $n-1$ lines contains two integers $u$ and $v$ ($1\\le u,v\\le n$), denoting there is a road connecting city $u$ and city $v$.\n    \n    It is guaranteed that from any city, you can reach any other city by the roads.\n    \n    \n    -----Output-----\n    \n    Print the only line containing a single integer \u00a0\u2014 the maximum possible sum of happinesses of all envoys.\n    \n    \n    -----Examples-----\n    Input\n    7 4\n    1 2\n    1 3\n    1 4\n    3 5\n    3 6\n    4 7\n    \n    Output\n    7\n    Input\n    4 1\n    1 2\n    1 3\n    2 4\n    \n    Output\n    2\n    Input\n    8 5\n    7 5\n    1 7\n    6 1\n    3 7\n    8 3\n    2 1\n    4 5\n    \n    Output\n    9\n    \n    \n    -----Note-----\n    \n    [Image]\n    \n    In the first example, Linova can choose cities $2$, $5$, $6$, $7$ to develop industry, then the happiness of the envoy from city $2$ is $1$, the happiness of envoys from cities $5$, $6$, $7$ is $2$. The sum of happinesses is $7$, and it can be proved to be the maximum one.\n    \n    [Image]\n    \n    In the second example, choosing cities $3$, $4$ developing industry can reach a sum of $3$, but remember that Linova plans to choose exactly $k$ cities developing industry, then the maximum sum is $2$.\n    \"\"\"\n", "entry_point": "calculate_max_happiness", "test": "\ndef check(candidate):\n    assert candidate(7, 4, [(1, 2), (1, 3), (1, 4), (3, 5), (3, 6), (4, 7)]) == 7\n    assert candidate(4, 1, [(1, 2), (1, 3), (2, 4)]) == 2\n    assert candidate(8, 5, [(7, 5), (1, 7), (6, 1), (3, 7), (8, 3), (2, 1), (4, 5)]) == 9\n    assert candidate(2, 1, [(1, 2)]) == 1\n    assert candidate(20, 7, [(9, 7), (3, 7), (15, 9), (1, 3), (11, 9), (18, 7), (17, 18), (20, 1), (4, 11), (2, 11), (12, 18), (8, 18), (13, 2), (19, 2), (10, 9), (6, 13), (5, 8), (14, 1), (16, 13)]) == 38\n    assert candidate(3, 2, [(1, 2), (1, 3)]) == 2\n    assert candidate(3, 1, [(1, 2), (2, 3)]) == 2\ncheck(calculate_max_happiness)\n", "given_tests": ["assert calculate_max_happiness(7, 4, [(1, 2), (1, 3), (1, 4), (3, 5), (3, 6), (4, 7)]) == 7", "assert calculate_max_happiness(4, 1, [(1, 2), (1, 3), (2, 4)]) == 2", "assert calculate_max_happiness(8, 5, [(7, 5), (1, 7), (6, 1), (3, 7), (8, 3), (2, 1), (4, 5)]) == 9"], "canonical_solution": "[\"import sys\\ninput = sys.stdin.readline\\n\\nn, k = list(map(int, input().split()))\\n\\nbegin = [-1] * n\\nend = [-1] * n\\nhurt = [-1] * n\\n\\nadj = [[] for i in range(n)]\\nfor _ in range(n-1):\\n    u ,v = list(map(int, input().split()))\\n    adj[u-1].append(v-1)\\n    adj[v-1].append(u-1)\\n\\nhurt[0] = 1\\nbegin[0] = 0\\nstack = [0]\\ncurr = 1\\nwhile stack:\\n    nex = stack[-1]\\n    if adj[nex]:\\n        v = adj[nex].pop()\\n        if begin[v] == -1:\\n            begin[v] = curr\\n            curr += 1\\n            stack.append(v)\\n            hurt[v] = len(stack)\\n    else:\\n        end[nex] = curr\\n        stack.pop()\\n\\ndesc = [end[i] - begin[i]-hurt[i] for i in range(n)]\\ndesc.sort(reverse = True)\\nout = 0\\nfor i in range(n - k):\\n    out += desc[i]\\nprint(out)\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2083", "prompt": "def find_suitable_array(n: int, m: int, operations: List[Tuple[int, int, int, int]]) -> Tuple[str, List[int]]:\n    \"\"\"\n    Levko loves array a_1, a_2, ... , a_{n}, consisting of integers, very much. That is why Levko is playing with array a, performing all sorts of operations with it. Each operation Levko performs is of one of two types:\n    \n    Increase all elements from l_{i} to r_{i} by d_{i}. In other words, perform assignments a_{j} = a_{j} + d_{i} for all j that meet the inequation l_{i} \u2264 j \u2264 r_{i}.  Find the maximum of elements from l_{i} to r_{i}. That is, calculate the value $m_{i} = \\operatorname{max}_{j = l_{i}}^{r_{i}} a_{j}$.\n    \n    Sadly, Levko has recently lost his array. Fortunately, Levko has records of all operations he has performed on array a. Help Levko, given the operation records, find at least one suitable array. The results of all operations for the given array must coincide with the record results. Levko clearly remembers that all numbers in his array didn't exceed 10^9 in their absolute value, so he asks you to find such an array.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers n and m (1 \u2264 n, m \u2264 5000) \u2014 the size of the array and the number of operations in Levko's records, correspondingly.\n    \n    Next m lines describe the operations, the i-th line describes the i-th operation. The first integer in the i-th line is integer t_{i} (1 \u2264 t_{i} \u2264 2) that describes the operation type. If t_{i} = 1, then it is followed by three integers l_{i}, r_{i} and d_{i} (1 \u2264 l_{i} \u2264 r_{i} \u2264 n,  - 10^4 \u2264 d_{i} \u2264 10^4) \u2014 the description of the operation of the first type. If t_{i} = 2, then it is followed by three integers l_{i}, r_{i} and m_{i} (1 \u2264 l_{i} \u2264 r_{i} \u2264 n,  - 5\u00b710^7 \u2264 m_{i} \u2264 5\u00b710^7) \u2014 the description of the operation of the second type.\n    \n    The operations are given in the order Levko performed them on his array.\n    \n    \n    -----Output-----\n    \n    In the first line print \"YES\" (without the quotes), if the solution exists and \"NO\" (without the quotes) otherwise.\n    \n    If the solution exists, then on the second line print n integers a_1, a_2, ... , a_{n} (|a_{i}| \u2264 10^9) \u2014 the recovered array.\n    \n    \n    -----Examples-----\n    Input\n    4 5\n    1 2 3 1\n    2 1 2 8\n    2 3 4 7\n    1 1 3 3\n    2 3 4 8\n    \n    Output\n    YES\n    4 7 4 7\n    Input\n    4 5\n    1 2 3 1\n    2 1 2 8\n    2 3 4 7\n    1 1 3 3\n    2 3 4 13\n    \n    Output\n    NO\n    \"\"\"\n", "entry_point": "find_suitable_array", "test": "\ndef check(candidate):\n    assert candidate(4, 5, [(1, 2, 3, 1), (2, 1, 2, 8), (2, 3, 4, 7), (1, 1, 3, 3), (2, 3, 4, 8)]) == ('YES', [4, 7, 4, 7])\n    assert candidate(4, 5, [(1, 2, 3, 1), (2, 1, 2, 8), (2, 3, 4, 7), (1, 1, 3, 3), (2, 3, 4, 13)]) == 'NO'\n    assert candidate(1, 4, [(1, 1, 1, 2), (2, 1, 1, 6), (1, 1, 1, 1), (2, 1, 1, 7)]) == ('YES', [4])\n    assert candidate(1, 4, [(1, 1, 1, 2), (2, 1, 1, 6), (1, 1, 1, 1), (2, 1, 1, 8)]) == 'NO'\n    assert candidate(1, 2, [(2, 1, 1, 8), (2, 1, 1, 7)]) == 'NO'\n    assert candidate(1, 2, [(2, 1, 1, 10), (2, 1, 1, 5)]) == 'NO'\n    assert candidate(2, 2, [(2, 1, 1, 10), (2, 1, 2, 5)]) == 'NO'\n    assert candidate(1, 2, [(2, 1, 1, 5), (2, 1, 1, 1)]) == 'NO'\n    assert candidate(2, 2, [(2, 1, 2, 8), (2, 1, 2, 7)]) == 'NO'\n    assert candidate(1, 2, [(2, 1, 1, 1), (2, 1, 1, 0)]) == 'NO'\n    assert candidate(1, 1, [(2, 1, 1, 40000000)]) == ('YES', [40000000])\n    assert candidate(1, 2, [(2, 1, 1, 2), (2, 1, 1, 1)]) == 'NO'\n    assert candidate(3, 2, [(2, 1, 2, 100), (2, 1, 3, 50)]) == 'NO'\ncheck(find_suitable_array)\n", "given_tests": ["assert find_suitable_array(4, 5, [(1, 2, 3, 1), (2, 1, 2, 8), (2, 3, 4, 7), (1, 1, 3, 3), (2, 3, 4, 8)]) == ('YES', [4, 7, 4, 7])", "assert find_suitable_array(4, 5, [(1, 2, 3, 1), (2, 1, 2, 8), (2, 3, 4, 7), (1, 1, 3, 3), (2, 3, 4, 13)]) == 'NO'"], "canonical_solution": "[\"n, m = map(int, input().split())\\na = [10**9 for _ in range(n)]\\nextra = [0 for _ in range(n)]\\nquery = list()\\nfor _ in range(m):\\n     t, l, r, x = map(int, input().split())\\n     l -= 1\\n     r -= 1\\n     query.append((t, l, r, x))\\n     if t == 1:\\n          for j in range(l, r + 1):\\n               extra[j] += x\\n     else:\\n          for j in range(l, r + 1):\\n               a[j] = min(a[j], x - extra[j])\\nextra = a.copy()\\nfor t, l, r, x in query:\\n     if t == 1:\\n          for j in range(l, r + 1):\\n               a[j] += x\\n     else:\\n          val = -10**9\\n          for j in range(l, r + 1):\\n               val = max(val, a[j])\\n          if not val == x:\\n               print('NO')\\n               return\\n\\nprint('YES')\\nfor x in extra:\\n     print(x, end=' ')\\n          \"]", "difficulty": "competition"}
{"task_id": "APPS/2178", "prompt": "def calculate_inversions(n: int, m: int, permutation: List[int], operations: List[Tuple[int, int]]) -> float:\n    \"\"\"\n    The Little Elephant loves permutations of integers from 1 to n very much. But most of all he loves sorting them. To sort a permutation, the Little Elephant repeatedly swaps some elements. As a result, he must receive a permutation 1, 2, 3, ..., n.\n    \n    This time the Little Elephant has permutation p_1, p_2, ..., p_{n}. Its sorting program needs to make exactly m moves, during the i-th move it swaps elements that are at that moment located at the a_{i}-th and the b_{i}-th positions. But the Little Elephant's sorting program happened to break down and now on every step it can equiprobably either do nothing or swap the required elements.\n    \n    Now the Little Elephant doesn't even hope that the program will sort the permutation, but he still wonders: if he runs the program and gets some permutation, how much will the result of sorting resemble the sorted one? For that help the Little Elephant find the mathematical expectation of the number of permutation inversions after all moves of the program are completed.\n    \n    We'll call a pair of integers i, j (1 \u2264 i < j \u2264 n) an inversion in permutatuon p_1, p_2, ..., p_{n}, if the following inequality holds: p_{i} > p_{j}.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers n and m (1 \u2264 n, m \u2264 1000, n > 1) \u2014 the permutation size and the number of moves. The second line contains n distinct integers, not exceeding n \u2014 the initial permutation. Next m lines each contain two integers: the i-th line contains integers a_{i} and b_{i} (1 \u2264 a_{i}, b_{i} \u2264 n, a_{i} \u2260 b_{i}) \u2014 the positions of elements that were changed during the i-th move.\n    \n    \n    -----Output-----\n    \n    In the only line print a single real number \u2014 the answer to the problem. The answer will be considered correct if its relative or absolute error does not exceed 10^{ - 6}.\n    \n    \n    -----Examples-----\n    Input\n    2 1\n    1 2\n    1 2\n    \n    Output\n    0.500000000\n    \n    Input\n    4 3\n    1 3 2 4\n    1 2\n    2 3\n    1 4\n    \n    Output\n    3.000000000\n    \"\"\"\n", "entry_point": "calculate_inversions", "test": "\ndef check(candidate):\n    assert candidate(2, 1, [1, 2], [(1, 2)]) == 0.500000000\n    assert candidate(4, 3, [1, 3, 2, 4], [(1, 2), (2, 3), (1, 4)]) == 3.000000000\n    assert candidate(7, 4, [7, 6, 4, 2, 1, 5, 3], [(1, 3), (2, 1), (7, 2), (3, 5)]) == 11.250000000\n    assert candidate(10, 1, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10], [(1, 10)]) == 8.500000000\n    assert candidate(9, 20, [9, 8, 7, 6, 5, 4, 3, 2, 1], [(4, 6), (9, 4), (5, 9), (6, 8), (1, 9), (5, 8), (6, 9), (7, 3), (1, 9), (8, 3), (4, 5), (9, 6), (3, 8), (4, 1), (1, 2), (3, 2), (4, 9), (6, 7), (7, 5), (9, 6)]) == 20.105407715\n    assert candidate(20, 7, [3, 17, 7, 14, 11, 4, 1, 18, 20, 19, 13, 12, 5, 6, 15, 16, 9, 2, 8, 10], [(19, 13), (20, 6), (19, 11), (12, 3), (10, 19), (14, 10), (3, 16)]) == 102.250000000\n    assert candidate(100, 1, [78, 52, 95, 76, 96, 49, 53, 59, 77, 100, 64, 11, 9, 48, 15, 17, 44, 46, 21, 54, 39, 68, 43, 4, 32, 28, 73, 6, 16, 62, 72, 84, 65, 86, 98, 75, 33, 45, 25, 3, 91, 82, 2, 92, 63, 88, 7, 50, 97, 93, 14, 22, 20, 42, 60, 55, 80, 85, 29, 34, 56, 71, 83, 38, 26, 47, 90, 70, 51, 41, 40, 31, 37, 12, 35, 99, 67, 94, 1, 87, 57, 8, 61, 19, 23, 79, 36, 18, 66, 74, 5, 27, 81, 69, 24, 58, 13, 10, 89, 30], [(17, 41)]) == 2659.500000000\n    assert candidate(125, 8, [111, 69, 3, 82, 24, 38, 4, 39, 42, 22, 92, 6, 16, 10, 8, 45, 17, 91, 84, 53, 5, 46, 124, 47, 18, 57, 43, 73, 114, 102, 121, 105, 118, 95, 104, 98, 72, 20, 56, 60, 123, 80, 103, 70, 65, 107, 67, 112, 101, 108, 99, 49, 12, 94, 2, 68, 119, 109, 59, 40, 86, 116, 88, 63, 110, 14, 13, 120, 41, 64, 89, 71, 15, 35, 81, 51, 113, 90, 55, 122, 1, 75, 54, 33, 28, 7, 125, 9, 100, 115, 19, 58, 61, 83, 117, 52, 106, 87, 11, 50, 93, 32, 21, 96, 26, 78, 48, 79, 23, 36, 66, 27, 31, 62, 25, 77, 30, 74, 76, 44, 97, 85, 29, 34, 37], [(33, 17), (84, 103), (71, 33), (5, 43), (23, 15), (65, 34), (125, 58), (51, 69)]) == 3919.000000000\n    assert candidate(100, 2, [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 100], [(88, 90), (62, 77)]) == 16.000000000\ncheck(calculate_inversions)\n", "given_tests": ["assert calculate_inversions(2, 1, [1, 2], [(1, 2)]) == 0.500000000", "assert calculate_inversions(4, 3, [1, 3, 2, 4], [(1, 2), (2, 3), (1, 4)]) == 3.000000000"], "canonical_solution": "[\"inp = input().split(' ')\\nval=[];\\n\\ntotNums = int(inp[0]); totOpt = int(inp[1]);\\ninp = input().split(' '); #assert(len(inp) == totNums);\\nfor it in inp: val.append(int(it))\\n\\ndp = [[0.0 for _ in range(0,totNums)] for __ in range(0,totNums)]\\nfor i in range(0,totNums):\\n    for j in range(0,totNums):\\n        if val[i]>val[j]: dp[i][j] = 1.0\\n\\nwhile totOpt>0:\\n    totOpt -= 1\\n\\n    inp = input().split(' ')\\n    fr = int(inp[0])-1; to = int(inp[1])-1;\\n\\n    for i in range(0,totNums):\\n        if i!=fr and i!=to:\\n            dp[i][fr] = dp[i][to] = (dp[i][fr] + dp[i][to]) / 2;\\n            dp[fr][i] = dp[to][i] = (dp[fr][i] + dp[to][i]) / 2;\\n\\n    dp[fr][to] = dp[to][fr] = (dp[fr][to] + dp[to][fr]) / 2;\\n\\nans = 0.0\\nfor i in range(0,totNums):\\n    for j in range(i+1,totNums):\\n        ans += dp[i][j]\\n\\nprint('%.10f'%ans)\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2164", "prompt": "def find_unobtainable_residues(N: int, M: int, A: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    Everybody seems to think that the Martians are green, but it turns out they are metallic pink and fat. Ajs has two bags of distinct nonnegative integers. The bags are disjoint, and the union of the sets of numbers in the bags is $\\{0,1,\u2026,M-1\\}$, for some positive integer $M$. Ajs draws a number from the first bag and a number from the second bag, and then sums them modulo $M$.\n    \n    What are the residues modulo $M$ that Ajs cannot obtain with this action?\n    \n    \n    -----Input-----\n    \n    The first line contains two positive integer $N$ ($1 \\leq N \\leq 200\\,000$) and $M$ ($N+1 \\leq M \\leq 10^{9}$), denoting the number of the elements in the first bag and the modulus, respectively.\n    \n    The second line contains $N$ nonnegative integers $a_1,a_2,\\ldots,a_N$ ($0 \\leq a_1<a_2< \\ldots< a_N<M$), the contents of the first bag.\n    \n    \n    \n    \n    -----Output-----\n    \n    In the first line, output the cardinality $K$ of the set of residues modulo $M$ which Ajs cannot obtain.\n    \n    In the second line of the output, print $K$ space-separated integers greater or equal than zero and less than $M$, which represent the residues Ajs cannot obtain. The outputs should be sorted in increasing order of magnitude. If $K$=0, do not output the second line.\n    \n    \n    -----Examples-----\n    Input\n    2 5\n    3 4\n    \n    Output\n    1\n    2\n    \n    Input\n    4 1000000000\n    5 25 125 625\n    \n    Output\n    0\n    \n    Input\n    2 4\n    1 3\n    \n    Output\n    2\n    0 2\n    \n    \n    \n    -----Note-----\n    \n    In the first sample, the first bag and the second bag contain $\\{3,4\\}$ and $\\{0,1,2\\}$, respectively. Ajs can obtain every residue modulo $5$ except the residue $2$: $ 4+1 \\equiv 0, \\, 4+2 \\equiv 1, \\, 3+0 \\equiv 3, \\, 3+1 \\equiv 4 $ modulo $5$. One can check that there is no choice of elements from the first and the second bag which sum to $2$ modulo $5$.\n    \n    In the second sample, the contents of the first bag are $\\{5,25,125,625\\}$, while the second bag contains all other nonnegative integers with at most $9$ decimal digits. Every residue modulo $1\\,000\\,000\\,000$ can be obtained as a sum of an element in the first bag and an element in the second bag.\n    \"\"\"\n", "entry_point": "find_unobtainable_residues", "test": "\ndef check(candidate):\n    assert candidate(2, 5, [3, 4]) == (1, [2])\n    assert candidate(4, 1000000000, [5, 25, 125, 625]) == (0, [])\n    assert candidate(2, 4, [1, 3]) == (2, [0, 2])\n    assert candidate(1, 2, [1]) == (1, [0])\n    assert candidate(14, 34, [1, 2, 4, 7, 10, 12, 13, 18, 19, 21, 24, 27, 29, 30]) == (2, [14, 31])\n    assert candidate(36, 81, [4, 5, 7, 8, 13, 14, 16, 17, 22, 23, 25, 26, 31, 32, 34, 35, 40, 41, 43, 44, 49, 50, 52, 53, 58, 59, 61, 62, 67, 68, 70, 71, 76, 77, 79, 80]) == (9, [3, 12, 21, 30, 39, 48, 57, 66, 75])\n    assert candidate(9, 10, [1, 2, 3, 4, 5, 6, 7, 8, 9]) == (1, [0])\n    assert candidate(3, 100000011, [678, 500678, 1000678]) == (1, [1001356])\n    assert candidate(4, 20, [5, 6, 7, 16]) == (1, [12])\ncheck(find_unobtainable_residues)\n", "given_tests": ["assert find_unobtainable_residues(2, 5, [3, 4]) == (1, [2])", "assert find_unobtainable_residues(4, 1000000000, [5, 25, 125, 625]) == (0, [])", "assert find_unobtainable_residues(2, 4, [1, 3]) == (2, [0, 2])"], "canonical_solution": "[\"import sys\\ninput = sys.stdin.readline\\n\\ndef main():\\n    n, m = map(int, input().split())\\n    a = list(map(int, input().split())) + [0]*500000\\n    ans_S = 0\\n    a[n] = a[0] + m\\n    s = [0]*600600\\n    for i in range(n):\\n        s[i] = a[i + 1] - a[i]\\n    s[n] = -1\\n    for i in range(n):\\n        s[2*n - i] = s[i]\\n    for i in range(2*n + 1, 3*n + 1):\\n        s[i] = s[i - n]\\n    l, r = 0, 0\\n    z = [0]*600600\\n    for i in range(1, 3*n + 1):\\n        if i < r:\\n            z[i] = z[i - l]\\n        while i + z[i] <= 3*n and (s[i + z[i]] == s[z[i]]):\\n            z[i] += 1\\n        if i + z[i] > r:\\n            l = i\\n            r = i + z[i]\\n    ans = []\\n    for i in range(n + 1, 2*n + 1):\\n        if z[i] < n:\\n            continue\\n        ans_S += 1\\n        ans.append((a[0] + a[2*n - i + 1]) % m)\\n    ans.sort()\\n    print(ans_S)\\n    print(*ans)\\n    return\\n\\ndef __starting_point():\\n    main()\\n__starting_point()\"]", "difficulty": "competition"}
{"task_id": "APPS/2329", "prompt": "def count_subsequences(N: int, M: int, A: List[int], B: List[int]) -> int:\n    \"\"\"\n    You are given an array A, consisting of N integers and an array B, consisting of M integers.\n    The subsequence of A is the array that can be obtained by picking the elements at the arbitrary sorted set of positions from A.\n    Your task is to count the number of such subsequences C of A that:\n    \n    - C contains exactly M elements.\n    - The array (C+B) is non-decreasing. Here by + operation, we mean element-wise sum.\n    \n    For example, the array (4, 8, 5) plus the array (10, 20, 30) is (14, 28, 35).\n    \n    Formally, (C+B) is an array of size M such that (C+B)i = Ci + Bi.\n    \n    In case some subsequence appears more that once, you should counts it as many times as it appears.\n    \n    Formally, two subarrays of an array a, (ai_1, ai_2, ... ,ai_n) and (aj_1, aj_2, ... ,aj_m) will be considered different if either their lengths are different i.e. n != m or there exists an index k such that such that i_k  != j_k.\n    \n    Since the answer can be very large, we ask you to calculate it, modulo 109+7.\n    \n    -----Input-----\n    The first line of input contains a pair of space separated integers N and M, denoting the number of elements in the array A and the number of elements in the array B.\n    The second line contains N space-separated integers Ai, denoting the array A.\n    The third line contains M space-separated integers Bj, denoting the array B.\n    \n    -----Output-----\n    Output a single line containing the number of subsequences C as asked in the problem, modulo 109+7.\n    \n    -----Constraints-----\n    - 1 \u2264 Ai, Bi \u2264 109\n    - 1 \u2264 M \u2264 N\n    \n    -----Subtasks-----\n    - Subtask #1 (33 points): 1 \u2264 N \u2264 50, 1 \u2264 M \u2264 5\n    - Subtask #2 (33 points): 1 \u2264 N \u2264 500, 1 \u2264 M \u2264 50\n    - Subtask #3 (34 points): 1 \u2264 N \u2264 2000, 1 \u2264 M \u2264 1000\n    \n    -----Example-----\n    Input #1:\n    5 3\n    1 5 2 4 7\n    7 9 6\n    \n    Output #1:\n    4\n    \n    Input #2:\n    4 2\n    7 7 7 7\n    3 4\n    \n    Output #2:\n    6\n    \n    -----Explanation-----\n    Example case 1. The suitable subsequences are (1, 2, 7), (1, 4, 7), (5, 4, 7), (2, 4, 7).\n    Example case 2. The suitable subsequence is (7, 7), and it appears 6 times:\n    \n    - at indices (1, 2)\n    - at indices (1, 3)\n    - at indices (1, 4)\n    - at indices (2, 3)\n    - at indices (2, 4)\n    - at indices (3, 4)\n    \n    So, the answer is 6.\n    \"\"\"\n", "entry_point": "count_subsequences", "test": "\ndef check(candidate):\n    assert candidate(5, 3, [1, 5, 2, 4, 7], [7, 9, 6]) == 4\n    assert candidate(4, 2, [7, 7, 7, 7], [3, 4]) == 6\ncheck(count_subsequences)\n", "given_tests": ["assert count_subsequences(5, 3, [1, 5, 2, 4, 7], [7, 9, 6]) == 4", "assert count_subsequences(4, 2, [7, 7, 7, 7], [3, 4]) == 6"], "canonical_solution": "[\"mod =(10**9)+7\\nn,m = list(map(int,input().split()))\\na = [int(i) for i in input().split()]\\nb = [int(i) for i in input().split()]\\ndp = []\\nfor i in range(n):\\n    dp += [[0]*m]\\ndp[-1][-1]=1\\nfor i in range(n-2,-1,-1):\\n    dp[i][-1]=1\\n    for j in range(m-1):\\n        x = (a[i]+b[j])-(b[j+1])\\n        temp = 0\\n        for k in range(i+1,n):\\n            if(a[k]>=x):\\n                temp += dp[k][j+1]\\n        dp[i][j]=temp\\nans = 0\\nfor i in range(n):\\n    ans += dp[i][0]\\nprint(ans%mod)\\n        \\n\", \"n,m = list(map(int,input().split()))\\na = [int(i) for i in input().split()]\\nb = [int(i) for i in input().split()]\\ndp = []\\nfor i in range(n):\\n    dp += [[0]*m]\\ndp[-1][-1]=1\\nfor i in range(n-2,-1,-1):\\n    dp[i][-1]=1\\n    for j in range(m-1):\\n        x = (a[i]+b[j])-(b[j+1])\\n        temp = 0\\n        for k in range(i+1,n):\\n            if(a[k]>=x):\\n                temp += dp[k][j+1]\\n        dp[i][j]=temp\\nans = 0\\nfor i in range(n):\\n    ans += dp[i][0]\\nprint(ans)\\n        \\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2197", "prompt": "def find_palindrome(A: str) -> str:\n    \"\"\"\n    You are given a string A. Find a string B, where B is a palindrome and A is a subsequence of B.\n    \n    A subsequence of a string is a string that can be derived from it by deleting some (not necessarily consecutive) characters without changing the order of the remaining characters. For example, \"cotst\" is a subsequence of \"contest\".\n    \n    A palindrome is a string that reads the same forward or backward.\n    \n    The length of string B should be at most 10^4. It is guaranteed that there always exists such string.\n    \n    You do not need to find the shortest answer, the only restriction is that the length of string B should not exceed 10^4.\n    \n    \n    -----Input-----\n    \n    First line contains a string A (1 \u2264 |A| \u2264 10^3) consisting of lowercase Latin letters, where |A| is a length of A.\n    \n    \n    -----Output-----\n    \n    Output single line containing B consisting of only lowercase Latin letters. You do not need to find the shortest answer, the only restriction is that the length of string B should not exceed 10^4. If there are many possible B, print any of them.\n    \n    \n    -----Examples-----\n    Input\n    aba\n    \n    Output\n    aba\n    Input\n    ab\n    \n    Output\n    aabaa\n    \n    \n    -----Note-----\n    \n    In the first example, \"aba\" is a subsequence of \"aba\" which is a palindrome.\n    \n    In the second example, \"ab\" is a subsequence of \"aabaa\" which is a palindrome.\n    \"\"\"\n", "entry_point": "find_palindrome", "test": "\ndef check(find_palindrome):\n    assert find_palindrome('aba') == 'abaaba'\n    assert find_palindrome('ab') == 'abba'\n    assert find_palindrome('abca') == 'abcacba'\n    assert find_palindrome('racecar') == 'racecaracecar'\n    assert find_palindrome('a') == 'aa'\ncheck(find_palindrome)\n", "given_tests": ["assert find_palindrome('aba') == 'aba'", "assert find_palindrome('ab') == 'aabaa'"], "canonical_solution": "[\"a = input()\\nb = a[::-1]\\nprint(a + b)\"]", "difficulty": "competition"}
{"task_id": "APPS/2097", "prompt": "def max_possible_f(n: int, edges: List[Tuple[int, int, int]], use_count: List[int]) -> int:\n    \"\"\"\n    DZY loves planting, and he enjoys solving tree problems.\n    \n    DZY has a weighted tree (connected undirected graph without cycles) containing n nodes (they are numbered from 1 to n). He defines the function g(x, y) (1 \u2264 x, y \u2264 n) as the longest edge in the shortest path between nodes x and y. Specially g(z, z) = 0 for every z.\n    \n    For every integer sequence p_1, p_2, ..., p_{n} (1 \u2264 p_{i} \u2264 n), DZY defines f(p) as $\\operatorname{min}_{i = 1}^{n} g(i, p_{i})$.\n    \n    DZY wants to find such a sequence p that f(p) has maximum possible value. But there is one more restriction: the element j can appear in p at most x_{j} times.\n    \n    Please, find the maximum possible f(p) under the described restrictions.\n    \n    \n    -----Input-----\n    \n    The first line contains an integer n\u00a0(1 \u2264 n \u2264 3000).\n    \n    Each of the next n - 1 lines contains three integers a_{i}, b_{i}, c_{i}\u00a0(1 \u2264 a_{i}, b_{i} \u2264 n;\u00a01 \u2264 c_{i} \u2264 10000), denoting an edge between a_{i} and b_{i} with length c_{i}. It is guaranteed that these edges form a tree.\n    \n    Each of the next n lines describes an element of sequence x. The j-th line contains an integer x_{j}\u00a0(1 \u2264 x_{j} \u2264 n).\n    \n    \n    -----Output-----\n    \n    Print a single integer representing the answer.\n    \n    \n    -----Examples-----\n    Input\n    4\n    1 2 1\n    2 3 2\n    3 4 3\n    1\n    1\n    1\n    1\n    \n    Output\n    2\n    \n    Input\n    4\n    1 2 1\n    2 3 2\n    3 4 3\n    4\n    4\n    4\n    4\n    \n    Output\n    3\n    \n    \n    \n    -----Note-----\n    \n    In the first sample, one of the optimal p is [4, 3, 2, 1].\n    \"\"\"\n", "entry_point": "max_possible_f", "test": "\ndef check(max_possible_f):\n    assert max_possible_f(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3)], [1, 1, 1, 1]) == 2\n    assert max_possible_f(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3)], [4, 4, 4, 4]) == 3\n    assert max_possible_f(5, [(1, 2, 1), (1, 3, 1), (1, 4, 1), (1, 5, 1)], [1, 1, 1, 1, 1]) == 1\n    assert max_possible_f(3, [(1, 2, 3), (2, 3, 4)], [2, 2, 2]) == 4\ncheck(max_possible_f)\n", "given_tests": ["assert max_possible_f(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3)], [1, 1, 1, 1]) == 2", "assert max_possible_f(4, [(1, 2, 1), (2, 3, 2), (3, 4, 3)], [4, 4, 4, 4]) == 3"], "canonical_solution": "[\"n = int(input())\\nedges = [[int(x) for x in input().split()] for i in range(n-1)]\\nedges are sorted(edges)\\nuse_count = [0]+[int(input()) for i in range(n)]\\nlo,hi = 0,10000\\ndef getpar(par,u):\\n    if par[par[u]] == par[u]:\\n        return par[u]\\n    par[u] = getpar(par,par[u])\\n    return par[u]\\ndef unite(par,sz,use,u,v):\\n    u = getpar(par,u)\\n    v = getpar(par,v)\\n    par[u] = v\\n    sz[v] += sz[u]\\n    use[v] += use[u]\\ndef solve(fp):\\n    par = [i for i in range(n+1)]\\n    sz = [1 for i in range(n+1)]\\n    use = [use_count[i] for i in range(n+1)]\\n    for edge in edges:\\n        if edge[2] < fp:\\n            unite(par,sz,use,edge[0],edge[1])\\n    total_use = sum(use_count)\\n    for i in range(n+1):\\n        p = getpar(par,i)\\n        if(p == i):\\n            if(total_use - use[p] < sz[p]):\\n                return False\\n    return True\\nwhile lo < hi:\\n    mid = (lo+hi+1)//2\\n    if solve(mid):\\n        lo = mid\\n    else:\\n        hi = mid-1\\nprint(lo)\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2200", "prompt": "def xor_pairwise_sums(n: int, arr: List[int]) -> int:\n    \"\"\"\n    Catherine received an array of integers as a gift for March 8. Eventually she grew bored with it, and she started calculated various useless characteristics for it. She succeeded to do it for each one she came up with. But when she came up with another one\u00a0\u2014 xor of all pairwise sums of elements in the array, she realized that she couldn't compute it for a very large array, thus she asked for your help. Can you do it? Formally, you need to compute\n    \n    $$ (a_1 + a_2) \\oplus (a_1 + a_3) \\oplus \\ldots \\oplus (a_1 + a_n) \\\\ \\oplus (a_2 + a_3) \\oplus \\ldots \\oplus (a_2 + a_n) \\\\ \\ldots \\\\ \\oplus (a_{n-1} + a_n) \\\\ $$\n    \n    Here $x \\oplus y$ is a bitwise XOR operation (i.e. $x$ ^ $y$ in many modern programming languages). You can read about it in Wikipedia: https://en.wikipedia.org/wiki/Exclusive_or#Bitwise_operation.\n    \n    \n    -----Input-----\n    \n    The first line contains a single integer $n$ ($2 \\leq n \\leq 400\\,000$)\u00a0\u2014 the number of integers in the array.\n    \n    The second line contains integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 10^7$).\n    \n    \n    -----Output-----\n    \n    Print a single integer\u00a0\u2014 xor of all pairwise sums of integers in the given array.\n    \n    \n    -----Examples-----\n    Input\n    2\n    1 2\n    \n    Output\n    3\n    Input\n    3\n    1 2 3\n    \n    Output\n    2\n    \n    \n    -----Note-----\n    \n    In the first sample case there is only one sum $1 + 2 = 3$.\n    \n    In the second sample case there are three sums: $1 + 2 = 3$, $1 + 3 = 4$, $2 + 3 = 5$. In binary they are represented as $011_2 \\oplus 100_2 \\oplus 101_2 = 010_2$, thus the answer is 2.\n    \n    $\\oplus$ is the bitwise xor operation. To define $x \\oplus y$, consider binary representations of integers $x$ and $y$. We put the $i$-th bit of the result to be 1 when exactly one of the $i$-th bits of $x$ and $y$ is 1. Otherwise, the $i$-th bit of the result is put to be 0. For example, $0101_2 \\, \\oplus \\, 0011_2 = 0110_2$.\n    \"\"\"\n", "entry_point": "xor_pairwise_sums", "test": "\ndef check(xor_pairwise_sums):\n    assert xor_pairwise_sums(2, [1, 2]) == 3\n    assert xor_pairwise_sums(3, [1, 2, 3]) == 2\n    assert xor_pairwise_sums(2, [1, 1]) == 2\n    assert xor_pairwise_sums(100, list(range(100))) == 102\n    assert xor_pairwise_sums(50, [i for i in range(50)]) == 3\n    assert xor_pairwise_sums(100, [i * 5 for i in range(100)]) == 148\n    assert xor_pairwise_sums(3, [2, 2, 8]) == 4\ncheck(xor_pairwise_sums)\n", "given_tests": ["assert xor_pairwise_sums(2, [1, 2]) == 3", "assert xor_pairwise_sums(3, [1, 2, 3]) == 2"], "canonical_solution": "[\"import sys\\ninput = sys.stdin.readline \\n\\n\\nn = int(input())\\na = list(map(int, input().split()))\\nb = a\\n\\nans = 0\\nfor k in range(29):\\n    a0 = []\\n    a1 = []\\n    a0a = a0.append\\n    a1a = a1.append\\n    \\n    b0 = []\\n    b1 = []\\n    b0a = b0.append\\n    b1a = b1.append\\n    for i in a:\\n        if i&(1<<k): a1a(i)\\n        else: a0a(i)\\n    for i in b:\\n        if i&(1<<k): b1a(i)\\n        else: b0a(i)\\n    \\n    a = a0+a1\\n    b = b0+b1\\n    mask = (1<<(k+1))-1\\n    \\n    aa = [i&mask for i in a]\\n    bb = [i&mask for i in b]\\n    \\n    res = 0\\n    p1 = 1<<k\\n    p2 = mask+1\\n    p3 = p1+p2\\n\\n    j1 = j2 = j3 = 0   \\n    for jj, ai in enumerate(reversed(aa)):\\n        while j1 < n and ai+bb[j1] < p1:\\n            j1 += 1\\n        while j2 < n and ai+bb[j2] < p2:\\n            j2 += 1\\n        while j3 < n and ai+bb[j3] < p3:\\n            j3 += 1\\n        res += max(n, n - jj) - max(j3, n - jj)\\n        res += max(j2, n - jj) - max(j1, n - jj)\\n    ans |= (res & 1) << k\\n    \\nprint(ans)    \\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2118", "prompt": "def game_of_stones(n: int, stones: List[int]) -> str:\n    \"\"\"\n    Sam has been teaching Jon the Game of Stones to sharpen his mind and help him devise a strategy to fight the white walkers. The rules of this game are quite simple:  The game starts with n piles of stones indexed from 1 to n. The i-th pile contains s_{i} stones. The players make their moves alternatively. A move is considered as removal of some number of stones from a pile. Removal of 0 stones does not count as a move. The player who is unable to make a move loses.\n    \n    Now Jon believes that he is ready for battle, but Sam does not think so. To prove his argument, Sam suggested that they play a modified version of the game.\n    \n    In this modified version, no move can be made more than once on a pile. For example, if 4 stones are removed from a pile, 4 stones cannot be removed from that pile again.\n    \n    Sam sets up the game and makes the first move. Jon believes that Sam is just trying to prevent him from going to battle. Jon wants to know if he can win if both play optimally.\n    \n    \n    -----Input-----\n    \n    First line consists of a single integer n (1 \u2264 n \u2264 10^6) \u2014 the number of piles.\n    \n    Each of next n lines contains an integer s_{i} (1 \u2264 s_{i} \u2264 60) \u2014 the number of stones in i-th pile.\n    \n    \n    -----Output-----\n    \n    Print a single line containing \"YES\" (without quotes) if Jon wins, otherwise print \"NO\" (without quotes)\n    \n    \n    -----Examples-----\n    Input\n    1\n    5\n    \n    Output\n    NO\n    Input\n    2\n    1\n    2\n    \n    Output\n    YES\n    \n    \n    -----Note-----\n    \n    In the first case, Sam removes all the stones and Jon loses.\n    \n    In second case, the following moves are possible by Sam: $\\{1,2 \\} \\rightarrow \\{0,2 \\}, \\{1,2 \\} \\rightarrow \\{1,0 \\}, \\{1,2 \\} \\rightarrow \\{1,1 \\}$\n    \n    In each of these cases, last move can be made by Jon to win the game as follows: $\\{0,2 \\} \\rightarrow \\{0,0 \\}, \\{1,0 \\} \\rightarrow \\{0,0 \\}, \\{1,1 \\} \\rightarrow \\{0,1 \\}$\n    \"\"\"\n", "entry_point": "game_of_stones", "test": "\ndef check(candidate):\n    assert candidate(1, [5]) == 'NO'\n    assert candidate(2, [1, 2]) == 'YES'\n    assert candidate(3, [34, 44, 21]) == 'NO'\n    assert candidate(6, [34, 44, 21, 55, 1, 36]) == 'NO'\n    assert candidate(14, [34, 44, 21, 55, 1, 36, 53, 31, 58, 59, 11, 40, 20, 32]) == 'NO'\n    assert candidate(10, [34, 44, 21, 55, 1, 36, 53, 31, 58, 59]) == 'NO'\n    assert candidate(12, [34, 44, 21, 55, 1, 36, 53, 31, 58, 59, 11, 40]) == 'NO'\n    assert candidate(118, [34, 44, 21, 55, 1, 36, 53, 31, 58, 59, 11, 40, 20, 32, 43, 48, 16, 5, 35, 20, 21, 36, 15, 2, 11, 56, 58, 2, 40, 47, 29, 21, 4, 21, 1, 25, 51, 55, 17, 40, 56, 35, 51, 1, 34, 18, 54, 44, 1, 43, 16, 28, 21, 14, 57, 53, 29, 44, 59, 54, 47, 21, 43, 41, 11, 37, 30, 4, 39, 47, 40, 50, 52, 9, 32, 1, 19, 30, 20, 6, 25, 42, 34, 38, 42, 46, 35, 28, 20, 47, 60, 46, 35, 59, 24, 11, 25, 27, 9, 51, 39, 35, 22, 24, 10, 48, 6, 30, 10, 33, 51, 45, 38, 8, 51, 8, 7, 46]) == 'NO'\n    assert candidate(124, [34, 44, 21, 55, 1, 36, 53, 31, 58, 59, 11, 40, 20, 32, 43, 48, 16, 5, 35, 20, 21, 36, 15, 2, 11, 56, 58, 2, 40, 47, 29, 21, 4, 21, 1, 25, 51, 55, 17, 40, 56, 35, 51, 1, 34, 18, 54, 44, 1, 43, 16, 28, 21, 14, 57, 53, 29, 44, 59, 54, 47, 21, 43, 41, 11, 37, 30, 4, 39, 47, 40, 50, 52, 9, 32, 1, 19, 30, 20, 6, 25, 42, 34, 38, 42, 46, 35, 28, 20, 47, 60, 46, 35, 59, 24, 11, 25, 27, 9, 51, 39, 35, 22, 24, 10, 48, 6, 30, 10, 33, 51, 45, 38, 8, 51, 8, 7, 46, 49, 27, 16, 13, 4, 54]) == 'NO'\n    assert candidate(15, [34, 44, 21, 55, 1, 36, 53, 31, 58, 59, 11, 40, 20, 32, 43]) == 'NO'\n    assert candidate(2, [34, 44]) == 'NO'\ncheck(game_of_stones)\n", "given_tests": ["assert game_of_stones(1, [5]) == 'NO'", "assert game_of_stones(2, [1, 2]) == 'YES'"], "canonical_solution": "[\"n = int(input())\\narr = [int(input()) for i in range(n)]\\nb = [0 for i in range(n)]\\ns = 0\\nfor i in range(n):\\n    j = int((arr[i] << 1) ** 0.5)\\n    if j * (j + 1) > (arr[i] << 1):\\n        j -= 1\\n    s ^= j\\nif s != 0:\\n    print('NO')\\nelse:\\n    print('YES')\\n\", \"from math import sqrt\\nk = 0\\nfor t in range(int(input())): k ^= int(int(sqrt(8 * int(input()) + 1) - 1) / 2)\\nprint(\\\"NO\\\" if k != 0 else \\\"YES\\\")\", \"s = 0\\nfor t in range(int(input())): s ^= int((8 * int(input()) + 1) ** 0.5 - 1) // 2\\nprint(['YES', 'NO'][s > 0])\", \"ans=0\\nfor _ in range(int(input())):\\n    ans^=int((8*int(input())+1)**0.5-1)//2\\nprint(['YES', 'NO'][ans>0])\", \"import sys\\ninput = sys.stdin.readline\\n\\ndef large(x):\\n    for i in range(10, -1, -1):\\n        if i*(i+1)//2 <= x:\\n            return i\\nx = int(input())\\nl = []\\nfor i in range(x):\\n    l.append(int(input()))\\na = [large(i) for i in range(0, 61)]\\nlol = 0\\nfor i in l:\\n    i = a[i]\\n    lol = lol ^ i\\nif (lol == 0):\\n    print(\\\"YES\\\")\\nelse:\\n    print(\\\"NO\\\")\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2034", "prompt": "def max_perimeter(n: int, points: List[List[int]]) -> str:\n    \"\"\"\n    You are given $n$ points on the plane. The polygon formed from all the $n$ points is strictly convex, that is, the polygon is convex, and there are no three collinear points (i.e. lying in the same straight line). The points are numbered from $1$ to $n$, in clockwise order.\n    \n    We define the distance between two points $p_1 = (x_1, y_1)$ and $p_2 = (x_2, y_2)$ as their Manhattan distance: $$d(p_1, p_2) = |x_1 - x_2| + |y_1 - y_2|.$$\n    \n    Furthermore, we define the perimeter of a polygon, as the sum of Manhattan distances between all adjacent pairs of points on it; if the points on the polygon are ordered as $p_1, p_2, \\ldots, p_k$ $(k \\geq 3)$, then the perimeter of the polygon is $d(p_1, p_2) + d(p_2, p_3) + \\ldots + d(p_k, p_1)$.\n    \n    For some parameter $k$, let's consider all the polygons that can be formed from the given set of points, having any $k$ vertices, such that the polygon is not self-intersecting. For each such polygon, let's consider its perimeter. Over all such perimeters, we define $f(k)$ to be the maximal perimeter.\n    \n    Please note, when checking whether a polygon is self-intersecting, that the edges of a polygon are still drawn as straight lines. For instance, in the following pictures:\n    \n    [Image]\n    \n    In the middle polygon, the order of points ($p_1, p_3, p_2, p_4$) is not valid, since it is a self-intersecting polygon. The right polygon (whose edges resemble the Manhattan distance) has the same order and is not self-intersecting, but we consider edges as straight lines. The correct way to draw this polygon is ($p_1, p_2, p_3, p_4$), which is the left polygon.\n    \n    Your task is to compute $f(3), f(4), \\ldots, f(n)$. In other words, find the maximum possible perimeter for each possible number of points (i.e. $3$ to $n$).\n    \n    \n    -----Input-----\n    \n    The first line contains a single integer $n$ ($3 \\leq n \\leq 3\\cdot 10^5$)\u00a0\u2014 the number of points.\n    \n    Each of the next $n$ lines contains two integers $x_i$ and $y_i$ ($-10^8 \\leq x_i, y_i \\leq 10^8$)\u00a0\u2014 the coordinates of point $p_i$.\n    \n    The set of points is guaranteed to be convex, all points are distinct, the points are ordered in clockwise order, and there will be no three collinear points.\n    \n    \n    -----Output-----\n    \n    For each $i$ ($3\\leq i\\leq n$), output $f(i)$.\n    \n    \n    -----Examples-----\n    Input\n    4\n    2 4\n    4 3\n    3 0\n    1 3\n    \n    Output\n    12 14\n    Input\n    3\n    0 0\n    0 2\n    2 0\n    \n    Output\n    8\n    \n    \n    -----Note-----\n    \n    In the first example, for $f(3)$, we consider four possible polygons:   ($p_1, p_2, p_3$), with perimeter $12$.  ($p_1, p_2, p_4$), with perimeter $8$.  ($p_1, p_3, p_4$), with perimeter $12$.  ($p_2, p_3, p_4$), with perimeter $12$.\n    \n    For $f(4)$, there is only one option, taking all the given points. Its perimeter $14$.\n    \n    In the second example, there is only one possible polygon. Its perimeter is $8$.\n    \"\"\"\n", "entry_point": "max_perimeter", "test": "\ndef check(candidate):\n    assert candidate(4, [[2, 4], [4, 3], [3, 0], [1, 3]]) == '12 14'\n    assert candidate(3, [[0, 0], [0, 2], [2, 0]]) == '8'\n    assert candidate(8, [[0, 3], [2, 2], [3, 0], [2, -2], [0, -3], [-2, -2], [-3, 0], [-2, 2]]) == '20 24 24 24 24 24'\n    assert candidate(4, [[-100000000, -100000000], [-100000000, 100000000], [100000000, 100000000], [100000000, -100000000]]) == '800000000 800000000'\n    assert candidate(4, [[0, 0], [10, 10], [10, 9], [1, 0]]) == '40 40'\n    assert candidate(4, [[12345678, 99999999], [12345679, 100000000], [12345680, 99999999], [12345679, 99999998]]) == '6 8'\n    assert candidate(6, [[-1000, 1000], [-998, 1001], [-996, 1000], [-996, 996], [-997, 995], [-1001, 997]]) == '20 22 22 22'\n    assert candidate(3, [[51800836, -5590860], [51801759, -5590419], [51801320, -5590821]]) == '2728'\n    assert candidate(3, [[97972354, -510322], [97972814, -510361], [97972410, -510528]]) == '1332'\n    assert candidate(4, [[-95989415, -89468419], [-95989014, -89468179], [-95989487, -89468626], [-95989888, -89468866]]) == '3122 3122'\n    assert candidate(4, [[100000000, 0], [0, -100000000], [-100000000, 0], [0, 100000000]]) == '600000000 800000000'\n    assert candidate(3, [[77445196, 95326351], [77444301, 95326820], [77444705, 95326693]]) == '2728'\n    assert candidate(3, [[-99297393, 80400183], [-99297475, 80399631], [-99297428, 80399972]]) == '1268'\n    assert candidate(10, [[811055, 21220458], [813063, 21222323], [815154, 21220369], [817067, 21218367], [815214, 21216534], [813198, 21214685], [803185, 21212343], [805063, 21214436], [806971, 21216475], [808966, 21218448]]) == '47724 47724 47724 47724 47724 47724 47724 47724'\n    assert candidate(12, [[-83240790, -33942371], [-83240805, -33942145], [-83240821, -33941752], [-83240424, -33941833], [-83240107, -33942105], [-83239958, -33942314], [-83239777, -33942699], [-83239762, -33942925], [-83239746, -33943318], [-83240143, -33943237], [-83240460, -33942965], [-83240609, -33942756]]) == '5282 5282 5282 5282 5282 5282 5282 5282 5282 5282'\n    assert candidate(20, [[-2967010, 48581504], [-2967318, 48581765], [-2967443, 48581988], [-2967541, 48582265], [-2967443, 48582542], [-2967318, 48582765], [-2967010, 48583026], [-2966691, 48583154], [-2966252, 48583234], [-2965813, 48583154], [-2965494, 48583026], [-2965186, 48582765], [-2965061, 48582542], [-2964963, 48582265], [-2965061, 48581988], [-2965186, 48581765], [-2965494, 48581504], [-2965813, 48581376], [-2966252, 48581296], [-2966691, 48581376]]) == '7648 9032 9032 9032 9032 9032 9032 9032 9032 9032 9032 9032 9032 9032 9032 9032 9032 9032'\n    assert candidate(4, [[0, 99999999], [0, 100000000], [1, -99999999], [1, -100000000]]) == '400000002 400000002'\ncheck(max_perimeter)\n", "given_tests": ["assert max_perimeter(4, [[2, 4], [4, 3], [3, 0], [1, 3]]) == '12 14'", "assert max_perimeter(3, [[0, 0], [0, 2], [2, 0]]) == '8'"], "canonical_solution": "[\"import sys\\ninput = sys.stdin.readline\\n\\nn = int(input())\\nx = []\\ny = []\\nfor i in range(n):\\n    xi, yi = map(int, input().split())\\n    x.append(xi)\\n    y.append(yi)\\nmin_x = min(x)\\nmax_x = max(x)\\nmin_y = min(y)\\nmax_y = max(y)\\nanswer = 0\\nfor i in range(n):\\n    dx = max(max_x - x[i], x[i] - min_x)\\n    dy = max(max_y - y[i], y[i] - min_y)\\n    answer = max(answer, dx + dy)\\nprint(2*answer, end = ' ')\\nfor i in range(4, n + 1):\\n    print(2*(max_x - min_x + max_y - min_y), end = ' ')\", \"import sys\\ninput = sys.stdin.readline\\nout = sys.stdout\\n\\nn = int(input())\\nx = []\\ny = []\\nfor i in range(n):\\n    xi, yi = map(int, input().split())\\n    x.append(xi)\\n    y.append(yi)\\nmin_x = min(x)\\nmax_x = max(x)\\nmin_y = min(y)\\nmax_y = max(y)\\nanswer = 0\\nfor i in range(n):\\n    dx = max(max_x - x[i], x[i] - min_x)\\n    dy = max(max_y - y[i], y[i] - min_y)\\n    answer = max(answer, dx + dy)\\nout.write(str(2*answer) + ' ')\\nfor i in range(4, n + 1):\\n    out.write(str(2*(max_x - min_x + max_y - min_y)) + ' ')\"]", "difficulty": "competition"}
{"task_id": "APPS/2173", "prompt": "def process_paper_operations(n: int, q: int, queries: List[str]) -> List[int]:\n    \"\"\"\n    Appleman has a very big sheet of paper. This sheet has a form of rectangle with dimensions 1 \u00d7 n. Your task is help Appleman with folding of such a sheet. Actually, you need to perform q queries. Each query will have one of the following types:  Fold the sheet of paper at position p_{i}. After this query the leftmost part of the paper with dimensions 1 \u00d7 p_{i} must be above the rightmost part of the paper with dimensions 1 \u00d7 ([current\u00a0width\u00a0of\u00a0sheet] - p_{i}).  Count what is the total width of the paper pieces, if we will make two described later cuts and consider only the pieces between the cuts. We will make one cut at distance l_{i} from the left border of the current sheet of paper and the other at distance r_{i} from the left border of the current sheet of paper.\n    \n    Please look at the explanation of the first test example for better understanding of the problem.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers: n and q (1  \u2264 n \u2264 10^5;\u00a01 \u2264 q \u2264 10^5) \u2014 the width of the paper and the number of queries.\n    \n    Each of the following q lines contains one of the described queries in the following format:  \"1 p_{i}\" (1 \u2264 p_{i} < [current\u00a0width\u00a0of\u00a0sheet]) \u2014 the first type query.  \"2 l_{i} r_{i}\" (0 \u2264 l_{i} < r_{i} \u2264 [current\u00a0width\u00a0of\u00a0sheet]) \u2014 the second type query.\n    \n    \n    -----Output-----\n    \n    For each query of the second type, output the answer.\n    \n    \n    -----Examples-----\n    Input\n    7 4\n    1 3\n    1 2\n    2 0 1\n    2 1 2\n    \n    Output\n    4\n    3\n    \n    Input\n    10 9\n    2 2 9\n    1 1\n    2 0 1\n    1 8\n    2 0 8\n    1 2\n    2 1 3\n    1 4\n    2 2 4\n    \n    Output\n    7\n    2\n    10\n    4\n    5\n    \n    \n    \n    -----Note-----\n    \n    The pictures below show the shapes of the paper during the queries of the first example: [Image]\n    \n    After the first fold operation the sheet has width equal to 4, after the second one the width of the sheet equals to 2.\n    \"\"\"\n", "entry_point": "process_paper_operations", "test": "\ndef check(process_paper_operations):\n    assert process_paper_operations(7, 4, [\"1 3\", \"1 2\", \"2 0 1\", \"2 1 2\"]) == [4, 3]\n    assert process_paper_operations(10, 9, [\"2 2 9\", \"1 1\", \"2 0 1\", \"1 8\", \"2 0 8\", \"1 2\", \"2 1 3\", \"1 4\", \"2 2 4\"]) == [7, 2, 10, 4, 5]\n    assert process_paper_operations(10, 5, [\"2 1 9\", \"2 4 10\", \"1 1\", \"2 0 1\", \"2 0 1\"]) == [8, 6, 2, 2]\n    assert process_paper_operations(10, 5, [\"1 8\", \"1 1\", \"1 1\", \"1 3\", \"1 2\"]) == []\n    assert process_paper_operations(10, 10, [\"2 5 9\", \"2 2 9\", \"2 1 7\", \"2 3 9\", \"2 3 4\", \"2 0 6\", \"2 3 9\", \"2 2 8\", \"2 5 9\", \"1 9\"]) == [4, 7, 6, 6, 1, 6, 6, 6, 4]\n    assert process_paper_operations(100000, 1, [\"2 19110 78673\"]) == [59563]\n    assert process_paper_operations(100000, 1, [\"1 99307\"]) == []\n    assert process_paper_operations(1, 1, [\"2 0 1\"]) == [1]\n    assert process_paper_operations(2, 3, [\"2 0 2\", \"2 0 1\", \"1 1\"]) == [2, 1]\ncheck(process_paper_operations)\n", "given_tests": ["assert process_paper_operations(7, 4, [\"1 3\", \"1 2\", \"2 0 1\", \"2 1 2\"]) == [4, 3]", "assert process_paper_operations(10, 9, [\"2 2 9\", \"1 1\", \"2 0 1\", \"1 8\", \"2 0 8\", \"1 2\", \"2 1 3\", \"1 4\", \"2 2 4\"]) == [7, 2, 10, 4, 5]"], "canonical_solution": "def process_paper_operations(n, q, queries):\n    from itertools import starmap\n\n    a = list(range(n + 1))\n    flipped = False\n    start = 0\n    end = n\n\n    results = []\n    for query in queries:\n        cmd, *args = map(int, query.split())\n\n        if cmd == 1:\n            p = args[0]\n            if p > end - start - p:\n                flipped = not flipped\n                p = end - start - p\n            if flipped:\n                a[end - p:end - 2 * p:-1] = starmap(\n                    lambda a, b: a + n - b,\n                    list(zip(a[end - p:end - 2 * p:-1], a[end - p:end]))\n                )\n                end -= p\n            else:\n                start += p\n                a[start:start + p] = starmap(\n                    lambda a, b: a - b,\n                    list(zip(a[start:start + p], a[start:start - p:-1]))\n                )\n        else:\n            l, r = args\n            if flipped:\n                l, r = end - start - r, end - start - l\n            results.append(a[start + r] - a[start + l])\n    return results\n", "difficulty": "competition"}
{"task_id": "APPS/2030", "prompt": "def find_min_travel_cost(n: int, x: int, y: int, roads: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    A group of n cities is connected by a network of roads. There is an undirected road between every pair of cities, so there are $\\frac{n \\cdot(n - 1)}{2}$ roads in total. It takes exactly y seconds to traverse any single road.\n    \n    A spanning tree is a set of roads containing exactly n - 1 roads such that it's possible to travel between any two cities using only these roads.\n    \n    Some spanning tree of the initial network was chosen. For every road in this tree the time one needs to traverse this road was changed from y to x seconds. Note that it's not guaranteed that x is smaller than y.\n    \n    You would like to travel through all the cities using the shortest path possible. Given n, x, y and a description of the spanning tree that was chosen, find the cost of the shortest path that starts in any city, ends in any city and visits all cities exactly once.\n    \n    \n    -----Input-----\n    \n    The first line of the input contains three integers n, x and y (2 \u2264 n \u2264 200 000, 1 \u2264 x, y \u2264 10^9).\n    \n    Each of the next n - 1 lines contains a description of a road in the spanning tree. The i-th of these lines contains two integers u_{i} and v_{i} (1 \u2264 u_{i}, v_{i} \u2264 n)\u00a0\u2014 indices of the cities connected by the i-th road. It is guaranteed that these roads form a spanning tree.\n    \n    \n    -----Output-----\n    \n    Print a single integer\u00a0\u2014 the minimum number of seconds one needs to spend in order to visit all the cities exactly once.\n    \n    \n    -----Examples-----\n    Input\n    5 2 3\n    1 2\n    1 3\n    3 4\n    5 3\n    \n    Output\n    9\n    \n    Input\n    5 3 2\n    1 2\n    1 3\n    3 4\n    5 3\n    \n    Output\n    8\n    \n    \n    \n    -----Note-----\n    \n    In the first sample, roads of the spanning tree have cost 2, while other roads have cost 3. One example of an optimal path is $5 \\rightarrow 3 \\rightarrow 4 \\rightarrow 1 \\rightarrow 2$.\n    \n    In the second sample, we have the same spanning tree, but roads in the spanning tree cost 3, while other roads cost 2. One example of an optimal path is $1 \\rightarrow 4 \\rightarrow 5 \\rightarrow 2 \\rightarrow 3$.\n    \"\"\"\n", "entry_point": "find_min_travel_cost", "test": "\ndef check(find_min_travel_cost):\n    assert find_min_travel_cost(5, 2, 3, [(1, 2), (1, 3), (3, 4), (5, 3)]) == 9\n    assert find_min_travel_cost(5, 3, 2, [(1, 2), (1, 3), (3, 4), (5, 3)]) == 8\n    assert find_min_travel_cost(50, 23129, 410924, [(18, 28), (17, 23), (21, 15), (18, 50), (50, 11), (32, 3), (44, 41), (50, 31), (50, 34), (5, 14), (36, 13), (22, 40), (20, 9), (9, 43), (19, 47), (48, 40), (20, 22), (33, 45), (35, 22), (33, 24), (9, 6), (13, 1), (13, 24), (49, 20), (1, 20), (29, 38), (10, 35), (25, 23), (49, 30), (42, 8), (20, 18), (32, 15), (32, 1), (27, 10), (20, 47), (41, 7), (20, 14), (18, 26), (4, 20), (20, 2), (46, 37), (41, 16), (46, 41), (12, 20), (8, 40), (18, 37), (29, 3), (32, 39), (23, 37)]) == 8113631\n    assert find_min_travel_cost(2, 3, 4, [(1, 2)]) == 3\n    assert find_min_travel_cost(50, 491238, 12059, [(42, 3), (5, 9), (11, 9), (41, 15), (42, 34), (11, 6), (40, 16), (23, 8), (41, 7), (22, 6), (24, 29), (7, 17), (31, 2), (17, 33), (39, 42), (42, 6), (41, 50), (21, 45), (19, 41), (1, 21), (42, 1), (2, 25), (17, 28), (49, 42), (30, 13), (4, 12), (10, 32), (48, 35), (21, 2), (14, 6), (49, 29), (18, 20), (38, 22), (19, 37), (20, 47), (3, 36), (1, 44), (20, 7), (4, 11), (39, 26), (30, 40), (6, 7), (25, 46), (2, 27), (30, 42), (10, 11), (8, 21), (42, 43), (35, 8)]) == 590891\n    assert find_min_travel_cost(2, 4, 1, [(1, 2)]) == 4\n    assert find_min_travel_cost(5, 2, 2, [(1, 2), (1, 3), (1, 4), (1, 5)]) == 8\n    assert find_min_travel_cost(4, 100, 1, [(1, 2), (1, 3), (1, 4)]) == 102\n    assert find_min_travel_cost(3, 2, 1, [(1, 2), (1, 3)]) == 3\n    assert find_min_travel_cost(5, 6, 1, [(1, 2), (1, 3), (1, 4), (1, 5)]) == 9\n    assert find_min_travel_cost(3, 100, 1, [(1, 2), (2, 3)]) == 101\n    assert find_min_travel_cost(2, 2, 1, [(1, 2)]) == 2\n    assert find_min_travel_cost(5, 3, 2, [(1, 2), (1, 3), (1, 4), (1, 5)]) == 9\n    assert find_min_travel_cost(4, 1000, 1, [(1, 2), (1, 3), (1, 4)]) == 1002\n    assert find_min_travel_cost(4, 100, 1, [(1, 2), (2, 3), (3, 4)]) == 3\n    assert find_min_travel_cost(2, 3, 1, [(1, 2)]) == 3\n    assert find_min_travel_cost(5, 4, 3, [(1, 2), (1, 3), (1, 4), (1, 5)]) == 13\ncheck(find_min_travel_cost)\n", "given_tests": ["assert find_min_travel_cost(5, 2, 3, [(1, 2), (1, 3), (3, 4), (5, 3)]) == 9", "assert find_min_travel_cost(5, 3, 2, [(1, 2), (1, 3), (3, 4), (5, 3)]) == 8"], "canonical_solution": "def find_min_travel_cost(n, x, y, roads):\n    from collections import defaultdict\n    from collections import deque\n    from functools import reduce\n\n    E = defaultdict(set)\n    for u, v in roads:\n        E[u].add(v)\n        E[v].add(u)\n\n    if x > y:\n        for v in E:\n            if len(E[v]) == n-1:\n                return (n-2)*y + x\n            elif len(E[v]) > 1:\n                return (n-1)*y\n    else:\n        visited = {v : False for v in E}\n        stack = [1]\n        topsorted = deque()\n        while stack:\n            v = stack.pop()\n            if visited[v]: continue\n            visited[v] = True\n            topsorted.appendleft(v)\n            stack.extend(E[v])\n        chopped = set()\n        ans = 0\n        for v in topsorted:\n            ans += max(0, len(E[v])-2)\n            if len(E[v]) > 2:\n                S = E[v].intersection(chopped)\n                S1 = {S.pop(), S.pop()}\n                for u in E[v]:\n                    if not u in S1:\n                        E[u].remove(v)\n                E[v].clear()\n                E[v].update(S1)\n            chopped.add(v)\n        return ans*y + (n-1-ans)*x\n", "difficulty": "competition"}
{"task_id": "APPS/2018", "prompt": "def find_min_goodness(n: int, h: int, a: List[int]) -> Tuple[int, List[int]]:\n    \"\"\"\n    This problem is the most boring one you've ever seen.\n    \n    Given a sequence of integers a_1, a_2, ..., a_{n} and a non-negative integer h, our goal is to partition the sequence into two subsequences (not necessarily consist of continuous elements). Each element of the original sequence should be contained in exactly one of the result subsequences. Note, that one of the result subsequences can be empty.\n    \n    Let's define function f(a_{i}, a_{j}) on pairs of distinct elements (that is i \u2260 j) in the original sequence. If a_{i} and a_{j} are in the same subsequence in the current partition then f(a_{i}, a_{j}) = a_{i} + a_{j} otherwise f(a_{i}, a_{j}) = a_{i} + a_{j} + h.\n    \n    Consider all possible values of the function f for some partition. We'll call the goodness of this partiotion the difference between the maximum value of function f and the minimum value of function f.\n    \n    Your task is to find a partition of the given sequence a that have the minimal possible goodness among all possible partitions.\n    \n    \n    -----Input-----\n    \n    The first line of input contains integers n and h (2 \u2264 n \u2264 10^5, 0 \u2264 h \u2264 10^8). In the second line there is a list of n space-separated integers representing a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 10^8).\n    \n    \n    -----Output-----\n    \n    The first line of output should contain the required minimum goodness.\n    \n    The second line describes the optimal partition. You should print n whitespace-separated integers in the second line. The i-th integer is 1 if a_{i} is in the first subsequence otherwise it should be 2.\n    \n    If there are several possible correct answers you are allowed to print any of them.\n    \n    \n    -----Examples-----\n    Input\n    3 2\n    1 2 3\n    \n    Output\n    1\n    1 2 2\n    \n    Input\n    5 10\n    0 1 0 2 1\n    \n    Output\n    3\n    2 2 2 2 2\n    \n    \n    \n    -----Note-----\n    \n    In the first sample the values of f are as follows: f(1, 2) = 1 + 2 + 2 = 5, f(1, 3) = 1 + 3 + 2 = 6 and f(2, 3) = 2 + 3 = 5. So the difference between maximum and minimum values of f is 1.\n    \n    In the second sample the value of h is large, so it's better for one of the sub-sequences to be empty.\n    \"\"\"\n", "entry_point": "find_min_goodness", "test": "\ndef check(find_min_goodness):\n    assert find_min_goodness(3, 2, [1, 2, 3]) == (1, [1, 2, 2])\n    assert find_min_goodness(5, 10, [0, 1, 0, 2, 1]) == (3, [2, 2, 2, 2, 2])\n    assert find_min_goodness(9, 0, [11, 22, 33, 44, 55, 66, 77, 88, 99]) == (154, [2, 2, 2, 2, 2, 2, 2, 2, 2])\n    assert find_min_goodness(10, 100, [2705446, 2705444, 2705446, 2705445, 2705448, 2705447, 2705444, 2705448, 2705448, 2705449]) == (9, [2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n    assert find_min_goodness(10, 5, [5914099, 5914094, 5914099, 5914097, 5914100, 5914101, 5914097, 5914095, 5914101, 5914102]) == (11, [2, 1, 2, 2, 2, 2, 2, 2, 2, 2])\n    assert find_min_goodness(12, 3, [7878607, 7878605, 7878605, 7878613, 7878612, 7878609, 7878609, 7878608, 7878609, 7878611, 7878609, 7878613]) == (14, [2, 2, 1, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n    assert find_min_goodness(9, 6, [10225066, 10225069, 10225069, 10225064, 10225068, 10225067, 10225066, 10225063, 10225062]) == (11, [2, 2, 2, 2, 2, 2, 2, 2, 1])\n    assert find_min_goodness(20, 10, [12986238, 12986234, 12986240, 12986238, 12986234, 12986238, 12986234, 12986234, 12986236, 12986236, 12986232, 12986238, 12986232, 12986239, 12986233, 12986238, 12986237, 12986232, 12986231, 12986235]) == (16, [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n    assert find_min_goodness(4, 3, [16194884, 16194881, 16194881, 16194883]) == (4, [2, 2, 1, 2])\n    assert find_min_goodness(2, 5, [23921862, 23921857]) == (0, [1, 1])\n    assert find_min_goodness(3, 8, [28407428, 28407413, 28407422]) == (7, [2, 1, 2])\n    assert find_min_goodness(7, 4, [0, 10, 10, 11, 11, 12, 13]) == (11, [1, 2, 2, 2, 2, 2, 2])\n    assert find_min_goodness(10, 6, [4, 2, 2, 3, 4, 0, 3, 2, 2, 2]) == (6, [2, 2, 2, 2, 2, 2, 2, 2, 2, 2])\n    assert find_min_goodness(5, 10000000, [1, 1, 2, 2, 100000000]) == (100000000, [2, 2, 2, 2, 2])\n    assert find_min_goodness(2, 2, [2, 2]) == (0, [1, 1])\n    assert find_min_goodness(2, 0, [8, 9]) == (0, [1, 1])\n    assert find_min_goodness(2, 5, [8, 9]) == (0, [1, 1])\n    assert find_min_goodness(10, 1, [10, 10, 10, 10, 10, 4, 4, 4, 4, 1]) == (14, [2, 2, 2, 2, 2, 2, 2, 2, 2, 1])\ncheck(find_min_goodness)\n", "given_tests": ["assert find_min_goodness(3, 2, [1, 2, 3]) == (1, [1, 2, 2])", "assert find_min_goodness(5, 10, [0, 1, 0, 2, 1]) == (3, [2, 2, 2, 2, 2])"], "canonical_solution": "def find_min_goodness(n, h, a):\n    a = sorted((val, i) for i, val in enumerate(a))\n    if n == 2:\n        return 0, [1, 1]\n    min_ = (a[-1][0] + a[-2][0]) - (a[0][0] + a[1][0])\n    min_2 = max(a[-1][0] + a[-2][0], a[-1][0] + a[0][0] + h) - min(a[0][0] + a[1][0] + h, a[1][0] + a[2][0])\n    ans = [1] * n\n    if min_2 < min_:\n        min_ = min_2\n        ans[a[0][1]] = 2\n    return min_, ans\n", "difficulty": "competition"}
{"task_id": "APPS/2158", "prompt": "def find_permutation(n: int) -> Tuple[str, List[int]]:\n    \"\"\"\n    Consider a sequence [a_1, a_2, ... , a_{n}]. Define its prefix product sequence $[ a_{1} \\operatorname{mod} n,(a_{1} a_{2}) \\operatorname{mod} n, \\cdots,(a_{1} a_{2} \\cdots a_{n}) \\operatorname{mod} n ]$.\n    \n    Now given n, find a permutation of [1, 2, ..., n], such that its prefix product sequence is a permutation of [0, 1, ..., n - 1].\n    \n    \n    -----Input-----\n    \n    The only input line contains an integer n (1 \u2264 n \u2264 10^5).\n    \n    \n    -----Output-----\n    \n    In the first output line, print \"YES\" if such sequence exists, or print \"NO\" if no such sequence exists.\n    \n    If any solution exists, you should output n more lines. i-th line contains only an integer a_{i}. The elements of the sequence should be different positive integers no larger than n.\n    \n    If there are multiple solutions, you are allowed to print any of them.\n    \n    \n    -----Examples-----\n    Input\n    7\n    \n    Output\n    YES\n    1\n    4\n    3\n    6\n    5\n    2\n    7\n    \n    Input\n    6\n    \n    Output\n    NO\n    \n    \n    \n    -----Note-----\n    \n    For the second sample, there are no valid sequences.\n    \"\"\"\n", "entry_point": "find_permutation", "test": "\ndef check(find_permutation):\n    assert find_permutation(7) == ('YES', [1, 2, 5, 6, 3, 4, 7])\n    assert find_permutation(6) == ('NO', [])\n    assert find_permutation(7137) == ('NO', [])\n    assert find_permutation(1941) == ('NO', [])\n    assert find_permutation(55004) == ('NO', [])\n    assert find_permutation(1) == ('YES', [1])\n    assert find_permutation(2) == ('YES', [1, 2])\n    assert find_permutation(3) == ('YES', [1, 2, 3])\n    assert find_permutation(4) == ('YES', [1, 3, 2, 4])\n    assert find_permutation(5) == ('YES', [1, 2, 4, 3, 5])\ncheck(find_permutation)\n", "given_tests": ["assert find_permutation(7) == ('YES', [1, 2, 5, 6, 3, 4, 7])", "assert find_permutation(6) == ('NO', [])"], "canonical_solution": "def find_permutation(n):\n    def is_prime(x):\n        if x <= 1:\n            return False\n        for i in range(2, int(x ** 0.5) + 1):\n            if x % i == 0:\n                return False\n        return True\n\n    if n == 4:\n        return 'YES', [1, 3, 2, 4]\n    elif not is_prime(n):\n        return 'NO', []\n    else:\n        result = [1]\n        for i in range(2, n):\n            result.append((i - 1) * pow(i, n - 2, n) % n)\n        result.append(n)\n        return 'YES', result\n", "difficulty": "competition"}
{"task_id": "APPS/2149", "prompt": "def count_connected_components(n: int, m: int, a: List[int]) -> int:\n    \"\"\"\n    You are given a set of size $m$ with integer elements between $0$ and $2^{n}-1$ inclusive. Let's build an undirected graph on these integers in the following way: connect two integers $x$ and $y$ with an edge if and only if $x \\& y = 0$. Here $\\&$ is the bitwise AND operation. Count the number of connected components in that graph.\n    \n    \n    -----Input-----\n    \n    In the first line of input there are two integers $n$ and $m$ ($0 \\le n \\le 22$, $1 \\le m \\le 2^{n}$).\n    \n    In the second line there are $m$ integers $a_1, a_2, \\ldots, a_m$ ($0 \\le a_{i} < 2^{n}$)\u00a0\u2014 the elements of the set. All $a_{i}$ are distinct.\n    \n    \n    -----Output-----\n    \n    Print the number of connected components.\n    \n    \n    -----Examples-----\n    Input\n    2 3\n    1 2 3\n    \n    Output\n    2\n    \n    Input\n    5 5\n    5 19 10 20 12\n    \n    Output\n    2\n    \n    \n    \n    -----Note-----\n    \n    Graph from first sample:\n    \n    $0$\n    \n    Graph from second sample:\n    \n    [Image]\n    \"\"\"\n", "entry_point": "count_connected_components", "test": "\ndef check(count_connected_components):\n    assert count_connected_components(2, 3, [1, 2, 3]) == 2\n    assert count_connected_components(5, 5, [5, 19, 10, 20, 12]) == 2\n    assert count_connected_components(3, 5, [3, 5, 0, 6, 7]) == 1\n    assert count_connected_components(0, 1, [0]) == 1\n    assert count_connected_components(1, 1, [1]) == 1\n    assert count_connected_components(1, 1, [0]) == 1\n    assert count_connected_components(6, 30, [3, 8, 13, 16, 18, 19, 21, 22, 24, 25, 26, 28, 29, 31, 33, 42, 44, 46, 49, 50, 51, 53, 54, 57, 58, 59, 60, 61, 62, 63]) == 10\n    assert count_connected_components(6, 35, [5, 7, 10, 11, 13, 14, 17, 18, 25, 27, 28, 29, 30, 31, 33, 35, 36, 37, 39, 40, 41, 43, 46, 47, 50, 52, 55, 56, 57, 58, 59, 60, 61, 62, 63]) == 13\n    assert count_connected_components(6, 22, [21, 23, 26, 28, 31, 35, 38, 39, 41, 42, 44, 45, 47, 50, 51, 52, 54, 55, 56, 59, 62, 63]) == 20\n    assert count_connected_components(6, 19, [15, 23, 27, 29, 30, 31, 43, 46, 47, 51, 53, 55, 57, 58, 59, 60, 61, 62, 63]) == 19\ncheck(count_connected_components)\n", "given_tests": ["assert count_connected_components(2, 3, [1, 2, 3]) == 2", "assert count_connected_components(5, 5, [5, 19, 10, 20, 12]) == 2"], "canonical_solution": "def count_connected_components(n, m, a):\n    a = set(a)\n    y = 2 ** n\n    mk = [0] * (2 * y)\n    cur = 0\n    for x in a:\n        if mk[x]: continue\n        mk[x] = 1\n        st = [x]\n        while st:\n            u = st.pop()\n            if u < y:\n                if not mk[y + u]:\n                    mk[y + u] = 1\n                    st.append(y + u)\n            else:\n                for b in range(n):\n                    v = u | 1 << b\n                    if u < v and not mk[v]:\n                        mk[v] = 1\n                        st.append(v)\n                v = y - 1 - (u - y)\n                if v in a and not mk[v]:\n                    mk[v] = 1\n                    st.append(v)\n        cur += 1\n    return cur\n", "difficulty": "competition"}
{"task_id": "APPS/2162", "prompt": "def find_final_label_probabilities(n: int, edges: List[Tuple[int, int]]) -> List[float]:\n    \"\"\"\n    Consider a tree $T$ (that is, a connected graph without cycles) with $n$ vertices labelled $1$ through $n$. We start the following process with $T$: while $T$ has more than one vertex, do the following:\n    \n    \n    \n    choose a random edge of $T$ equiprobably;\n    \n    shrink the chosen edge: if the edge was connecting vertices $v$ and $u$, erase both $v$ and $u$ and create a new vertex adjacent to all vertices previously adjacent to either $v$ or $u$. The new vertex is labelled either $v$ or $u$ equiprobably.\n    \n    At the end of the process, $T$ consists of a single vertex labelled with one of the numbers $1, \\ldots, n$. For each of the numbers, what is the probability of this number becoming the label of the final vertex?\n    \n    \n    -----Input-----\n    \n    The first line contains a single integer $n$ ($1 \\leq n \\leq 50$).\n    \n    The following $n - 1$ lines describe the tree edges. Each of these lines contains two integers $u_i, v_i$\u00a0\u2014 labels of vertices connected by the respective edge ($1 \\leq u_i, v_i \\leq n$, $u_i \\neq v_i$). It is guaranteed that the given graph is a tree.\n    \n    \n    -----Output-----\n    \n    Print $n$ floating numbers\u00a0\u2014 the desired probabilities for labels $1, \\ldots, n$ respectively. All numbers should be correct up to $10^{-6}$ relative or absolute precision.\n    \n    \n    -----Examples-----\n    Input\n    4\n    1 2\n    1 3\n    1 4\n    \n    Output\n    0.1250000000\n    0.2916666667\n    0.2916666667\n    0.2916666667\n    \n    Input\n    7\n    1 2\n    1 3\n    2 4\n    2 5\n    3 6\n    3 7\n    \n    Output\n    0.0850694444\n    0.0664062500\n    0.0664062500\n    0.1955295139\n    0.1955295139\n    0.1955295139\n    0.1955295139\n    \n    \n    \n    -----Note-----\n    \n    In the first sample, the resulting vertex has label 1 if and only if for all three edges the label 1 survives, hence the probability is $1/2^3 = 1/8$. All other labels have equal probability due to symmetry, hence each of them has probability $(1 - 1/8) / 3 = 7/24$.\n    \"\"\"\n", "entry_point": "find_final_label_probabilities", "test": "\ndef check(find_final_label_probabilities):\n    assert find_final_label_probabilities(4, [(1, 2), (1, 3), (1, 4)]) == [0.1250000000, 0.2916666667, 0.2916666667, 0.2916666667]\n    assert find_final_label_probabilities(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == [0.0850694444, 0.0664062500, 0.0664062500, 0.1955295139, 0.1955295139, 0.1955295139, 0.1955295139]\n    assert find_final_label_probabilities(1, []) == [1.0000000000]\n    assert find_final_label_probabilities(10, [(9, 8), (7, 4), (10, 7), (6, 7), (1, 9), (4, 9), (9, 3), (2, 3), (1, 5)]) == [0.0716733902, 0.1568513416, 0.0716733902, 0.0513075087, 0.1568513416, 0.1496446398, 0.0462681362, 0.1274088542, 0.0186767578, 0.1496446398]\n    assert find_final_label_probabilities(20, [(13, 11), (4, 12), (17, 16), (15, 19), (16, 6), (7, 6), (6, 8), (12, 2), (19, 20), (1, 8), (4, 17), (18, 12), (9, 5), (14, 13), (11, 15), (1, 19), (3, 13), (4, 9), (15, 10)]) == [0.0241401787, 0.0917954309, 0.0976743034, 0.0150433990, 0.1006279377, 0.0150716827, 0.0758016731, 0.0241290115, 0.0444770708, 0.0796739239, 0.0310518413, 0.0248005499, 0.0287209519, 0.0976743034, 0.0160891602, 0.0248310267, 0.0253902066, 0.0917954309, 0.0146375074, 0.0765744099]\n    assert find_final_label_probabilities(30, [(15, 21), (21, 3), (22, 4), (5, 18), (26, 25), (12, 24), (11, 2), (27, 13), (11, 14), (7, 29), (10, 26), (16, 17), (16, 27), (16, 1), (3, 22), (5, 19), (2, 23), (4, 10), (8, 4), (1, 20), (30, 22), (9, 3), (28, 15), (23, 4), (4, 1), (2, 7), (5, 27), (6, 26), (6, 24)]) == [0.0047521072, 0.0089582002, 0.0091024503, 0.0005692947, 0.0158713738, 0.0231639046, 0.0280364616, 0.0385477047, 0.0508439275, 0.0104849699, 0.0280364616, 0.0756812249, 0.0527268460, 0.0663906850, 0.0348291400, 0.0067068947, 0.0473003760, 0.0620785158, 0.0620785158, 0.0431676433, 0.0225005681, 0.0055308416, 0.0101877956, 0.0354105896, 0.0520300528, 0.0099339742, 0.0093540308, 0.0748580820, 0.0663906850, 0.0444766827]\n    assert find_final_label_probabilities(2, [(2, 1)]) == [0.5000000000, 0.5000000000]\n    assert find_final_label_probabilities(3, [(2, 1), (3, 2)]) == [0.3750000000, 0.2500000000, 0.3750000000]\n    assert find_final_label_probabilities(4, [(3, 1), (3, 2), (2, 4)]) == [0.3125000000, 0.1875000000, 0.1875000000, 0.3125000000]\ncheck(find_final_label_probabilities)\n", "given_tests": ["assert find_final_label_probabilities(4, [(1, 2), (1, 3), (1, 4)]) == [0.1250000000, 0.2916666667, 0.2916666667, 0.2916666667]", "assert find_final_label_probabilities(7, [(1, 2), (1, 3), (2, 4), (2, 5), (3, 6), (3, 7)]) == [0.0850694444, 0.0664062500, 0.0664062500, 0.1955295139, 0.1955295139, 0.1955295139, 0.1955295139]"], "canonical_solution": "maxn=50+10\ng=[None]*maxn\ndp=[None]*maxn\nc=[None]*maxn\nsize=[0]*maxn\n\nfor i in range(0,maxn):\n    c[i]=[0]*maxn\n    c[i][0]=1\n    for j in range(1,i+1):\n        c[i][j]=c[i-1][j-1]+c[i-1][j]\n\nn=int(input())\nfor i in range(1,n+1):\n    g[i]=[]\nfor i in range(1,n):\n    u,v=input().split()\n    u=int(u)\n    v=int(v)\n    g[u].append(v)\n    g[v].append(u)\n\ndef mul(a,b,x,y):\n    tmp=[0]*(x+y+1)\n    for i in range(0,x+1):\n        for j in range(0,y+1):\n            tmp[i+j]+=a[i]*b[j]*c[i+j][i]*c[x+y-i-j][x-i]\n    return tmp\ndef dfs(pos,fa):\n    nonlocal dp\n    nonlocal size\n    dp[pos]=[1]\n    size[pos]=0\n    for ch in g[pos]:\n        if ch != fa:\n            dfs(pos=ch,fa=pos)\n            dp[pos]=mul(dp[pos],dp[ch],size[pos],size[ch])\n            size[pos]+=size[ch]\n    if fa:\n        size[pos]+=1\n        tmp=[0]*(size[pos]+1)\n        for i in range(0,size[pos]+1):\n            for j in range(0,size[pos]):\n                if j<i:\n                    tmp[i]+=dp[pos][i-1]\n                else:\n                    tmp[i]+=dp[pos][j]*0.5\n        dp[pos]=tmp\n\nfor i in range(1,n+1):\n    dfs(pos=i,fa=0)\n    tmp=dp[i][0]\n    for j in range(1,n):\n        tmp/=j\n    print(tmp)\n", "difficulty": "competition"}
{"task_id": "APPS/2126", "prompt": "def find_gcd_of_lcms(n: int, a: List[int]) -> int:\n    \"\"\"\n    For the multiset of positive integers $s=\\{s_1,s_2,\\dots,s_k\\}$, define the Greatest Common Divisor (GCD) and Least Common Multiple (LCM) of $s$ as follow: $\\gcd(s)$ is the maximum positive integer $x$, such that all integers in $s$ are divisible on $x$. $\\textrm{lcm}(s)$ is the minimum positive integer $x$, that divisible on all integers from $s$.\n    \n    For example, $\\gcd(\\{8,12\\})=4,\\gcd(\\{12,18,6\\})=6$ and $\\textrm{lcm}(\\{4,6\\})=12$. Note that for any positive integer $x$, $\\gcd(\\{x\\})=\\textrm{lcm}(\\{x\\})=x$.\n    \n    Orac has a sequence $a$ with length $n$. He come up with the multiset $t=\\{\\textrm{lcm}(\\{a_i,a_j\\})\\ |\\ i<j\\}$, and asked you to find the value of $\\gcd(t)$ for him. In other words, you need to calculate the GCD of LCMs of all pairs of elements in the given sequence.\n    \n    \n    -----Input-----\n    \n    The first line contains one integer $n\\ (2\\le n\\le 100\\,000)$.\n    \n    The second line contains $n$ integers, $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 200\\,000$).\n    \n    \n    -----Output-----\n    \n    Print one integer: $\\gcd(\\{\\textrm{lcm}(\\{a_i,a_j\\})\\ |\\ i<j\\})$.\n    \n    \n    -----Examples-----\n    Input\n    2\n    1 1\n    \n    Output\n    1\n    \n    Input\n    4\n    10 24 40 80\n    \n    Output\n    40\n    \n    Input\n    10\n    540 648 810 648 720 540 594 864 972 648\n    \n    Output\n    54\n    \n    \n    \n    -----Note-----\n    \n    For the first example, $t=\\{\\textrm{lcm}(\\{1,1\\})\\}=\\{1\\}$, so $\\gcd(t)=1$.\n    \n    For the second example, $t=\\{120,40,80,120,240,80\\}$, and it's not hard to see that $\\gcd(t)=40$.\n    \"\"\"\n", "entry_point": "find_gcd_of_lcms", "test": "\ndef check(find_gcd_of_lcms):\n    assert find_gcd_of_lcms(2, [1, 1]) == 1\n    assert find_gcd_of_lcms(4, [10, 24, 40, 80]) == 40\n    assert find_gcd_of_lcms(10, [540, 648, 810, 648, 720, 540, 594, 864, 972, 648]) == 54\n    assert find_gcd_of_lcms(2, [199999, 200000]) == 39999800000\n    assert find_gcd_of_lcms(2, [198761, 199999]) == 39752001239\n    assert find_gcd_of_lcms(10, [972, 972, 324, 972, 324, 648, 1944, 243, 324, 474]) == 162\n    assert find_gcd_of_lcms(3, [166299, 110866, 86856]) == 332598\n    assert find_gcd_of_lcms(2, [10007, 20014]) == 20014\n    assert find_gcd_of_lcms(2, [4, 6]) == 12\n    assert find_gcd_of_lcms(5, [25, 25, 5, 5, 5]) == 5\n    assert find_gcd_of_lcms(2, [3, 3]) == 3\ncheck(find_gcd_of_lcms)\n", "given_tests": ["assert find_gcd_of_lcms(2, [1, 1]) == 1", "assert find_gcd_of_lcms(4, [10, 24, 40, 80]) == 40", "assert find_gcd_of_lcms(10, [540, 648, 810, 648, 720, 540, 594, 864, 972, 648]) == 54"], "canonical_solution": "def find_gcd_of_lcms(n, a):\n    from math import gcd\n    lcm = a[0]\n    for i in range(1, n):\n        lcm = lcm * a[i] // gcd(lcm, a[i])\n    g = lcm\n    for i in range(1, n):\n        for j in range(i + 1, n):\n            g = gcd(g, a[i] * a[j] // gcd(a[i], a[j]))\n    return g\n", "difficulty": "competition"}
{"task_id": "APPS/2274", "prompt": "def construct_array(n: int, r: int, c: List[int], changes: List[Tuple[int, int]]) -> List[float]:\n    \"\"\"\n    Allen and Bessie are playing a simple number game. They both know a function $f: \\{0, 1\\}^n \\to \\mathbb{R}$, i.\u00a0e. the function takes $n$ binary arguments and returns a real value. At the start of the game, the variables $x_1, x_2, \\dots, x_n$ are all set to $-1$. Each round, with equal probability, one of Allen or Bessie gets to make a move. A move consists of picking an $i$ such that $x_i = -1$ and either setting $x_i \\to 0$ or $x_i \\to 1$.\n    \n    After $n$ rounds all variables are set, and the game value resolves to $f(x_1, x_2, \\dots, x_n)$. Allen wants to maximize the game value, and Bessie wants to minimize it.\n    \n    Your goal is to help Allen and Bessie find the expected game value! They will play $r+1$ times though, so between each game, exactly one value of $f$ changes. In other words, between rounds $i$ and $i+1$ for $1 \\le i \\le r$, $f(z_1, \\dots, z_n) \\to g_i$ for some $(z_1, \\dots, z_n) \\in \\{0, 1\\}^n$. You are to find the expected game value in the beginning and after each change.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers $n$ and $r$ ($1 \\le n \\le 18$, $0 \\le r \\le 2^{18}$).\n    \n    The next line contains $2^n$ integers $c_0, c_1, \\dots, c_{2^n-1}$ ($0 \\le c_i \\le 10^9$), denoting the initial values of $f$. More specifically, $f(x_0, x_1, \\dots, x_{n-1}) = c_x$, if $x = \\overline{x_{n-1} \\ldots x_0}$ in binary.\n    \n    Each of the next $r$ lines contains two integers $z$ and $g$ ($0 \\le z \\le 2^n - 1$, $0 \\le g \\le 10^9$). If $z = \\overline{z_{n-1} \\dots z_0}$ in binary, then this means to set $f(z_0, \\dots, z_{n-1}) \\to g$.\n    \n    \n    -----Output-----\n    \n    Print $r+1$ lines, the $i$-th of which denotes the value of the game $f$ during the $i$-th round. Your answer must have absolute or relative error within $10^{-6}$.\n    \n    Formally, let your answer be $a$, and the jury's answer be $b$. Your answer is considered correct if $\\frac{|a - b|}{\\max{(1, |b|)}} \\le 10^{-6}$.\n    \n    \n    -----Examples-----\n    Input\n    2 2\n    0 1 2 3\n    2 5\n    0 4\n    \n    Output\n    1.500000\n    2.250000\n    3.250000\n    \n    Input\n    1 0\n    2 3\n    \n    Output\n    2.500000\n    \n    Input\n    2 0\n    1 1 1 1\n    \n    Output\n    1.000000\n    \n    \n    \n    -----Note-----\n    \n    Consider the second test case. If Allen goes first, he will set $x_1 \\to 1$, so the final value will be $3$. If Bessie goes first, then she will set $x_1 \\to 0$ so the final value will be $2$. Thus the answer is $2.5$.\n    \n    In the third test case, the game value will always be $1$ regardless of Allen and Bessie's play.\n    \"\"\"\n", "entry_point": "construct_array", "test": "\ndef check(candidate):\n    assert construct_array(2, 2, [0, 1, 2, 3], [(2, 5), (0, 4)]) == [1.500000, 2.250000, 3.250000]\n    assert candidate(1, 0, [2, 3], []) == [2.500000]\n    assert construct_array(2, 0, [1, 1, 1, 1], []) == [1.000000]\ncheck(construct_array)\n", "given_tests": ["assert construct_array(2, 2, [0, 1, 2, 3], [(2, 5), (0, 4)]) == [1.500000, 2.250000, 3.250000]", "assert construct_array(1, 0, [2, 3], []) == [2.500000]", "assert construct_array(2, 0, [1, 1, 1, 1], []) == [1.000000]"], "canonical_solution": "def construct_array(n, r, c, changes):\n    res = []\n    n = 2 ** n\n    s = sum(c)\n    res.append(s / n)\n    for z, g in changes:\n        s += g - c[z]\n        c[z] = g\n        res.append(s / n)\n    return res\n", "difficulty": "competition"}
{"task_id": "APPS/2219", "prompt": "def coexist_in_peace(n: int, q: int, word: str, operations: List[Tuple[str, int, str]]) -> List[str]:\n    \"\"\"\n    During the archaeological research in the Middle East you found the traces of three ancient religions: First religion, Second religion and Third religion. You compiled the information on the evolution of each of these beliefs, and you now wonder if the followers of each religion could coexist in peace.\n    \n    The Word of Universe is a long word containing the lowercase English characters only. At each moment of time, each of the religion beliefs could be described by a word consisting of lowercase English characters.\n    \n    The three religions can coexist in peace if their descriptions form disjoint subsequences of the Word of Universe. More formally, one can paint some of the characters of the Word of Universe in three colors: $1$, $2$, $3$, so that each character is painted in at most one color, and the description of the $i$-th religion can be constructed from the Word of Universe by removing all characters that aren't painted in color $i$.\n    \n    The religions however evolve. In the beginning, each religion description is empty. Every once in a while, either a character is appended to the end of the description of a single religion, or the last character is dropped from the description. After each change, determine if the religions could coexist in peace.\n    \n    \n    -----Input-----\n    \n    The first line of the input contains two integers $n, q$ ($1 \\leq n \\leq 100\\,000$, $1 \\leq q \\leq 1000$) \u2014 the length of the Word of Universe and the number of religion evolutions, respectively. The following line contains the Word of Universe \u2014 a string of length $n$ consisting of lowercase English characters.\n    \n    Each of the following line describes a single evolution and is in one of the following formats:   + $i$ $c$ ($i \\in \\{1, 2, 3\\}$, $c \\in \\{\\mathtt{a}, \\mathtt{b}, \\dots, \\mathtt{z}\\}$: append the character $c$ to the end of $i$-th religion description.  - $i$ ($i \\in \\{1, 2, 3\\}$) \u2013 remove the last character from the $i$-th religion description. You can assume that the pattern is non-empty.\n    \n    You can assume that no religion will have description longer than $250$ characters.\n    \n    \n    -----Output-----\n    \n    Write $q$ lines. The $i$-th of them should be YES if the religions could coexist in peace after the $i$-th evolution, or NO otherwise.\n    \n    You can print each character in any case (either upper or lower).\n    \n    \n    -----Examples-----\n    Input\n    6 8\n    abdabc\n    + 1 a\n    + 1 d\n    + 2 b\n    + 2 c\n    + 3 a\n    + 3 b\n    + 1 c\n    - 2\n    \n    Output\n    YES\n    YES\n    YES\n    YES\n    YES\n    YES\n    NO\n    YES\n    \n    Input\n    6 8\n    abbaab\n    + 1 a\n    + 2 a\n    + 3 a\n    + 1 b\n    + 2 b\n    + 3 b\n    - 1\n    + 2 z\n    \n    Output\n    YES\n    YES\n    YES\n    YES\n    YES\n    NO\n    YES\n    NO\n    \n    \n    \n    -----Note-----\n    \n    In the first example, after the 6th evolution the religion descriptions are: ad, bc, and ab. The following figure shows how these descriptions form three disjoint subsequences of the Word of Universe: $\\left. \\begin{array}{|c|c|c|c|c|c|c|} \\hline \\text{Word} & {a} & {b} & {d} & {a} & {b} & {c} \\\\ \\hline ad & {a} & {} & {d} & {} & {} & {} \\\\ \\hline bc & {} & {b} & {} & {} & {} & {c} \\\\ \\hline ab & {} & {} & {} & {a} & {b} & {} \\\\ \\hline \\end{array} \\right.$\n    \"\"\"\n", "entry_point": "coexist_in_peace", "test": "\ndef check(candidate):\n    assert coexist_in_peace(6, 8, 'abdabc', [('+', 1, 'a'), ('+', 1, 'd'), ('+', 2, 'b'), ('+', 2, 'c'), ('+', 3, 'a'), ('+', 3, 'b'), ('+', 1, 'c'), ('-', 2)]) == ['YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES']\n    assert coexist_in_peace(6, 8, 'abbaab', [('+', 1, 'a'), ('+', 2, 'a'), ('+', 3, 'a'), ('+', 1, 'b'), ('+', 2, 'b'), ('+', 3, 'b'), ('-', 1), ('+', 2, 'z')]) == ['YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO']\n    assert coexist_in_peace(1, 1, 'z', [('+', 3, 'z')]) == ['YES']\n    assert coexist_in_peace(1, 1, 't', [('+', 2, 'p')]) == ['NO']\n    assert coexist_in_peace(2, 12, 'aa', [('+', 1, 'a'), ('+', 2, 'a'), ('+', 3, 'a'), ('-', 1), ('+', 1, 'a'), ('-', 2), ('+', 2, 'a'), ('-', 3), ('+', 3, 'a'), ('+', 2, 'a'), ('-', 1), ('-', 3)]) == ['YES', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'YES', 'NO', 'NO', 'NO', 'YES']\n    assert coexist_in_peace(2, 10, 'uh', [('+', 1, 'h'), ('+', 2, 'u'), ('+', 3, 'h'), ('-', 1), ('-', 2), ('+', 2, 'h'), ('+', 3, 'u'), ('-', 2), ('+', 1, 'u'), ('-', 3)]) == ['YES', 'YES', 'NO', 'YES', 'YES', 'NO', 'NO', 'NO', 'NO', 'YES']\ncheck(coexist_in_peace)\n", "given_tests": ["assert coexist_in_peace(6, 8, 'abdabc', [('+', 1, 'a'), ('+', 1, 'd'), ('+', 2, 'b'), ('+', 2, 'c'), ('+', 3, 'a'), ('+', 3, 'b'), ('+', 1, 'c'), ('-', 2)]) == ['YES', 'YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES']", "assert coexist_in_peace(6, 8, 'abbaab', [('+', 1, 'a'), ('+', 2, 'a'), ('+', 3, 'a'), ('+', 1, 'b'), ('+', 2, 'b'), ('+', 3, 'b'), ('-', 1), ('+', 2, 'z')]) == ['YES', 'YES', 'YES', 'YES', 'YES', 'NO', 'YES', 'NO']"], "canonical_solution": "n, q = map(int, input().split())\ns = '!' + input()\n\nnxt = [[n + 1] * (n + 2) for _ in range(26)]\nfor i in range(n - 1, -1, -1):\n    c = ord(s[i + 1]) - 97\n    for j in range(26):\n        nxt[j][i] = nxt[j][i + 1]\n    nxt[c][i] = i + 1\n\nw = [[-1], [-1], [-1]]\nidx = lambda i, j, k: i * 65536 + j * 256 + k\ndp = [0] * (256 * 256 * 256)\ndef calc(fix=None):\n    r = list(map(range, (len(w[0]), len(w[1]), len(w[2]))))\n    if fix is not None: r[fix] = range(len(w[fix]) - 1, len(w[fix]))\n    for i in r[0]:\n        for j in r[1]:\n            for k in r[2]:\n                dp[idx(i, j, k)] = min(nxt[w[0][i]][dp[idx(i - 1, j, k)]] if i else n + 1,\n                                       nxt[w[1][j]][dp[idx(i, j - 1, k)]] if j else n + 1,\n                                       nxt[w[2][k]][dp[idx(i, j, k - 1)]] if k else n + 1)\n                if i == j == k == 0: dp[idx(i, j, k)] = 0\n\nout = []\nfor _ in range(q):\n    t, *r = input().split()\n    if t == '+':\n        i, c = int(r[0]) - 1, ord(r[1]) - 97\n        w[i].append(c)\n        calc(i)\n    else:\n        i = int(r[0]) - 1\n        w[i].pop()\n    req = dp[idx(len(w[0]) - 1, len(w[1]) - 1, len(w[2]) - 1)]\n    out.append('YES' if req <= n else 'NO')\n\nprint(*out, sep='\\n')", "difficulty": "competition"}
{"task_id": "APPS/2060", "prompt": "def min_processing_time(n: int, k: int, contrasts: List[int]) -> int:\n    \"\"\"\n    Evlampiy has found one more cool application to process photos. However the application has certain limitations.\n    \n    Each photo i has a contrast v_{i}. In order for the processing to be truly of high quality, the application must receive at least k photos with contrasts which differ as little as possible.\n    \n    Evlampiy already knows the contrast v_{i} for each of his n photos. Now he wants to split the photos into groups, so that each group contains at least k photos. As a result, each photo must belong to exactly one group.\n    \n    He considers a processing time of the j-th group to be the difference between the maximum and minimum values of v_{i} in the group. Because of multithreading the processing time of a division into groups is the maximum processing time among all groups.\n    \n    Split n photos into groups in a such way that the processing time of the division is the minimum possible, i.e. that the the maximum processing time over all groups as least as possible.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers n and k (1 \u2264 k \u2264 n \u2264 3\u00b710^5) \u2014 number of photos and minimum size of a group.\n    \n    The second line contains n integers v_1, v_2, ..., v_{n} (1 \u2264 v_{i} \u2264 10^9), where v_{i} is the contrast of the i-th photo.\n    \n    \n    -----Output-----\n    \n    Print the minimal processing time of the division into groups.\n    \n    \n    -----Examples-----\n    Input\n    5 2\n    50 110 130 40 120\n    \n    Output\n    20\n    \n    Input\n    4 1\n    2 3 4 1\n    \n    Output\n    0\n    \n    \n    \n    -----Note-----\n    \n    In the first example the photos should be split into 2 groups: [40, 50] and [110, 120, 130]. The processing time of the first group is 10, and the processing time of the second group is 20. Maximum among 10 and 20 is 20. It is impossible to split the photos into groups in a such way that the processing time of division is less than 20.\n    \n    In the second example the photos should be split into four groups, each containing one photo. So the minimal possible processing time of a division is 0.\n    \"\"\"\n", "entry_point": "min_processing_time", "test": "\ndef check(candidate):\n    assert min_processing_time(5, 2, [50, 110, 130, 40, 120]) == 20\n    assert min_processing_time(4, 1, [2, 3, 4, 1]) == 0\n    assert min_processing_time(1, 1, [4]) == 0\n    assert min_processing_time(2, 2, [7, 5]) == 2\n    assert candidate(3, 2, [34, 3, 75]) == 72\n    assert min_processing_time(5, 2, [932, 328, 886, 96, 589]) == 343\n    assert min_processing_time(10, 4, [810, 8527, 9736, 3143, 2341, 6029, 7474, 707, 2513, 2023]) == 3707\n    assert min_processing_time(20, 11, [924129, 939902, 178964, 918687, 720767, 695035, 577430, 407131, 213304, 810868, 596349, 266075, 123602, 376312, 36680, 18426, 716200, 121546, 61834, 851586]) == 921476\n    assert min_processing_time(100, 28, [1, 2, 3, 5, 1, 1, 1, 4, 1, 5, 2, 4, 3, 2, 5, 4, 1, 1, 4, 1, 4, 5, 4, 1, 4, 5, 1, 3, 5, 1, 1, 1, 4, 2, 5, 2, 3, 5, 2, 2, 3, 2, 4, 5, 5, 5, 5, 1, 2, 4, 1, 3, 1, 1, 1, 4, 3, 1, 5, 2, 5, 1, 3, 3, 2, 4, 5, 1, 1, 3, 4, 1, 1, 3, 3, 1, 2, 4, 3, 3, 4, 4, 3, 1, 2, 1, 5, 1, 4, 4, 2, 3, 1, 3, 3, 4, 2, 4, 1, 1]) == 1\n    assert min_processing_time(101, 9, [3, 2, 2, 1, 4, 1, 3, 2, 3, 4, 3, 2, 3, 1, 4, 4, 1, 1, 4, 1, 3, 3, 4, 1, 2, 1, 1, 3, 1, 2, 2, 4, 3, 1, 4, 3, 1, 1, 4, 4, 1, 2, 1, 1, 4, 2, 3, 4, 1, 2, 1, 4, 4, 1, 4, 3, 1, 4, 2, 1, 2, 1, 4, 3, 4, 3, 4, 2, 2, 4, 3, 2, 1, 3, 4, 3, 2, 2, 4, 3, 3, 2, 4, 1, 3, 2, 2, 4, 1, 3, 4, 2, 1, 3, 3, 2, 2, 1, 1, 3, 1]) == 0\n    assert min_processing_time(2, 2, [1, 1000000000]) == 999999999\n    assert min_processing_time(2, 1, [1, 1000000000]) == 0\n    assert min_processing_time(11, 3, [412, 3306, 3390, 2290, 1534, 316, 1080, 2860, 253, 230, 3166]) == 1122\n    assert min_processing_time(10, 3, [2414, 294, 184, 666, 2706, 1999, 2201, 1270, 904, 653]) == 707\n    assert min_processing_time(24, 4, [33, 27, 12, 65, 19, 6, 46, 33, 57, 2, 21, 50, 73, 13, 59, 69, 51, 45, 39, 1, 6, 64, 39, 27]) == 9\ncheck(min_processing_time)\n", "given_tests": ["assert min_processing_time(5, 2, [50, 110, 130, 40, 120]) == 20", "assert min_processing_time(4, 1, [2, 3, 4, 1]) == 0"], "canonical_solution": "def min_processing_time(n, k, v):\n    def f(m):\n        nonlocal dp, sdp\n        l = 0\n        for i in range(n):\n            while l < n and v[l] < v[i] - m:\n                l += 1\n            if l - 1 > i - k:\n                dp[i] = False\n            else:\n                dp[i] = (sdp[i - k + 1] != sdp[l - 1])\n            sdp[i + 1] = sdp[i] + (1 if dp[i] else 0)\n        return dp[n - 1]\n\n    dp = [False for _ in range(n + 2)]\n    sdp = [0 for _ in range(n + 2)]\n    dp[-1] = True\n    sdp[0] = 1\n    v.sort()\n    le = -1\n    r = v[-1] - v[0]\n    while r - le > 1:\n        m = (r + le) // 2\n        if f(m):\n            r = m\n        else:\n            le = m\n    return r\n", "difficulty": "competition"}
{"task_id": "APPS/2228", "prompt": "def max_trip_people(n: int, m: int, k: int, friendships: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    There are $n$ persons who initially don't know each other. On each morning, two of them, who were not friends before, become friends.\n    \n    We want to plan a trip for every evening of $m$ days. On each trip, you have to select a group of people that will go on the trip. For every person, one of the following should hold:   Either this person does not go on the trip,  Or at least $k$ of his friends also go on the trip.\n    \n    Note that the friendship is not transitive. That is, if $a$ and $b$ are friends and $b$ and $c$ are friends, it does not necessarily imply that $a$ and $c$ are friends.\n    \n    For each day, find the maximum number of people that can go on the trip on that day.\n    \n    \n    -----Input-----\n    \n    The first line contains three integers $n$, $m$, and $k$ ($2 \\leq n \\leq 2 \\cdot 10^5, 1 \\leq m \\leq 2 \\cdot 10^5$, $1 \\le k < n$)\u00a0\u2014 the number of people, the number of days and the number of friends each person on the trip should have in the group.\n    \n    The $i$-th ($1 \\leq i \\leq m$) of the next $m$ lines contains two integers $x$ and $y$ ($1\\leq x, y\\leq n$, $x\\ne y$), meaning that persons $x$ and $y$ become friends on the morning of day $i$. It is guaranteed that $x$ and $y$ were not friends before.\n    \n    \n    -----Output-----\n    \n    Print exactly $m$ lines, where the $i$-th of them ($1\\leq i\\leq m$) contains the maximum number of people that can go on the trip on the evening of the day $i$.\n    \n    \n    -----Examples-----\n    Input\n    4 4 2\n    2 3\n    1 2\n    1 3\n    1 4\n    \n    Output\n    0\n    0\n    3\n    3\n    \n    Input\n    5 8 2\n    2 1\n    4 2\n    5 4\n    5 2\n    4 3\n    5 1\n    4 1\n    3 2\n    \n    Output\n    0\n    0\n    0\n    3\n    3\n    4\n    4\n    5\n    \n    Input\n    5 7 2\n    1 5\n    3 2\n    2 5\n    3 4\n    1 2\n    5 3\n    1 3\n    \n    Output\n    0\n    0\n    0\n    0\n    3\n    4\n    4\n    \n    \n    \n    -----Note-----\n    \n    In the first example,   $1,2,3$ can go on day $3$ and $4$.\n    \n    In the second example,   $2,4,5$ can go on day $4$ and $5$.  $1,2,4,5$ can go on day $6$ and $7$.  $1,2,3,4,5$ can go on day $8$.\n    \n    In the third example,   $1,2,5$ can go on day $5$.  $1,2,3,5$ can go on day $6$ and $7$.\n    \"\"\"\n", "entry_point": "max_trip_people", "test": "\ndef check(candidate):\n    assert candidate(4, 4, 2, [(2, 3), (1, 2), (1, 3), (1, 4)]) == [0, 0, 3, 3]\n    assert candidate(5, 8, 2, [(2, 1), (4, 2), (5, 4), (5, 2), (4, 3), (5, 1), (4, 1), (3, 2)]) == [0, 0, 0, 3, 3, 4, 4, 5]\n    assert candidate(5, 7, 2, [(1, 5), (3, 2), (2, 5), (3, 4), (1, 2), (5, 3), (1, 3)]) == [0, 0, 0, 0, 3, 4, 4]\n    assert candidate(2, 1, 1, [(2, 1)]) == [2]\n    assert candidate(16, 20, 2, [(10, 3), (5, 3), (10, 5), (12, 7), (7, 6), (9, 12), (9, 6), (1, 10), (11, 16), (11, 1), (16, 2), (10, 2), (14, 4), (15, 14), (4, 13), (13, 15), (1, 8), (7, 15), (1, 7), (8, 15)]) == [0, 0, 3, 3, 3, 3, 7, 7, 7, 7, 7, 7, 11, 11, 11, 11, 15, 15, 15, 16]\ncheck(max_trip_people)\n", "given_tests": ["assert max_trip_people(4, 4, 2, [(2, 3), (1, 2), (1, 3), (1, 4)]) == [0, 0, 3, 3]", "assert max_trip_people(5, 8, 2, [(2, 1), (4, 2), (5, 4), (5, 2), (4, 3), (5, 1), (4, 1), (3, 2)]) == [0, 0, 0, 3, 3, 4, 4, 5]", "assert max_trip_people(5, 7, 2, [(1, 5), (3, 2), (2, 5), (3, 4), (1, 2), (5, 3), (1, 3)]) == [0, 0, 0, 0, 3, 4, 4]"], "canonical_solution": "[\"from collections import deque\\n\\ndef solve(adj, m, k, uv):\\n    n = len(adj)\\n    nn = [len(a) for a in adj]\\n    q = deque()\\n    for i in range(n):\\n        if nn[i] < k:\\n            q.append(i)\\n    while q:\\n        v = q.popleft()\\n        for u in adj[v]:\\n            nn[u] -= 1\\n            if nn[u] == k-1:\\n                q.append(u)\\n    res = [0]*m\\n    nk = len([1 for i in nn if i >= k])\\n    res[-1] = nk\\n    for i in range(m-1, 0, -1):\\n        u1, v1 = uv[i]\\n\\n        if nn[u1] < k or nn[v1] < k:\\n            res[i - 1] = nk\\n            continue\\n        if nn[u1] == k:\\n            q.append(u1)\\n            nn[u1] -= 1\\n        if not q and nn[v1] == k:\\n            q.append(v1)\\n            nn[v1] -= 1\\n\\n        if not q:\\n            nn[u1] -= 1\\n            nn[v1] -= 1\\n            adj[u1].remove(v1)\\n            adj[v1].remove(u1)\\n\\n        while q:\\n            v = q.popleft()\\n            nk -= 1\\n            for u in adj[v]:\\n                nn[u] -= 1\\n                if nn[u] == k - 1:\\n                    q.append(u)\\n        res[i - 1] = nk\\n    return res\\n\\nn, m, k = map(int, input().split())\\na = [set() for i in range(n)]\\nuv = []\\nfor i in range(m):\\n    u, v = map(int, input().split())\\n    a[u - 1].add(v - 1)\\n    a[v - 1].add(u - 1)\\n    uv.append((u-1, v-1))\\n\\nres = solve(a, m, k, uv)\\nprint(str(res)[1:-1].replace(' ', '').replace(',', '\\\\n'))\"]", "difficulty": "competition"}
{"task_id": "APPS/2031", "prompt": "def color_cells(n: int, m: int, l: List[int]) -> Union[List[int], int]:\n    \"\"\"\n    Dreamoon likes coloring cells very much.\n    \n    There is a row of $n$ cells. Initially, all cells are empty (don't contain any color). Cells are numbered from $1$ to $n$.\n    \n    You are given an integer $m$ and $m$ integers $l_1, l_2, \\ldots, l_m$ ($1 \\le l_i \\le n$)\n    \n    Dreamoon will perform $m$ operations.\n    \n    In $i$-th operation, Dreamoon will choose a number $p_i$ from range $[1, n-l_i+1]$ (inclusive) and will paint all cells from $p_i$ to $p_i+l_i-1$ (inclusive) in $i$-th color. Note that cells may be colored more one than once, in this case, cell will have the color from the latest operation.\n    \n    Dreamoon hopes that after these $m$ operations, all colors will appear at least once and all cells will be colored. Please help Dreamoon to choose $p_i$ in each operation to satisfy all constraints.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers $n,m$ ($1 \\leq m \\leq n \\leq 100\\,000$).\n    \n    The second line contains $m$ integers $l_1, l_2, \\ldots, l_m$ ($1 \\leq l_i \\leq n$).\n    \n    \n    -----Output-----\n    \n    If it's impossible to perform $m$ operations to satisfy all constraints, print \"'-1\" (without quotes).\n    \n    Otherwise, print $m$ integers $p_1, p_2, \\ldots, p_m$ ($1 \\leq p_i \\leq n - l_i + 1$), after these $m$ operations, all colors should appear at least once and all cells should be colored.\n    \n    If there are several possible solutions, you can print any.\n    \n    \n    -----Examples-----\n    \n    Input\n    5 3\n    3 2 2\n    \n    Output\n    2 4 1\n    \n    Input\n    10 1\n    1\n    \n    Output\n    -1\n    \"\"\"\n", "entry_point": "color_cells", "test": "\ndef check(candidate):\n    assert color_cells(5, 3, [3, 2, 2]) == [2, 4, 1]\n    assert color_cells(10, 1, [1]) == -1\n    assert color_cells(1, 1, [1]) == [1]\n    assert color_cells(2, 2, [1, 2]) == -1\n    assert color_cells(200, 50, [49, 35, 42, 47, 134, 118, 14, 148, 58, 159, 33, 33, 8, 123, 99, 126, 75, 94, 1, 141, 61, 79, 122, 31, 48, 7, 66, 97, 141, 43, 25, 141, 7, 56, 120, 55, 49, 37, 154, 56, 13, 59, 153, 133, 18, 1, 141, 24, 151, 125]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 76]\n    assert color_cells(3, 3, [3, 3, 1]) == -1\n    assert color_cells(100000, 1, [100000]) == [1]\n    assert color_cells(2000, 100, [5, 128, 1368, 1679, 1265, 313, 1854, 1512, 1924, 338, 38, 1971, 238, 1262, 1834, 1878, 1749, 784, 770, 1617, 191, 395, 303, 214, 1910, 1300, 741, 1966, 1367, 24, 268, 403, 1828, 1033, 1424, 218, 1146, 925, 1501, 1760, 1164, 1881, 1628, 1596, 1358, 1360, 29, 1343, 922, 618, 1537, 1839, 1114, 1381, 704, 464, 692, 1450, 1590, 1121, 670, 300, 1053, 1730, 1024, 1292, 1549, 1112, 1028, 1096, 794, 38, 1121, 261, 618, 1489, 587, 1841, 627, 707, 1693, 1693, 1867, 1402, 803, 321, 475, 410, 1664, 1491, 1846, 1279, 1250, 457, 1010, 518, 1785, 514, 1656, 1588]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 29, 30, 31, 32, 33, 34, 35, 36, 37, 38, 39, 40, 41, 42, 43, 44, 45, 46, 47, 48, 49, 50, 51, 52, 53, 54, 55, 56, 57, 58, 59, 60, 61, 62, 63, 64, 65, 66, 67, 68, 69, 70, 71, 72, 73, 74, 75, 76, 77, 78, 79, 80, 81, 82, 83, 84, 85, 86, 87, 88, 89, 90, 91, 92, 93, 94, 95, 96, 97, 98, 99, 413]\n    assert color_cells(10000, 3, [3376, 5122, 6812]) == [1, 2, 3189]\n    assert color_cells(99999, 30, [31344, 14090, 93157, 5965, 57557, 41264, 93881, 58871, 57763, 46958, 96029, 37297, 75623, 12215, 38442, 86773, 66112, 7512, 31968, 28331, 90390, 79301, 56205, 704, 15486, 63054, 83372, 45602, 15573, 78459]) == [1, 2, 3, 4, 5, 6, 7, 8, 9, 10, 11, 12, 13, 14, 15, 16, 17, 18, 19, 20, 21, 22, 23, 24, 25, 26, 27, 28, 5968, 21541]\n    assert color_cells(100000, 10, [31191, 100000, 99999, 99999, 99997, 100000, 99996, 99994, 99995, 99993]) == -1\n    assert color_cells(1000, 2, [1, 1]) == -1\n    assert color_cells(10, 3, [1, 9, 2]) == [1, 2, 9]\n    assert color_cells(6, 3, [2, 2, 6]) == -1\n    assert color_cells(100, 3, [45, 10, 45]) == [1, 46, 56]\n    assert color_cells(6, 3, [1, 2, 2]) == -1\n    assert color_cells(9, 3, [9, 3, 1]) == [1, 6, 9]\ncheck(color_cells)\n", "given_tests": ["assert color_cells(5, 3, [3, 2, 2]) == [1, 2, 4]", "assert color_cells(10, 1, [1]) == -1"], "canonical_solution": "[\"def main():\\n    import sys\\n    input = sys.stdin.readline\\n\\n    N, M = list(map(int, input().split()))\\n    L = list(map(int, input().split()))\\n\\n    if sum(L) < N:\\n        print(-1)\\n        return\\n\\n    ans = [0] * M\\n    left = N\\n    for i in range(M-1, -1, -1):\\n        if left - L[i] >= i:\\n            ans[i] = left - L[i] + 1\\n            left -= L[i]\\n        else:\\n            if i+L[i]-1 >= N:\\n                print(-1)\\n                return\\n            ans[i] = i+1\\n            left = i\\n    print(*ans)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\", \"from sys import stdin\\ninput = stdin.readline\\nn,m = map(int,input().split())\\nl = list(map(int,input().split()))\\nx = sum(l)\\nif x < n:\\n\\tprint(-1)\\nelse:\\n\\tdasie = True\\n\\tfor i in range(m):\\n\\t\\tif l[i] > n-i:\\n\\t\\t\\tdasie = False\\n\\tif not dasie:\\n\\t\\tprint(-1)\\n\\telse:\\n\\t\\todp = [1]\\n\\t\\tcyk = 1\\n\\t\\twhile cyk < m:\\n\\t\\t\\tx -= l[cyk-1]\\n\\t\\t\\todp.append(max(odp[-1]+1, n+1-x))\\n\\t\\t\\tcyk += 1\\n\\t\\tprint(*odp)\", \"n,m = [int(i) for i in input().split()]\\na = [int(i) for i in input().split()]\\ns = sum(a)\\nif s < n:\\n    print(-1)\\nelse:\\n    r = []\\n    diff = s-n\\n    curr = 0\\n    valid = True\\n    for i in range(m):\\n        r.append(curr+1)\\n        curr += a[i]\\n        if curr>n:\\n            valid = False\\n        d = min(diff,a[i]-1)\\n        curr -= d\\n        diff -= d\\n    if valid:\\n        print(*r)\\n    else:\\n        print(-1)\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2278", "prompt": "def count_u_shaped_parabolas(n: int, points: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    Recently Vasya learned that, given two points with different $x$ coordinates, you can draw through them exactly one parabola with equation of type $y = x^2 + bx + c$, where $b$ and $c$ are reals. Let's call such a parabola an $U$-shaped one.\n    \n    Vasya drew several distinct points with integer coordinates on a plane and then drew an $U$-shaped parabola through each pair of the points that have different $x$ coordinates. The picture became somewhat messy, but Vasya still wants to count how many of the parabolas drawn don't have any drawn point inside their internal area. Help Vasya.\n    \n    The internal area of an $U$-shaped parabola is the part of the plane that lies strictly above the parabola when the $y$ axis is directed upwards.\n    \n    \n    -----Input-----\n    \n    The first line contains a single integer $n$ ($1 \\le n \\le 100\\,000$)\u00a0\u2014 the number of points.\n    \n    The next $n$ lines describe the points, the $i$-th of them contains two integers $x_i$ and $y_i$\u00a0\u2014 the coordinates of the $i$-th point. It is guaranteed that all points are distinct and that the coordinates do not exceed $10^6$ by absolute value.\n    \n    \n    -----Output-----\n    \n    In the only line print a single integer\u00a0\u2014 the number of $U$-shaped parabolas that pass through at least two of the given points and do not contain any of the given points inside their internal area (excluding the parabola itself).\n    \n    \n    -----Examples-----\n    Input\n    3\n    -1 0\n    0 2\n    1 0\n    \n    Output\n    2\n    \n    Input\n    5\n    1 0\n    1 -1\n    0 -1\n    -1 0\n    -1 -1\n    \n    Output\n    1\n    \n    \n    \n    -----Note-----\n    \n    On the pictures below all $U$-shaped parabolas that pass through at least two given points are drawn for each of the examples. The $U$-shaped parabolas that do not have any given point inside their internal area are drawn in red.  [Image] The first example.\n    \n    [Image] The second example.\n    \"\"\"\n", "entry_point": "count_u_shaped_parabolas", "test": "\ndef check(candidate):\n    assert count_u_shaped_parabolas(3, [(-1, 0), (0, 2), (1, 0)]) == 2\n    assert count_u_shaped_parabolas(5, [(1, 0), (1, -1), (0, -1), (-1, 0), (-1, -1)]) == 1\n    assert count_u_shaped_parabolas(1, [(-751115, -925948)]) == 0\ncheck(count_u_shaped_parabolas)\n", "given_tests": ["assert count_u_shaped_parabolas(3, [(-1, 0), (0, 2), (1, 0)]) == 2", "assert count_u_shaped_parabolas(5, [(1, 0), (1, -1), (0, -1), (-1, 0), (-1, -1)]) == 1"], "canonical_solution": "[\"n = int(input())\\nrows = [input().split() for _ in range(n)]\\nrows = [(int(x),int(y)) for x,y in rows]\\npoints = {}\\nfor x,y in rows:\\n    if x in points:\\n        points[x] = max(y, points[x])\\n    else:\\n        points[x] = y\\npoints are sorted(points.items(),key=lambda point: point[0])\\n\\n\\ndef above(p,p1,p2):\\n    \\\"\\\"\\\"\\n    x1 < x2\\n    y1 = x1^2 + bx1 + c\\n    y2 = x2^2 + bx2 + c\\n    y >? x^2 + bx + c\\n\\n    y2 - y1 = x2^2 - x1^2 + bx2 - bx1\\n    b = (y2 - y1 - x2^2 + x1^2) / (x2 - x1)\\n    b * (x2 - x1) = y2 - y1 - x2^2 + x1^2\\n\\n    c = y1 - x1^2 - bx1\\n    c * (x2 - x1) = (y1 - x1^2) * (x2 - x1) - x1 * (y2 - y1 - x2^2 + x1^2)\\n\\n    y * (x2 - x1) >? (x^2 + bx + c) * (x2 - x1)\\n    y * (x2 - x1) >?\\n        x^2 * (x2 - x1)\\n        + x * (y2 - y1 - x2^2 + x1^2)\\n        + (y1 - x1^2) * (x2 - x1) - x1 * (y2 - y1 - x2^2 + x1^2)\\n    \\\"\\\"\\\"\\n    x,y = p\\n    x1,y1 = p1\\n    x2,y2 = p2\\n\\n    x_2 = x**2\\n    x12 = x1**2\\n    x22 = x2**2\\n    x2_x1 = x2 - x1\\n    eq_b = y2 - y1 - x22 + x12\\n\\n    term_y = y * x2_x1\\n    term_x2 = x_2 * x2_x1\\n    term_x = x * eq_b\\n    term_c = (y1 - x12) * x2_x1 - (x1 * eq_b)\\n\\n    return term_y >= term_x2 + term_x + term_c\\n\\n#print(above(points[2],points[0],points[1]))\\n\\n\\nUs = []\\nfor i, p in enumerate(points):\\n    while len(Us) >= 2:\\n        p1, p2 = Us[-2:]\\n        if above(p,p1,p2):\\n            Us.pop()\\n        else:\\n            break\\n    Us.append(p)\\n\\nout = len(Us) - 1\\nprint(out)\"]", "difficulty": "competition"}
{"task_id": "APPS/2136", "prompt": "def max_non_overlapping_dominos(n: int, heights: List[int]) -> int:\n    \"\"\"\n    You are given a Young diagram.\n    \n    Given diagram is a histogram with $n$ columns of lengths $a_1, a_2, \\ldots, a_n$ ($a_1 \\geq a_2 \\geq \\ldots \\geq a_n \\geq 1$). [Image] Young diagram for $a=[3,2,2,2,1]$.\n    \n    Your goal is to find the largest number of non-overlapping dominos that you can draw inside of this histogram, a domino is a $1 \\times 2$ or $2 \\times 1$ rectangle.\n    \n    \n    -----Input-----\n    \n    The first line of input contain one integer $n$ ($1 \\leq n \\leq 300\\,000$): the number of columns in the given histogram.\n    \n    The next line of input contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($1 \\leq a_i \\leq 300\\,000, a_i \\geq a_{i+1}$): the lengths of columns.\n    \n    \n    -----Output-----\n    \n    Output one integer: the largest number of non-overlapping dominos that you can draw inside of the given Young diagram.\n    \n    \n    -----Example-----\n    Input\n    5\n    3 2 2 2 1\n    \n    Output\n    4\n    \n    \n    \n    -----Note-----\n    \n    Some of the possible solutions for the example:\n    \n    [Image] $\\square$\n    \"\"\"\n", "entry_point": "max_non_overlapping_dominos", "test": "\ndef check(candidate):\n    assert max_non_overlapping_dominos(5, [3, 2, 2, 2, 1]) == 4\n    assert max_non_overlapping_dominos(5, [1, 1, 1, 1, 1]) == 2\n    assert max_non_overlapping_dominos(3, [3, 3, 3]) == 4\n    assert max_non_overlapping_dominos(1, [1]) == 0\n    assert max_non_overlapping_dominos(10, [9, 8, 7, 7, 6, 4, 3, 2, 1, 1]) == 23\n    assert max_non_overlapping_dominos(10, [99, 83, 62, 53, 47, 33, 24, 15, 10, 9]) == 216\n    assert max_non_overlapping_dominos(100, [100, 100, 99, 98, 97, 92, 92, 92, 92, 91, 89, 87, 87, 87, 86, 85, 84, 82, 82, 81, 81, 80, 79, 78, 78, 77, 77, 76, 76, 74, 72, 71, 71, 70, 69, 66, 64, 63, 63, 62, 60, 59, 59, 59, 55, 54, 53, 52, 52, 51, 49, 49, 49, 47, 47, 46, 46, 45, 44, 43, 42, 41, 41, 41, 40, 39, 38, 37, 37, 36, 31, 29, 25, 23, 22, 22, 21, 21, 20, 17, 17, 16, 15, 15, 14, 14, 13, 12, 12, 10, 9, 9, 8, 8, 8, 7, 4, 3, 3, 3]) == 2545\n    assert max_non_overlapping_dominos(100, [494, 493, 483, 483, 482, 479, 469, 455, 452, 448, 446, 437, 436, 430, 426, 426, 423, 418, 417, 413, 409, 403, 402, 398, 388, 386, 384, 379, 373, 372, 366, 354, 353, 347, 344, 338, 325, 323, 323, 322, 310, 306, 303, 302, 299, 296, 291, 290, 288, 285, 281, 274, 258, 254, 253, 250, 248, 248, 247, 243, 236, 235, 233, 227, 227, 223, 208, 204, 200, 196, 192, 191, 185, 184, 183, 174, 167, 167, 165, 163, 158, 139, 138, 132, 123, 122, 111, 91, 89, 88, 83, 62, 60, 58, 45, 39, 38, 34, 26, 3]) == 13710\n    assert max_non_overlapping_dominos(100, [1980, 1932, 1906, 1898, 1892, 1883, 1877, 1858, 1842, 1833, 1777, 1710, 1689, 1678, 1660, 1653, 1648, 1647, 1644, 1639, 1635, 1635, 1593, 1571, 1534, 1470, 1440, 1435, 1389, 1272, 1269, 1268, 1263, 1255, 1249, 1237, 1174, 1174, 1128, 1069, 1067, 981, 979, 979, 951, 915, 911, 906, 863, 826, 810, 810, 802, 785, 764, 752, 743, 710, 705, 696, 676, 661, 639, 619, 616, 572, 568, 549, 501, 464, 455, 444, 443, 434, 430, 427, 399, 386, 345, 339, 324, 324, 309, 300, 257, 255, 228, 195, 184, 182, 177, 148, 129, 112, 91, 65, 31, 31, 22, 3]) == 46496\n    assert max_non_overlapping_dominos(1, [300000]) == 150000\ncheck(max_non_overlapping_dominos)\n", "given_tests": ["assert max_non_overlapping_dominos(5, [3, 2, 2, 2, 1]) == 4"], "canonical_solution": "[\"import sys\\nreadline = sys.stdin.readline\\nN = int(readline())\\nA = list(map(int, readline().split()))\\nBW = [0, 0]\\nfor i in range(N):\\n    a = A[i]\\n    BW[i%2] += a//2\\n    BW[(i+1)%2] += -(-a//2)\\nprint(min(BW))\"]", "difficulty": "competition"}
{"task_id": "APPS/2070", "prompt": "def final_number_after_operations(n: int, nums: List[int]) -> int:\n    \"\"\"\n    Karen has just arrived at school, and she has a math test today! [Image]\n    \n    The test is about basic addition and subtraction. Unfortunately, the teachers were too busy writing tasks for Codeforces rounds, and had no time to make an actual test. So, they just put one question in the test that is worth all the points.\n    \n    There are n integers written on a row. Karen must alternately add and subtract each pair of adjacent integers, and write down the sums or differences on the next row. She must repeat this process on the values on the next row, and so on, until only one integer remains. The first operation should be addition.\n    \n    Note that, if she ended the previous row by adding the integers, she should start the next row by subtracting, and vice versa.\n    \n    The teachers will simply look at the last integer, and then if it is correct, Karen gets a perfect score, otherwise, she gets a zero for the test.\n    \n    Karen has studied well for this test, but she is scared that she might make a mistake somewhere and it will cause her final answer to be wrong. If the process is followed, what number can she expect to be written on the last row?\n    \n    Since this number can be quite large, output only the non-negative remainder after dividing it by 10^9 + 7.\n    \n    \n    -----Input-----\n    \n    The first line of input contains a single integer n (1 \u2264 n \u2264 200000), the number of numbers written on the first row.\n    \n    The next line contains n integers. Specifically, the i-th one among these is a_{i} (1 \u2264 a_{i} \u2264 10^9), the i-th number on the first row.\n    \n    \n    -----Output-----\n    \n    Output a single integer on a line by itself, the number on the final row after performing the process above.\n    \n    Since this number can be quite large, print only the non-negative remainder after dividing it by 10^9 + 7.\n    \n    \n    -----Examples-----\n    Input\n    5\n    3 6 9 12 15\n    \n    Output\n    36\n    \n    Input\n    4\n    3 7 5 2\n    \n    Output\n    1000000006\n    \n    \n    \n    -----Note-----\n    \n    In the first test case, the numbers written on the first row are 3, 6, 9, 12 and 15.\n    \n    Karen performs the operations as follows: [Image]\n    \n    The non-negative remainder after dividing the final number by 10^9 + 7 is still 36, so this is the correct output.\n    \n    In the second test case, the numbers written on the first row are 3, 7, 5 and 2.\n    \n    Karen performs the operations as follows: [Image]\n    \n    The non-negative remainder after dividing the final number by 10^9 + 7 is 10^9 + 6, so this is the correct output.\n    \"\"\"\n", "entry_point": "final_number_after_operations", "test": "\ndef check(candidate):\n    assert candidate(5, [3, 6, 9, 12, 15]) == 36\n    assert candidate(4, [3, 7, 5, 2]) == 1000000006\n    assert candidate(1, [1]) == 1\n    assert candidate(16, [985629174, 189232688, 48695377, 692426437, 952164554, 243460498, 173956955, 210310239, 237322183, 96515847, 678847559, 682240199, 498792552, 208770488, 736004147, 176573082]) == 347261016\n    assert candidate(18, [341796022, 486073481, 86513380, 593942288, 60606166, 627385348, 778725113, 896678215, 384223198, 661124212, 882144246, 60135494, 374392733, 408166459, 179944793, 331468916, 401182818, 69503967]) == 773499683\n    assert candidate(17, [458679894, 912524637, 347508634, 863280107, 226481104, 787939275, 48953130, 553494227, 458256339, 673787326, 353107999, 298575751, 436592642, 233596921, 957974470, 254020999, 707869688]) == 769845668\n    assert candidate(19, [519879446, 764655030, 680293934, 914539062, 744988123, 317088317, 653721289, 239862203, 605157354, 943428394, 261437390, 821695238, 312192823, 432992892, 547139308, 408916833, 829654733, 223751525, 672158759]) == 265109293\n    assert candidate(1, [1000000000]) == 1000000000\n    assert candidate(3, [524125987, 923264237, 374288891]) == 996365563\n    assert candidate(4, [702209411, 496813081, 673102149, 561219907]) == 317278572\n    assert candidate(5, [585325539, 365329221, 412106895, 291882089, 564718673]) == 974257995\n    assert candidate(6, [58376259, 643910770, 5887448, 757703054, 544067926, 902981667]) == 676517605\n    assert candidate(7, [941492387, 72235422, 449924898, 783332532, 378192988, 592684636, 147499872]) == 328894634\n    assert candidate(2, [500000004, 500000003]) == 0\ncheck(final_number_after_operations)\n", "given_tests": ["assert final_number_after_operations(5, [3, 6, 9, 12, 15]) == 36", "assert final_number_after_operations(4, [3, 7, 5, 2]) == 1000000006"], "canonical_solution": "[\"import sys\\nreadline = sys.stdin.readline\\nN = int(readline())\\nA = list(map(int, readline().split()))\\nBW = [0, 0]\\nfor i in range(N):\\n    a = A[i]\\n    BW[i%2] += a//2\\n    BW[(i+1)%2] += -(-a//2)\\nprint(min(BW))\"]", "difficulty": "competition"}
{"task_id": "APPS/2318", "prompt": "def participants_excluded_from_ranking(n: int, k: int, ratings: List[int]) -> List[int]:\n    \"\"\"\n    During the last Sereja's Codesecrof round the server crashed many times, so the round was decided to be made unrated for some participants.\n    \n    Let's assume that n people took part in the contest. Let's assume that the participant who got the first place has rating a_1, the second place participant has rating a_2, ..., the n-th place participant has rating a_{n}. Then changing the rating on the Codesecrof site is calculated by the formula $d_{i} = \\sum_{j = 1}^{i - 1}(a_{j} \\cdot(j - 1) -(n - i) \\cdot a_{i})$.\n    \n    After the round was over, the Codesecrof management published the participants' results table. They decided that if for a participant d_{i} < k, then the round can be considered unrated for him. But imagine the management's surprise when they found out that the participants' rating table is dynamic. In other words, when some participant is removed from the rating, he is removed from the results' table and the rating is recalculated according to the new table. And of course, all applications for exclusion from the rating are considered in view of the current table.\n    \n    We know that among all the applications for exclusion from the rating the first application to consider is from the participant with the best rank (the rank with the minimum number), for who d_{i} < k. We also know that the applications for exclusion from rating were submitted by all participants.\n    \n    Now Sereja wonders, what is the number of participants to be excluded from the contest rating, and the numbers of the participants in the original table in the order of their exclusion from the rating. Pay attention to the analysis of the first test case for a better understanding of the statement.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers n, k (1 \u2264 n \u2264 2\u00b710^5,  - 10^9 \u2264 k \u2264 0). The second line contains n space-separated integers a_1, a_2, ..., a_{n} (1 \u2264 a_{i} \u2264 10^9) \u2014 ratings of the participants in the initial table.\n    \n    \n    -----Output-----\n    \n    Print the numbers of participants in the order in which they were removed from the table. Print the initial numbers of the participants, that is, the numbers that the participants had in the initial table.\n    \n    \n    -----Examples-----\n    Input\n    5 0\n    5 3 4 1 2\n    \n    Output\n    2\n    3\n    4\n    \n    Input\n    10 -10\n    5 5 1 7 5 1 2 4 9 2\n    \n    Output\n    2\n    4\n    5\n    7\n    8\n    9\n    \n    \n    \n    -----Note-----\n    \n    Consider the first test sample.\n    \n    \n    \n    Initially the sequence of the contest participants' ratings equals [5, 3, 4, 1, 2]. You can use this sequence to calculate the sequence of rating changes: [0, -9, -13, 8, 14]. According to the problem statement, the application of the participant who won the second place will be considered first.\n    \n    As soon as the second place winner is out from the ratings, the participants' rating sequence will equal [5, 4, 1, 2]. By this sequence you can count the new sequence of rating changes: [0, -8, 2, 6]. According to the problem statement, the application of the participant who won the second place will be considered. Initially this participant won third place.\n    \n    The new rating sequence equals [5, 1, 2], the new sequence of rating changes equals [0, -1, 1]. The second place participant's application is taken into consideration, initially this participant won the fourth place.\n    \n    The new rating sequence equals [5, 2], the new sequence of rating changes equals [0, 0]. No more applications will be considered.\n    \n    Thus, you should print 2, 3, 4.\n    \"\"\"\n", "entry_point": "participants_excluded_from_ranking", "test": "\ndef check(candidate):\n    assert participants_excluded_from_ranking(5, 0, [5, 3, 4, 1, 2]) == [2, 3, 4]\n    assert participants_excluded_from_ranking(10, -10, [5, 5, 1, 7, 5, 1, 2, 4, 9, 2]) == [2, 4, 5, 7, 8, 9]\ncheck(participants_excluded_from_ranking)\n", "given_tests": ["assert participants_excluded_from_ranking(5, 0, [5, 3, 4, 1, 2]) == [2, 3, 4]", "assert participants_excluded_from_ranking(10, -10, [5, 5, 1, 7, 5, 1, 2, 4, 9, 2]) == [2, 4, 5, 7, 8, 9]"], "canonical_solution": "[\"n, k = list(map(int, input().split()))\\nc, m, l, r = 0, 0, [], 0\\nfor e in [int(i) for i in input().split()]:\\n    d = m - c * (n - c - 1) * e\\n    r+= 1\\n    if d < k:\\n        n -= 1\\n        l += [r]\\n    else:\\n        m += c * e\\n        c += 1\\nl.sort()\\nfor e in l: print(e)\\n        \\n        \\n\", \"n, k = map(int, input().split())\\nc, v = 0, []\\nfor i, a in enumerate(map(int, input().split())):\\n    j = i + 1 - len(v)\\n    d = c - (j - 1) * (n - j) * a\\n    if d < k:\\n        v.append(i + 1)\\n        n -= 1\\n    else:\\n        c += a * (j - 1)\\nprint('\\\\n'.join(map(str, v)))\", \"n, k = map(int, input().split())\\nc, v = 0, []\\nfor i, a in enumerate(map(int, input().split())):\\n    j = i + 1 - len(v)\\n    d = c - (j - 1) * (n - j) * a\\n    if d < k:\\n        v.append(i + 1)\\n        n -= 1\\n    else:\\n        c += a * (j - 1)\\nprint('\\\\n'.join(map(str, v)))\", \"f = lambda: map(int, input().split())\\nn, k = f()\\ns = j = 0\\nfor i, q in enumerate(f(), 1):\\n    if s - j * (n - i) * q < k: print(i)\\n    else:\\n        s += q * j\\n        j += 1\", \"f = lambda: map(int, input().split())\\nn, k = f()\\nj = 0\\nfor i, q in enumerate(f(), 1):\\n    if j * (i - n) * q < k: print(i)\\n    else:\\n        k -= q * j\\n        j += 1\", \"n, k = list(map(int, input().split()))\\narr = list(map(int, input().split()))\\ns, j, all_res = 0, 0, []\\nfor i, q in enumerate(arr, 1):\\n    if s - j * (n - i) * q < k: \\n        all_res.append(str(i))\\n    else:\\n        s += q * j\\n        j += 1\\nprint('\\\\n'.join(all_res))\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2142", "prompt": "def restore_sequence(n: int, matrix: List[List[int]]) -> List[int]:\n    \"\"\"\n    Recently Polycarpus has learned the \"bitwise AND\" operation (which is also called \"AND\") of non-negative integers. Now he wants to demonstrate the school IT teacher his superb manipulation with the learned operation.\n    \n    For that Polycarpus came to school a little earlier and wrote on the board a sequence of non-negative integers a_1, a_2, ..., a_{n}. He also wrote a square matrix b of size n \u00d7 n. The element of matrix b that sits in the i-th row in the j-th column (we'll denote it as b_{ij}) equals:  the \"bitwise AND\" of numbers a_{i} and a_{j} (that is, b_{ij} = a_{i}\u00a0&\u00a0a_{j}), if i \u2260 j;  -1, if i = j.\n    \n    Having written out matrix b, Polycarpus got very happy and wiped a off the blackboard. But the thing is, the teacher will want this sequence to check whether Polycarpus' calculations were correct. Polycarus urgently needs to restore the removed sequence of integers, or else he won't prove that he can count correctly.\n    \n    Help Polycarpus, given matrix b, restore the sequence of numbers a_1, a_2, ..., a_{n}, that he has removed from the board. Polycarpus doesn't like large numbers, so any number in the restored sequence mustn't exceed 10^9.\n    \n    \n    -----Input-----\n    \n    The first line contains a single integer n (1 \u2264 n \u2264 100) \u2014 the size of square matrix b. Next n lines contain matrix b. The i-th of these lines contains n space-separated integers: the j-th number represents the element of matrix b_{ij}. It is guaranteed, that for all i (1 \u2264 i \u2264 n) the following condition fulfills: b_{ii} = -1. It is guaranteed that for all i, j (1 \u2264 i, j \u2264 n;\u00a0i \u2260 j) the following condition fulfills: 0 \u2264 b_{ij} \u2264 10^9, b_{ij} = b_{ji}.\n    \n    \n    -----Output-----\n    \n    Print n non-negative integers a_1, a_2, ..., a_{n} (0 \u2264 a_{i} \u2264 10^9) \u2014 the sequence that Polycarpus wiped off the board. Separate the numbers by whitespaces.\n    \n    It is guaranteed that there is sequence a that satisfies the problem conditions. If there are multiple such sequences, you are allowed to print any of them.\n    \n    \n    -----Examples-----\n    Input\n    1\n    -1\n    \n    Output\n    0\n    Input\n    3\n    -1 18 0\n    18 -1 0\n    0 0 -1\n    \n    Output\n    18 18 0\n    Input\n    4\n    -1 128 128 128\n    128 -1 148 160\n    128 148 -1 128\n    128 160 128 -1\n    \n    Output\n    128 180 148 160\n    \n    \n    -----Note-----\n    \n    If you do not know what is the \"bitwise AND\" operation please read: http://en.wikipedia.org/wiki/Bitwise_operation.\n    \"\"\"\n", "entry_point": "restore_sequence", "test": "\ndef check(candidate):\n    assert restore_sequence(1, [[-1]]) == [0]\n    assert restore_sequence(3, [[-1, 18, 0], [18, -1, 0], [0, 0, -1]]) == [18, 18, 0]\n    assert restore_sequence(4, [[-1, 128, 128, 128], [128, -1, 148, 160], [128, 148, -1, 128], [128, 160, 128, -1]]) == [128, 180, 148, 160]\n    assert restore_sequence(5, [[-1, 0, 0, 0, 0], [0, -1, 1, 0, 0], [0, 1, -1, 0, 0], [0, 0, 0, -1, 0], [0, 0, 0, 0, -1]]) == [0, 1, 1, 0, 0]\n    assert restore_sequence(6, [[-1, 1835024, 1966227, 34816, 68550800, 34832], [1835024, -1, 18632728, 306185992, 324272924, 289412624], [1966227, 18632728, -1, 40, 555155640, 16846864], [34816, 306185992, 40, -1, 306185000, 272666176], [68550800, 324272924, 555155640, 306185000, -1, 289481232], [34832, 289412624, 16846864, 272666176, 289481232, -1]]) == [69109907, 324818716, 555700411, 306220904, 928457660, 289521232]\n    assert restore_sequence(7, [[-1, 1000000000, 999999488, 999999488, 1000000000, 1000000000, 999999488], [1000000000, -1, 999999488, 999999488, 1000000000, 1000000000, 999999488], [999999488, 999999488, -1, 999999999, 999999488, 999999488, 999999999], [999999488, 999999488, 999999999, -1, 999999488, 999999488, 999999999], [1000000000, 1000000000, 999999488, 999999488, -1, 1000000000, 999999488], [1000000000, 1000000000, 999999488, 999999488, 1000000000, -1, 999999488], [999999488, 999999488, 999999999, 999999999, 999999488, 999999488, -1]]) == [1000000000, 1000000000, 999999999, 999999999, 1000000000, 1000000000, 999999999]\n    assert restore_sequence(8, [[-1, 56086, 2560, 35584, 6402, 18688, 22530, 256], [56086, -1, 2697, 35592, 6410, 18696, 22667, 257], [2560, 2697, -1, 10824, 10280, 10248, 10377, 8193], [35584, 35592, 10824, -1, 76040, 76040, 10248, 73984], [6402, 6410, 10280, 76040, -1, 76040, 14346, 73984], [18688, 18696, 10248, 76040, 76040, -1, 26632, 73984], [22530, 22667, 10377, 10248, 14346, 26632, -1, 9217], [256, 257, 8193, 73984, 73984, 73984, 9217, -1]]) == [56086, 56223, 10985, 109384, 80170, 92424, 31883, 75009]\n    assert restore_sequence(9, [[-1, 0, 0, 2, 0, 2, 10, 2, 0], [0, -1, 17, 16, 16, 17, 0, 17, 16], [0, 17, -1, 16, 16, 17, 0, 17, 16], [2, 16, 16, -1, 16, 18, 2, 18, 16], [0, 16, 16, 16, -1, 16, 0, 16, 16], [2, 17, 17, 18, 16, -1, 2, 19, 16], [10, 0, 0, 2, 0, 2, -1, 2, 0], [2, 17, 17, 18, 16, 19, 2, -1, 16], [0, 16, 16, 16, 16, 16, 0, 16, -1]]) == [10, 17, 17, 18, 16, 19, 10, 19, 16]\n    assert restore_sequence(10, [[-1, 16, 16, 0, 0, 0, 0, 16, 16, 16], [16, -1, 16, 3, 3, 2, 0, 17, 18, 16], [16, 16, -1, 0, 0, 0, 0, 16, 16, 16], [0, 3, 0, -1, 15, 10, 12, 1, 2, 0], [0, 3, 0, 15, -1, 10, 12, 1, 2, 0], [0, 2, 0, 10, 10, -1, 8, 0, 2, 0], [0, 0, 0, 12, 12, 8, -1, 0, 0, 0], [16, 17, 16, 1, 1, 0, 0, -1, 16, 16], [16, 18, 16, 2, 2, 2, 0, 16, -1, 16], [16, 16, 16, 0, 0, 0, 0, 16, 16, -1]]) == [16, 19, 16, 15, 15, 10, 12, 17, 18, 16]\n    assert restore_sequence(2, [[-1, 0], [0, -1]]) == [0, 0]\ncheck(restore_sequence)\n", "given_tests": ["assert restore_sequence(1, [[-1]]) == [0]", "assert restore_sequence(3, [[-1, 18, 0], [18, -1, 0], [0, 0, -1]]) == [18, 18, 0]", "assert restore_sequence(4, [[-1, 128, 128, 128], [128, -1, 148, 160], [128, 148, -1, 128], [128, 160, 128, -1]]) == [128, 180, 148, 160]"], "canonical_solution": "[\"n=int(input());a=[list(map(int,input().split())) for _ in range(n)];print(*[reduce(lambda x, y: x | y, (a[i][j] for j in range(n) if j != i), 0) for i in range(n)])\"]", "difficulty": "competition"}
{"task_id": "APPS/2170", "prompt": "def minimize_eating_time(n: int, k: int, a: List[int]) -> int:\n    \"\"\"\n    There are some rabbits in Singapore Zoo. To feed them, Zookeeper bought $n$ carrots with lengths $a_1, a_2, a_3, \\ldots, a_n$. However, rabbits are very fertile and multiply very quickly. Zookeeper now has $k$ rabbits and does not have enough carrots to feed all of them. To solve this problem, Zookeeper decided to cut the carrots into $k$ pieces. For some reason, all resulting carrot lengths must be positive integers.\n    \n    Big carrots are very difficult for rabbits to handle and eat, so the time needed to eat a carrot of size $x$ is $x^2$.\n    \n    Help Zookeeper split his carrots while minimizing the sum of time taken for rabbits to eat the carrots.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers $n$ and $k$ $(1 \\leq n \\leq k \\leq 10^5)$: the initial number of carrots and the number of rabbits.\n    \n    The next line contains $n$ integers $a_1, a_2, \\ldots, a_n$ $(1 \\leq a_i \\leq 10^6)$: lengths of carrots.\n    \n    It is guaranteed that the sum of $a_i$ is at least $k$.\n    \n    \n    -----Output-----\n    \n    Output one integer: the minimum sum of time taken for rabbits to eat carrots.\n    \n    \n    -----Examples-----\n    Input\n    3 6\n    5 3 1\n    \n    Output\n    15\n    \n    Input\n    1 4\n    19\n    \n    Output\n    91\n    \n    \n    \n    -----Note-----\n    \n    For the first test, the optimal sizes of carrots are $\\{1,1,1,2,2,2\\}$. The time taken is $1^2+1^2+1^2+2^2+2^2+2^2=15$\n    \n    For the second test, the optimal sizes of carrots are $\\{4,5,5,5\\}$. The time taken is $4^2+5^2+5^2+5^2=91$.\n    \"\"\"\n", "entry_point": "minimize_eating_time", "test": "\ndef check(candidate):\n    assert minimize_eating_time(3, 6, [5, 3, 1]) == 15\n    assert minimize_eating_time(1, 4, [19]) == 91\n    assert minimize_eating_time(1, 3, [1000000]) == 333333333334\n    assert minimize_eating_time(1, 1, [1]) == 1\n    assert minimize_eating_time(10, 23, [343, 984, 238, 758983, 231, 74, 231, 548, 893, 543]) == 41149446942\n    assert minimize_eating_time(20, 40, [2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2, 2]) == 40\n    assert minimize_eating_time(29, 99047, [206580, 305496, 61753, 908376, 272137, 803885, 675070, 665109, 995787, 667887, 164508, 634877, 994427, 270698, 931765, 721679, 518973, 65009, 804367, 608526, 535640, 117656, 342804, 398273, 369209, 298745, 365459, 942772, 89584]) == 2192719703\n    assert minimize_eating_time(54, 42164, [810471, 434523, 262846, 930807, 148016, 633714, 247313, 376546, 142288, 30094, 599543, 829013, 182512, 647950, 512266, 827248, 452285, 531124, 257259, 453752, 114536, 833190, 737596, 267349, 598567, 781294, 390500, 318098, 354290, 725051, 978831, 905185, 849542, 761886, 55532, 608148, 631077, 557070, 355245, 929381, 280340, 620004, 285066, 42159, 82460, 348896, 446782, 672690, 364747, 339938, 715721, 870099, 357424, 323761]) == 17049737221\n    assert minimize_eating_time(12, 21223, [992192, 397069, 263753, 561788, 903539, 521894, 818097, 223467, 511651, 737418, 975119, 528954]) == 2604648091\ncheck(minimize_eating_time)\n", "given_tests": ["assert minimize_eating_time(3, 6, [5, 3, 1]) == 15", "assert minimize_eating_time(1, 4, [19]) == 91"], "canonical_solution": "[\"import heapq\\n\\ndef sum_sqaure(a, k):\\n    q, r = divmod(a, k)\\n    return q**2 * (k-r) + (q+1)**2 * r\\n\\ndef diff(a, k):\\n    return sum_sqaure(a, k+1) - sum_sqaure(a, k)\\n\\nn, k = map(int, input().split())\\nnums = list(map(int, input().split()))\\n\\ncurr = sum(sum_sqaure(a, 1) for a in nums)\\nQ = [(diff(a, 1), a, 1) for a in nums]\\nheapq.heapify(Q)\\nfor __ in range(k - n):\\n    d, a, i = heapq.heappop(Q)\\n    curr += d\\n    heapq.heappush(Q, (diff(a, i+1), a, i+1))\\nprint(curr)\", \"import sys\\nreadline = sys.stdin.readline\\nfrom heapq import heappop as hpp, heappush as hp\\n\\n\\nINF = 10**9+7\\ndef calc(A, x):\\n    if A < x:\\n        return INF\\n    d, r = divmod(A, x)\\n    return d*d*x+(2*d+1)*r\\n\\nN, K = list(map(int, readline().split()))\\nA = list(map(int, readline().split()))\\nQ = [(-calc(a, 1)+calc(a, 2), a, 1) for a in A]\\nQ.sort()\\nfor _ in range(K-N):\\n    dif, a, x = hpp(Q)\\n    hp(Q, (-calc(a, x+1) + calc(a, x+2), a, x+1))\\n\\nans = 0\\nfor _, a, x in Q:\\n    ans += calc(a, x)\\nprint(ans)    \\n\", \"def calc(l, n):\\n    smol = l // n\\n    tol = l % n\\n    return smol * smol * n + (2 * smol + 1) * tol\\n\\n\\nimport heapq\\nn, k = list(map(int, input().split()))\\na = list(map(int, input().split()))\\ncurr = [1] * n\\n\\nq = []\\nfor i in range(n):\\n    v = a[i]\\n    heapq.heappush(q, (calc(v, 2) - calc(v, 1), i))\\n\\nout2 = sum([x*x for x in a])\\n\\nfor i in range(k - n):\\n    diff, nex = heapq.heappop(q)\\n    curr[nex] += 1\\n    v = a[nex]\\n    heapq.heappush(q, (calc(v, curr[nex] + 1) - calc(v, curr[nex]), nex))\\n    out2 += diff\\n\\nout = 0\\nfor i in range(n):\\n    out += calc(a[i], curr[i])\\nassert(out == out2)\\nprint(out)\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2035", "prompt": "def count_picking_ways(n: int, m: int, a: List[int]) -> List[int]:\n    \"\"\"\n    This is the easy version of the problem. The only difference between easy and hard versions is the constraint of $m$. You can make hacks only if both versions are solved.\n    \n    Chiori loves dolls and now she is going to decorate her bedroom![Image]\n    \n    As a doll collector, Chiori has got $n$ dolls. The $i$-th doll has a non-negative integer value $a_i$ ($a_i < 2^m$, $m$ is given). Chiori wants to pick some (maybe zero) dolls for the decoration, so there are $2^n$ different picking ways.\n    \n    Let $x$ be the bitwise-xor-sum of values of dolls Chiori picks (in case Chiori picks no dolls $x = 0$). The value of this picking way is equal to the number of $1$-bits in the binary representation of $x$. More formally, it is also equal to the number of indices $0 \\leq i < m$, such that $\\left\\lfloor \\frac{x}{2^i} \\right\\rfloor$ is odd.\n    \n    Tell her the number of picking ways with value $i$ for each integer $i$ from $0$ to $m$. Due to the answers can be very huge, print them by modulo $998\\,244\\,353$.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers $n$ and $m$ ($1 \\le n \\le 2 \\cdot 10^5$, $0 \\le m \\le 35$) \u00a0\u2014 the number of dolls and the maximum value of the picking way.\n    \n    The second line contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i < 2^m$) \u00a0\u2014 the values of dolls.\n    \n    \n    -----Output-----\n    \n    Print $m+1$ integers $p_0, p_1, \\ldots, p_m$ \u00a0\u2014 $p_i$ is equal to the number of picking ways with value $i$ by modulo $998\\,244\\,353$.\n    \n    \n    -----Examples-----\n    Input\n    4 4\n    3 5 8 14\n    \n    Output\n    2 2 6 6 0\n    Input\n    6 7\n    11 45 14 9 19 81\n    \n    Output\n    1 2 11 20 15 10 5 0\n    \"\"\"\n", "entry_point": "count_picking_ways", "test": "\ndef check(candidate):\n    assert count_picking_ways(4, 4, [3, 5, 8, 14]) == [2, 2, 6, 6, 0]\n    assert count_picking_ways(6, 7, [11, 45, 14, 9, 19, 81]) == [1, 2, 11, 20, 15, 10, 5, 0]\n    assert count_picking_ways(1, 0, [0]) == [2]\n    assert count_picking_ways(30, 35, [11712212162, 13887261936, 9226451478, 5810578422, 4558800999, 2160186631, 25345435752, 20420262166, 16723017889, 4041013095, 17986671533, 30276157972, 27290831854, 10571984774, 24307466845, 32173907391, 15769943440, 28953863917, 1549581104, 13064028174, 1138889079, 12556425529, 26841655665, 18139754266, 5735510830, 3178397383, 7757108363, 15850451442, 11041191850, 17872176930]) == [4, 0, 16, 208, 1672, 9908, 50904, 210400, 734032, 2209780, 5738368, 13028432, 26080504, 46141348, 72492200, 101511648, 126865608, 141776868, 141823824, 126878576, 101475192, 72509020, 46144296, 26068512, 13036528, 5737756, 2208288, 736112, 208904, 50764, 10328, 1568, 244, 12, 0, 0]\n    assert count_picking_ways(1, 1, [1]) == [1, 1]\n    assert count_picking_ways(1, 35, [0]) == [2, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert count_picking_ways(1, 35, [11451423333]) == [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert count_picking_ways(10, 34, [0, 0, 12318192370, 9052534583, 0, 4986123150, 184250432, 4986123150, 0, 184250432]) == [64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 64, 128, 64, 192, 128, 128, 128, 0, 64, 0, 64, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert count_picking_ways(35, 35, [28970678337, 13247197766, 4600355530, 18082505493, 16706083720, 2360325080, 23035896777, 30607216979, 32966877835, 32966877835, 18508953859, 8718641292, 16706083720, 8718641292, 28970678337, 29062095447, 31585209157, 29062095447, 18082505493, 24992043025, 32966877835, 28970678337, 24992043025, 24349067783, 4600355530, 16706083720, 12649054530, 26987450767, 29062095447, 13247197766, 22145858015, 2062883350, 10922253140, 30607216979, 2062883350]) == [75497471, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 75497471, 226492413, 377487355, 452984826, 377487355, 301989884, 226492413, 75497471, 150994942, 0, 0, 0, 0, 75497471, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert count_picking_ways(6, 35, [23601314651, 29074846252, 10638992479, 32779777411, 26378409257, 33108582487]) == [1, 0, 0, 0, 0, 0, 0, 0, 0, 0, 0, 1, 0, 1, 8, 6, 6, 8, 8, 7, 5, 7, 3, 2, 0, 0, 1, 0, 0, 0, 0, 0, 0, 0, 0, 0]\n    assert count_picking_ways(30, 30, [65536, 536870912, 2097152, 512, 32768, 16384, 8388608, 16777216, 524288, 4194304, 1, 1048576, 2048, 262144, 64, 4096, 8192, 256, 131072, 2, 268435456, 33554432, 32, 16, 134217728, 8, 67108864, 128, 4, 1024]) == [1, 30, 435, 4060, 27405, 142506, 593775, 2035800, 5852925, 14307150, 30045015, 54627300, 86493225, 119759850, 145422675, 155117520, 145422675, 119759850, 86493225, 54627300, 30045015, 14307150, 5852925, 2035800, 593775, 142506, 27405, 4060, 435, 30, 1]\n    assert count_picking_ways(30, 30, [16777215, 7, 2097151, 131071, 15, 127, 1073741823, 3, 4095, 536870911, 134217727, 8191, 31, 255, 65535, 511, 8388607, 16383, 4194303, 524287, 1, 32767, 33554431, 1048575, 1023, 63, 262143, 2047, 67108863, 268435455]) == [1, 30, 435, 4060, 27405, 142506, 593775, 2035800, 5852925, 14307150, 30045015, 54627300, 86493225, 119759850, 145422675, 155117520, 145422675, 119759850, 86493225, 54627300, 30045015, 14307150, 5852925, 2035800, 593775, 142506, 27405, 4060, 435, 30, 1]\n    assert count_picking_ways(30, 31, [16385, 131072, 67108865, 1073741825, 1048577, 5, 65536, 16, 4096, 32, 33554432, 1024, 536870912, 2097153, 4194304, 3, 32768, 262145, 268435457, 9, 524289, 16777217, 256, 2049, 134217728, 65, 8388608, 128, 512, 8192]) == [1, 16, 225, 2240, 15785, 85008, 367913, 1314560, 3945045, 10080720, 22174581, 42334656, 70562765, 103129040, 132588045, 150266880, 150273315, 132594480, 103124035, 70557760, 42337659, 22177584, 10079355, 3943680, 1315015, 368368, 84903, 15680, 2255, 240, 15, 0]\n    assert count_picking_ways(30, 31, [7, 3, 1, 2097151, 511, 31, 1023, 4095, 536870911, 16383, 2047, 268435455, 33554431, 15, 8388607, 131071, 134217727, 67108863, 4194303, 65535, 8191, 1048575, 32767, 16777215, 524287, 1073741823, 63, 262143, 255, 127]) == [1, 30, 435, 4060, 27405, 142506, 593775, 2035800, 5852925, 14307150, 30045015, 54627300, 86493225, 119759850, 145422675, 155117520, 145422675, 119759850, 86493225, 54627300, 30045015, 14307150, 5852925, 2035800, 593775, 142506, 27405, 4060, 435, 30, 1, 0]\n    assert count_picking_ways(35, 35, [536870910, 4194303, 8388606, 1023, 131070, 8190, 17179869183, 262143, 510, 16777215, 255, 33554430, 63, 4095, 2147483646, 65535, 6, 15, 8589934590, 524286, 30, 134217726, 16383, 34359738366, 2046, 32766, 126, 2097150, 1048575, 4294967295, 268435455, 67108863, 8589934590, 1073741823, 3]) == [2, 0, 1190, 0, 104720, 0, 3246320, 0, 47071640, 0, 367158792, 0, 670659247, 0, 646941388, 0, 133903076, 0, 90936123, 0, 506420202, 0, 956186894, 0, 834451800, 0, 141214920, 0, 13449040, 0, 649264, 0, 13090, 0, 70, 0]\n    assert count_picking_ways(36, 35, [8193, 4194305, 262145, 536870913, 524289, 8589934593, 4294967297, 2147483649, 129, 1048577, 33, 4097, 131073, 2097153, 16777217, 1073741825, 33554433, 65, 1025, 257, 32769, 5, 134217729, 1025, 3, 17179869185, 9, 268435457, 513, 8193, 8388609, 16385, 2049, 67108865, 17, 65537]) == [4, 0, 2380, 0, 209440, 0, 6492640, 0, 94143280, 0, 734317584, 0, 343074141, 0, 295638423, 0, 267806152, 0, 181872246, 0, 14596051, 0, 914129435, 0, 670659247, 0, 282429840, 0, 26898080, 0, 1298528, 0, 26180, 0, 140, 0]\n    assert count_picking_ways(36, 35, [16384, 1048576, 2048, 268435456, 8, 256, 65536, 16777216, 128, 33554432, 4294967296, 32768, 1073741824, 4194304, 8388608, 8589934592, 4, 536870912, 2, 512, 131072, 16, 524288, 32768, 8192, 4096, 1, 2097152, 262144, 134217728, 64, 17179869184, 1024, 32, 2147483648, 67108864]) == [2, 70, 1190, 13090, 104720, 649264, 3246320, 13449040, 47071640, 141214920, 367158792, 834451800, 670659247, 956186894, 646941388, 506420202, 133903076, 90936123, 90936123, 133903076, 506420202, 646941388, 956186894, 670659247, 834451800, 367158792, 141214920, 47071640, 13449040, 3246320, 649264, 104720, 13090, 1190, 70, 2]\ncheck(count_picking_ways)\n", "given_tests": ["assert count_picking_ways(4, 4, [3, 5, 8, 14]) == [2, 2, 6, 6, 0]", "assert count_picking_ways(6, 7, [11, 45, 14, 9, 19, 81]) == [1, 2, 11, 20, 15, 10, 5, 0]"], "canonical_solution": "[\"MOD = 998244353\\nBOUND = 19\\n \\nn, m = list(map(int, input().split()))\\nl = list(map(int,input().split()))\\n \\nbasis = []\\nfor p in range(m-1,-1,-1):\\n    p2 = pow(2,p)\\n    nex = -1\\n    for i in range(n):\\n        if l[i] >= p2:\\n            nex = l[i]\\n            break\\n    if nex != -1:\\n        basis.append(nex)\\n        for i in range(n):\\n            if l[i] >= p2:\\n                l[i] ^= nex\\n        \\nextra = n - len(basis)\\n\\ndef add(a, b):\\n    out = [0] * (max(len(a), len(b)))\\n    for i in range(len(a)):\\n        out[i] = a[i]\\n    for i in range(len(b)):\\n        out[i] += b[i]\\n        out[i] %= MOD\\n    return out\\n    \\n \\ndef addSh(a, b):\\n    out = [0] * (max(len(a) + 1, len(b)))\\n    for i in range(len(a)):\\n        out[i + 1] = a[i]\\n    for i in range(len(b)):\\n        out[i] += b[i]\\n        out[i] %= MOD\\n    return out\\n \\ni = 0\\ncurr = dict()\\ncurr[0] = [1]\\nfor p in range(m-1,-1,-1):\\n    p2 = pow(2,p)\\n    if i < len(basis) and basis[i] >= p2:\\n        currN = dict(curr)\\n        for v in curr:\\n            if v ^ basis[i] not in currN:\\n                currN[v ^ basis[i]] = [0]\\n            currN[v ^ basis[i]] = add(curr[v], currN[v ^ basis[i]])\\n        curr = currN\\n        i += 1\\n \\n    currN = dict(curr)\\n    for v in curr:\\n        if v >= p2:\\n            if v ^ p2 not in currN:\\n                currN[v ^ p2] = [0]\\n            currN[v ^ p2] = addSh(curr[v], currN[v ^ p2])\\n            del currN[v]\\n    curr = currN  \\n \\nout = curr[0]\\nwhile len(out) < m + 1:\\n    out.append(0)\\nfor i in range(m + 1):\\n    out[i] *= pow(2, extra, MOD)\\n    out[i] %= MOD\\nprint(' '.join(map(str,out)))\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2308", "prompt": "def maximize_column_sums(n: int, w: int, arrays: List[List[int]]) -> List[int]:\n    \"\"\"\n    You are given $n$ arrays that can have different sizes. You also have a table with $w$ columns and $n$ rows. The $i$-th array is placed horizontally in the $i$-th row. You can slide each array within its row as long as it occupies several consecutive cells and lies completely inside the table.\n    \n    You need to find the maximum sum of the integers in the $j$-th column for each $j$ from $1$ to $w$ independently.\n    \n    [Image] Optimal placements for columns $1$, $2$ and $3$ are shown on the pictures from left to right.\n    \n    Note that you can exclude any array out of a column provided it remains in the window. In this case its value is considered to be zero.\n    \n    \n    -----Input-----\n    \n    The first line contains two integers $n$ ($1 \\le n \\le 10^{6}$) and $w$ ($1 \\le w \\le 10^{6}$)\u00a0\u2014 the number of arrays and the width of the table.\n    \n    Each of the next $n$ lines consists of an integer $l_{i}$ ($1 \\le l_{i} \\le w$), the length of the $i$-th array, followed by $l_{i}$ integers $a_{i1}, a_{i2}, \\ldots, a_{il_i}$ ($-10^{9} \\le a_{ij} \\le 10^{9}$)\u00a0\u2014 the elements of the array.\n    \n    The total length of the arrays does no exceed $10^{6}$.\n    \n    \n    -----Output-----\n    \n    Print $w$ integers, the $i$-th of them should be the maximum sum for column $i$.\n    \n    \n    -----Examples-----\n    Input\n    3 3\n    3 2 4 8\n    2 2 5\n    2 6 3\n    \n    Output\n    10 15 16\n    \n    Input\n    2 2\n    2 7 8\n    1 -8\n    \n    Output\n    7 8\n    \n    \n    \n    -----Note-----\n    \n    Illustration for the first example is in the statement.\n    \"\"\"\n", "entry_point": "maximize_column_sums", "test": "\ndef check(candidate):\n    assert candidate(3, 3, [[3, 2, 4, 8], [2, 2, 5], [2, 6, 3]]) == [10, 15, 16]\n    assert candidate(2, 2, [[2, 7, 8], [1, -8]]) == [7, 8]\ncheck(maximize_column_sums)\n", "given_tests": ["assert maximize_column_sums(3, 3, [[3, 2, 4, 8], [2, 2, 5], [2, 6, 3]]) == [10, 15, 16]", "assert maximize_column_sums(2, 2, [[2, 7, 8], [1, -8]]) == [7, 8]"], "canonical_solution": "[\"import sys\\ninput = sys.stdin.readline\\nfrom collections import deque\\ndef slidemax(X, k):\\n    q = deque([])\\n    ret = []\\n    for i in range(len(X)):\\n        while q and q[-1][1] <= X[i]:\\n            q.pop()\\n        deque.append(q, (i+k, X[i]))\\n        if q[0][0] == i:\\n            deque.popleft(q)\\n        if i >= k-1:\\n            ret.append(q[0][1])\\n    return ret\\n \\nN, W = list(map(int, input().split()))\\nA = [0] * W\\ns = 0\\nfor _ in range(N):\\n    l, *B = list(map(int, input().split()))\\n    if l*2 < W:\\n        C = slidemax([0]*(l-1)+B+[0]*(l-1), l)\\n        m = max(B + [0])\\n        s += m\\n        for i in range(l-1):\\n            A[i] += C[i] - m\\n            A[-i-1] += C[-i-1] - m\\n    else:\\n        C = slidemax([0]*(W-l)+B+[0]*(W-l), W - l + 1)\\n        A = [a+c for a, c in zip(A, C)]\\n\\nprint(*[a+s for a in A])\", \"import sys\\ninput = sys.stdin.readline\\nfrom collections import deque\\nn,w=[int(i) for i in input().rstrip('\\\\n').split()]\\narr=[]\\ntem=[]\\nfor i in range(n):\\n    t=[int(i) for i in input().rstrip('\\\\n').split()]\\n    tem.append(t[0])\\n    arr.append(t[1:])\\nl=[0 for i in range(w)]\\n\\nwi=[0 for i in range(w+1)]\\nfor j in range(n):\\n    st=deque()\\n    c=w-tem[j]\\n    for i in range(tem[j]):\\n        while st and st[0]<i-c:st.popleft()\\n        while st and arr[j][st[-1]]<arr[j][i]:st.pop()\\n        st.append(i)\\n        if arr[j][st[0]]>0 or (i>=c and i<w-c):\\n            l[i]+=arr[j][st[0]]\\n    ind=tem[j]\\n    while st and arr[j][st[0]]>0:\\n        wi[ind]+=arr[j][st[0]]\\n        wi[w-(tem[j]-st[0])+1]+=-arr[j][st[0]]\\n        ind=w-(tem[j]-st[0])+1\\n        st.popleft()\\n    \\n\\ncurr=0\\nfor i in range(w):\\n    curr+=wi[i]\\n    l[i]+=curr\\nprint(\\\" \\\".join(str(e) for e in l))\"]", "difficulty": "competition"}
{"task_id": "APPS/2346", "prompt": "def maximize_haybales(t: int, test_cases: List[Tuple[int, int, List[int]]]) -> List[int]:\n    \"\"\"\n    The USA Construction Operation (USACO) recently ordered Farmer John to arrange a row of $n$ haybale piles on the farm. The $i$-th pile contains $a_i$ haybales.\n    \n    However, Farmer John has just left for vacation, leaving Bessie all on her own. Every day, Bessie the naughty cow can choose to move one haybale in any pile to an adjacent pile. Formally, in one day she can choose any two indices $i$ and $j$ ($1 \\le i, j \\le n$) such that $|i-j|=1$ and $a_i>0$ and apply $a_i = a_i - 1$, $a_j = a_j + 1$. She may also decide to not do anything on some days because she is lazy.\n    \n    Bessie wants to maximize the number of haybales in pile $1$ (i.e. to maximize $a_1$), and she only has $d$ days to do so before Farmer John returns. Help her find the maximum number of haybales that may be in pile $1$ if she acts optimally!\n    \n    \n    -----Input-----\n    \n    The input consists of multiple test cases. The first line contains an integer $t$ ($1 \\le t \\le 100$) \u00a0\u2014 the number of test cases. Next $2t$ lines contain a description of test cases \u00a0\u2014 two lines per test case.\n    \n    The first line of each test case contains integers $n$ and $d$ ($1 \\le n,d \\le 100$) \u2014 the number of haybale piles and the number of days, respectively.\n    \n    The second line of each test case contains $n$ integers $a_1, a_2, \\ldots, a_n$ ($0 \\le a_i \\le 100$) \u00a0\u2014 the number of haybales in each pile.\n    \n    \n    -----Output-----\n    \n    For each test case, output one integer: the maximum number of haybales that may be in pile $1$ after $d$ days if Bessie acts optimally.\n    \n    \n    -----Example-----\n    Input\n    3\n    4 5\n    1 0 3 2\n    2 2\n    100 1\n    1 8\n    0\n    \n    Output\n    3\n    101\n    0\n    \n    \n    \n    -----Note-----\n    \n    In the first test case of the sample, this is one possible way Bessie can end up with $3$ haybales in pile $1$:   On day one, move a haybale from pile $3$ to pile $2$  On day two, move a haybale from pile $3$ to pile $2$  On day three, move a haybale from pile $2$ to pile $1$  On day four, move a haybale from pile $2$ to pile $1$  On day five, do nothing\n    \n    In the second test case of the sample, Bessie can do nothing on the first day and move a haybale from pile $2$ to pile $1$ on the second day.\n    \"\"\"\n", "entry_point": "maximize_haybales", "test": "\ndef check(candidate):\n    assert candidate(3, [(4, 5, [1, 0, 3, 2]), (2, 2, [100, 1]), (1, 8, [0])]) == [3, 101, 0]\ncheck(maximize_haybales)\n", "given_tests": ["assert maximize_haybales(3, [(4, 5, [1, 0, 3, 2]), (2, 2, [100, 1]), (1, 8, [0])]) == [3, 101, 0]"], "canonical_solution": "[\"\\nimport sys\\n#sys.stdin=open(\\\"data.txt\\\")\\ninput=sys.stdin.readline\\nmii=lambda:list(map(int,input().split()))\\n\\nfor _ in range(int(input())):\\n    n,d=mii()\\n    a=list(mii())\\n    ans=0\\n    for i in range(n):\\n        while d>=i and a[i]:\\n            a[i]-=1\\n            ans+=1\\n            d-=i\\n    print(ans)\\n\", \"for _ in range(int(input())):\\n    n, d = list(map(int, input().split()))\\n    ar = list(map(int, input().split()))\\n    ans = ar[0]\\n    for i in range(1, n):\\n        if ar[i] * i <= d:\\n            d -= ar[i] * i\\n            ans += ar[i]\\n        else:\\n            ans += d // i\\n            break\\n    print(ans)\", \"from bisect import bisect_left as bl\\nfrom bisect import bisect_right as br\\nimport heapq\\nimport math\\nfrom collections import *\\nfrom functools import reduce,cmp_to_key\\nimport sys\\ninput = sys.stdin.readline\\n \\nM = mod = 10**9 + 7\\ndef factors(n):return sorted(set(reduce(list.__add__, ([i, n//i] for i in range(1, int(n**0.5) + 1) if n % i == 0))))\\ndef inv_mod(n):return pow(n, mod - 2, mod)\\n \\ndef li():return [int(i) for i in input().rstrip('\\\\n').split()]\\ndef st():return input().rstrip('\\\\n')\\ndef val():return int(input().rstrip('\\\\n'))\\ndef li2():return [i for i in input().rstrip('\\\\n').split(' ')]\\ndef li3():return [int(i) for i in input().rstrip('\\\\n')]\\n\\n\\nfor _ in range(val()):\\n    tot = 0\\n    n,d = li()\\n    l = li()\\n    tot = l[0]\\n    for i in range(1,n):\\n        while d >= i and l[i]:\\n            l[i] -= 1\\n            tot += 1\\n            d-=i\\n    print(tot)\", \"for _ in range(int(input())):\\n    n, d = list(map(int, input().split()))\\n    li = list(map(int, input().split()))\\n    res = li[0]\\n    for i in range(1, n):\\n        x = min(li[i], d // i)\\n        res += x\\n        d -= x * i\\n    print(res)\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2204", "prompt": "def shortest_time_to_move_token(n: int, m: int, edges: List[Tuple[int, int]]) -> int:\n    \"\"\"\n    You are given a directed graph of $n$ vertices and $m$ edges. Vertices are numbered from $1$ to $n$. There is a token in vertex $1$.\n    \n    The following actions are allowed:   Token movement. To move the token from vertex $u$ to vertex $v$ if there is an edge $u \\to v$ in the graph. This action takes $1$ second.  Graph transposition. To transpose all the edges in the graph: replace each edge $u \\to v$ by an edge $v \\to u$. This action takes increasingly more time: $k$-th transposition takes $2^{k-1}$ seconds, i.e. the first transposition takes $1$ second, the second one takes $2$ seconds, the third one takes $4$ seconds, and so on.\n    \n    The goal is to move the token from vertex $1$ to vertex $n$ in the shortest possible time. Print this time modulo $998\\,244\\,353$.\n    \n    \n    -----Input-----\n    \n    The first line of input contains two integers $n, m$ ($1 \\le n, m \\le 200\\,000$).\n    \n    The next $m$ lines contain two integers each: $u, v$ ($1 \\le u, v \\le n; u \\ne v$), which represent the edges of the graph. It is guaranteed that all ordered pairs $(u, v)$ are distinct.\n    \n    It is guaranteed that it is possible to move the token from vertex $1$ to vertex $n$ using the actions above.\n    \n    \n    -----Output-----\n    \n    Print one integer: the minimum required time modulo $998\\,244\\,353$.\n    \n    \n    -----Examples-----\n    Input\n    4 4\n    1 2\n    2 3\n    3 4\n    4 1\n    \n    Output\n    2\n    \n    Input\n    4 3\n    2 1\n    2 3\n    4 3\n    \n    Output\n    10\n    \n    \n    \n    -----Note-----\n    \n    The first example can be solved by transposing the graph and moving the token to vertex $4$, taking $2$ seconds.\n    \n    The best way to solve the second example is the following: transpose the graph, move the token to vertex $2$, transpose the graph again, move the token to vertex $3$, transpose the graph once more and move the token to vertex $4$.\n    \"\"\"\n", "entry_point": "shortest_time_to_move_token", "test": "\ndef check(candidate):\n    assert candidate(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 2\n    assert candidate(4, 3, [(2, 1), (2, 3), (4, 3)]) == 10\n    assert candidate(10, 20, [(2, 1), (7, 9), (10, 2), (4, 9), (3, 1), (6, 4), (3, 6), (2, 9), (5, 2), (3, 9), (6, 8), (8, 7), (10, 4), (7, 4), (8, 5), (3, 4), (6, 7), (2, 6), (10, 6), (3, 8)]) == 3\n    assert candidate(10, 9, [(8, 5), (3, 5), (3, 7), (10, 6), (4, 6), (8, 1), (9, 2), (4, 2), (9, 7)]) == 520\n    assert candidate(50, 49, [(1, 3), (6, 46), (47, 25), (11, 49), (47, 10), (26, 10), (12, 38), (45, 38), (24, 39), (34, 22), (36, 3), (21, 16), (43, 44), (45, 23), (2, 31), (26, 13), (28, 42), (43, 30), (12, 27), (32, 44), (24, 25), (28, 20), (15, 19), (6, 48), (41, 7), (15, 17), (8, 9), (2, 48), (33, 5), (33, 23), (4, 19), (40, 31), (11, 9), (40, 39), (35, 27), (14, 37), (32, 50), (41, 20), (21, 13), (14, 42), (18, 30), (35, 22), (36, 5), (18, 7), (4, 49), (29, 16), (29, 17), (8, 37), (34, 46)]) == 16495294\n    assert candidate(13, 13, [(2, 1), (2, 3), (1, 4), (4, 5), (5, 6), (6, 7), (7, 3), (8, 3), (8, 9), (10, 9), (10, 11), (12, 11), (12, 13)]) == 74\n    assert candidate(2, 1, [(2, 1)]) == 2\ncheck(shortest_time_to_move_token)\n", "given_tests": ["assert shortest_time_to_move_token(4, 4, [(1, 2), (2, 3), (3, 4), (4, 1)]) == 2", "assert shortest_time_to_move_token(4, 3, [(2, 1), (2, 3), (4, 3)]) == 10"], "canonical_solution": "[\"import sys\\ninput = sys.stdin.readline\\nimport heapq\\n\\nmod=998244353\\n\\nn,m=list(map(int,input().split()))\\n\\nE=[[] for i in range(n+1)]\\nE2=[[] for i in range(n+1)]\\n\\nfor i in range(m):\\n    x,y=list(map(int,input().split()))\\n    E[x].append(y)\\n    E2[y].append(x)\\n\\nTIME=[1<<29]*(n+1)\\nTIME[1]=0\\n\\ndef shuku(x,y):\\n    return (x<<20)+y\\n\\nQ=[]\\nANS=[]\\n\\nfor k in range(n+1):\\n    NQ=[]\\n\\n    if k<=1:\\n        heapq.heappush(Q,shuku(0,1))\\n\\n    if k%2==0:\\n        while Q:\\n            #print(Q)\\n            x=heapq.heappop(Q)\\n            time=x>>20\\n            town=x-(time<<20)\\n\\n            #print(x,time,town)\\n\\n            if TIME[town]<time:\\n                continue\\n\\n            for to in E[town]:\\n                if TIME[to]>time+1:\\n                    TIME[to]=time+1\\n                    heapq.heappush(Q,shuku(TIME[to],to))\\n                    heapq.heappush(NQ,shuku(TIME[to],to))\\n\\n    else:\\n        while Q:\\n            x=heapq.heappop(Q)\\n            time=x>>20\\n            town=x-(time<<20)\\n\\n            #print(x,time,town)\\n\\n            if TIME[town]<time:\\n                continue\\n\\n            for to in E2[town]:\\n                if TIME[to]>time+1:\\n                    TIME[to]=time+1\\n                    heapq.heappush(Q,shuku(TIME[to],to))\\n                    heapq.heappush(NQ,shuku(TIME[to],to))\\n\\n    #print(k,TIME)\\n\\n    Q=NQ\\n    ANS.append(TIME[n])\\n\\n    if k>=100 and TIME[n]!=1<<29:\\n        break\\n\\nA=ANS[0]\\nfor k in range(1,len(ANS)):\\n    if ANS[k]==1<<29:\\n        continue\\n\\n    if ANS[k-1]==1<<29:\\n        A=(ANS[k]+pow(2,k,mod)-1)%mod\\n\\n    if k<60 and ANS[k-1]-ANS[k]>pow(2,k-1):\\n        A=(ANS[k]+pow(2,k,mod)-1)%mod\\n\\nprint(A)\\n    \\n\\n\\n    \\n    \\n        \\n                    \\n                \\n\\n        \\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2175", "prompt": "def is_possible_xor_sum(m: int, numbers: List[int]) -> List[str]:\n    \"\"\"\n    After Misha's birthday he had many large numbers left, scattered across the room. Now it's time to clean up and Misha needs to put them in a basket. He ordered this task to his pet robot that agreed to complete the task at certain conditions. Before the robot puts a number x to the basket, Misha should answer the question: is it possible to choose one or multiple numbers that already are in the basket, such that their XOR sum equals x?\n    \n    If the answer is positive, you also need to give the indexes of these numbers. If there are multiple options of choosing numbers, you are allowed to choose any correct option. After Misha's answer the robot puts the number to the basket.\n    \n    Initially the basket is empty. Each integer you put in the basket takes some number. The first integer you put into the basket take number 0, the second integer takes number 1 and so on.\n    \n    Misha needs to clean up the place as soon as possible but unfortunately, he isn't that good at mathematics. He asks you to help him.\n    \n    \n    -----Input-----\n    \n    The first line contains number m (1 \u2264 m \u2264 2000), showing how many numbers are scattered around the room.\n    \n    The next m lines contain the numbers in the order in which the robot puts them in the basket. Each number is a positive integer strictly less than 10^600 that doesn't contain leading zeroes.\n    \n    \n    -----Output-----\n    \n    For each number either print a 0 on the corresponding line, if the number cannot be represented as a XOR sum of numbers that are in the basket, or print integer k showing how many numbers are in the representation and the indexes of these numbers. Separate the numbers by spaces. Each number can occur in the representation at most once.\n    \n    \n    -----Examples-----\n    Input\n    7\n    7\n    6\n    5\n    4\n    3\n    2\n    1\n    \n    Output\n    0\n    0\n    0\n    3 0 1 2\n    2 1 2\n    2 0 2\n    2 0 1\n    \n    Input\n    2\n    5\n    5\n    \n    Output\n    0\n    1 0\n    \n    \n    \n    -----Note-----\n    \n    The XOR sum of numbers is the result of bitwise sum of numbers modulo 2.\n    \"\"\"\n", "entry_point": "is_possible_xor_sum", "test": "\ndef check(candidate):\n    assert candidate(7, [7, 6, 5, 4, 3, 2, 1]) == ['0', '0', '0', '3 0 1 2', '2 1 2', '2 0 2', '2 0 1']\n    assert candidate(2, [5, 5]) == ['0', '1 0']\n    assert candidate(10, [81, 97, 12, 2, 16, 96, 80, 99, 6, 83]) == ['0', '0', '0', '0', '0', '0', '3 0 1 5', '2 1 3', '0', '2 0 3']\n    assert candidate(10, [15106, 13599, 69319, 33224, 26930, 94490, 85089, 60931, 23137, 62868]) == ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0']\n    assert candidate(10, [5059464500, 8210395556, 3004213265, 248593357, 5644084048, 9359824793, 8120649160, 4288978422, 183848555, 8135845959]) == ['0', '0', '0', '0', '0', '0', '0', '0', '0', '0']\n    assert candidate(10, [4, 12, 28, 29, 31, 31, 31, 31, 31, 31]) == ['0', '0', '0', '0', '0', '1 4', '1 4', '1 4', '1 4', '1 4']\n    assert candidate(10, [16, 24, 28, 30, 31, 31, 31, 31, 31, 31]) == ['0', '0', '0', '0', '0', '1 4', '1 4', '1 4', '1 4', '1 4']\n    assert candidate(10, [16, 8, 4, 2, 1, 31, 31, 31, 31, 31]) == ['0', '0', '0', '0', '0', '5 0 1 2 3 4', '5 0 1 2 3 4', '5 0 1 2 3 4', '5 0 1 2 3 4', '5 0 1 2 3 4']\n    assert candidate(10, [1, 2, 4, 8, 16, 31, 31, 31, 31, 31]) == ['0', '0', '0', '0', '0', '5 0 1 2 3 4', '5 0 1 2 3 4', '5 0 1 2 3 4', '5 0 1 2 3 4', '5 0 1 2 3 4']\ncheck(is_possible_xor_sum)\n", "given_tests": ["assert is_possible_xor_sum(7, [7, 6, 5, 4, 3, 2, 1]) == ['0', '0', '0', '3 0 1 2', '2 1 2', '2 0 2', '2 0 1']", "assert is_possible_xor_sum(2, [5, 5]) == ['0', '1 0']"], "canonical_solution": "[\"buck = [[0, 0] for i in range(2201)]\\nm = int(input())\\nfor i in range(m):\\n    a = int(input())\\n    ok = True\\n    br = 0\\n    for j in range(2200, -1, -1):\\n        if a & (1 << j):\\n            if(buck[j][0]):\\n                a  ^= buck[j][0]\\n                br ^= buck[j][1]\\n            else:\\n                ok = False\\n                buck[j][0] = a\\n                buck[j][1] = br | (1 << i)\\n                break\\n    if not ok:\\n        print(\\\"0\\\")\\n    else:\\n        lst = []\\n        for j in range(2201):\\n            if br & (1 << j):\\n                lst.append(j)\\n        print(len(lst), end = ' ')\\n        for j in lst:\\n            print(j, end = ' ')\\n        print('\\\\n', end='')\\n\", \"m = int(input())\\n\\nb = []\\nk = []\\nfor i in range(m):\\n    x = int(input())\\n    c = 0\\n    for j in range(len(b)):\\n        v = b[j]\\n        d = k[j]\\n        if (x ^ v) < x:\\n            x ^= v\\n            c ^= d\\n\\n    if x != 0:\\n        print(0)\\n        c ^= 2 ** i\\n        b.append(x)\\n        k.append(c)\\n    else:\\n        a = []\\n        for j in range(m):\\n            if c & 1 == 1:\\n                a.append(j)\\n            c >>= 1\\n        print(len(a), end='')\\n        for v in a:\\n            print(' ', v, sep='', end='')\\n        print()\\n\", \"n = int(input())\\nb = []\\nbb =[]\\nfor i in range(n):\\n    x=int(input())\\n    idx = 0\\n    for j in range(len(b)):\\n        nxt = b[j] ^ x\\n        if nxt < x :\\n            x = nxt\\n            idx ^= bb[j]\\n    if x == 0:\\n        cnt = 0\\n        v = []\\n        for k in range(2000):\\n            if idx & (1 << k) :\\n                v.append(k)\\n        print(len(v),end=' ')\\n        for e in v:\\n            print(e,end=' ')\\n        print()\\n    else :\\n        print(0)\\n        idx ^= 1 << i\\n        b.append(x)\\n        bb.append(idx)\\n\\n        \\n    \"]", "difficulty": "competition"}
{"task_id": "APPS/2139", "prompt": "def partition_sum(n: int, a: List[int]) -> int:\n    \"\"\"\n    You are given an array $a$ of length $2n$. Consider a partition of array $a$ into two subsequences $p$ and $q$ of length $n$ each (each element of array $a$ should be in exactly one subsequence: either in $p$ or in $q$).\n    \n    Let's sort $p$ in non-decreasing order, and $q$ in non-increasing order, we can denote the sorted versions by $x$ and $y$, respectively. Then the cost of a partition is defined as $f(p, q) = \\sum_{i = 1}^n |x_i - y_i|$.\n    \n    Find the sum of $f(p, q)$ over all correct partitions of array $a$. Since the answer might be too big, print its remainder modulo $998244353$.\n    \n    \n    -----Input-----\n    \n    The first line contains a single integer $n$ ($1 \\leq n \\leq 150\\,000$).\n    \n    The second line contains $2n$ integers $a_1, a_2, \\ldots, a_{2n}$ ($1 \\leq a_i \\leq 10^9$)\u00a0\u2014 elements of array $a$.\n    \n    \n    -----Output-----\n    \n    Print one integer\u00a0\u2014 the answer to the problem, modulo $998244353$.\n    \n    \n    -----Examples-----\n    Input\n    1\n    1 4\n    \n    Output\n    6\n    Input\n    2\n    2 1 2 1\n    \n    Output\n    12\n    Input\n    3\n    2 2 2 2 2 2\n    \n    Output\n    0\n    Input\n    5\n    13 8 35 94 9284 34 54 69 123 846\n    \n    Output\n    2588544\n    \n    \n    -----Note-----\n    \n    Two partitions of an array are considered different if the sets of indices of elements included in the subsequence $p$ are different.\n    \n    In the first example, there are two correct partitions of the array $a$:  $p = [1]$, $q = [4]$, then $x = [1]$, $y = [4]$, $f(p, q) = |1 - 4| = 3$;  $p = [4]$, $q = [1]$, then $x = [4]$, $y = [1]$, $f(p, q) = |4 - 1| = 3$.\n    \n    In the second example, there are six valid partitions of the array $a$:   $p = [2, 1]$, $q = [2, 1]$ (elements with indices $1$ and $2$ in the original array are selected in the subsequence $p$);  $p = [2, 2]$, $q = [1, 1]$;  $p = [2, 1]$, $q = [1, 2]$ (elements with indices $1$ and $4$ are selected in the subsequence $p$);  $p = [1, 2]$, $q = [2, 1]$;  $p = [1, 1]$, $q = [2, 2]$;  $p = [2, 1]$, $q = [2, 1]$ (elements with indices $3$ and $4$ are selected in the subsequence $p$).\n    \"\"\"\n", "entry_point": "partition_sum", "test": "\ndef check(candidate):\n    assert candidate(1, [1, 4]) == 6\n    assert candidate(2, [2, 1, 2, 1]) == 12\n    assert candidate(3, [2, 2, 2, 2, 2, 2]) == 0\n    assert candidate(5, [13, 8, 35, 94, 9284, 34, 54, 69, 123, 846]) == 2588544\n    assert candidate(1, [2, 5]) == 6\n    assert candidate(7, [2, 5, 6, 25, 22, 21, 7, 9, 7, 22, 25, 25, 22, 24]) == 370656\n    assert candidate(5, [2, 7, 14, 11, 14, 15, 3, 11, 7, 16]) == 10080\n    assert candidate(4, [4, 9, 5, 13, 5, 6, 5, 13]) == 1540\n    assert candidate(10, [1, 1, 1, 1, 1, 1, 1, 1, 1, 1, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000, 1000000000]) == 365420863\n    assert candidate(16, [998244362, 998244362, 998244362, 998244362, 998244362, 998244362, 998244362, 998244362, 998244362, 998244362, 998244362, 998244362, 998244362, 998244362, 998244362, 998244362, 998244363, 998244363, 998244363, 998244363, 998244363, 998244363, 998244363, 998244363, 998244363, 998244363, 998244363, 998244363, 998244363, 998244363, 998244363, 998244363]) == 633087063\ncheck(partition_sum)\n", "given_tests": ["assert partition_sum(1, [1, 4]) == 6", "assert partition_sum(2, [2, 1, 2, 1]) == 12", "assert partition_sum(3, [2, 2, 2, 2, 2, 2]) == 0", "assert partition_sum(5, [13, 8, 35, 94, 9284, 34, 54, 69, 123, 846]) == 2588544"], "canonical_solution": "[\"import sys\\nfrom sys import stdin\\n\\ndef modfac(n, MOD):\\n \\n    f = 1\\n    factorials = [1]\\n    for m in range(1, n + 1):\\n        f *= m\\n        f %= MOD\\n        factorials.append(f)\\n    inv = pow(f, MOD - 2, MOD)\\n    invs = [1] * (n + 1)\\n    invs[n] = inv\\n    for m in range(n, 1, -1):\\n        inv *= m\\n        inv %= MOD\\n        invs[m - 1] = inv\\n    return factorials, invs\\n\\n\\ndef modnCr(n,r,mod,fac,inv): \\n    return fac[n] * inv[n-r] * inv[r] % mod\\n\\nmod = 998244353\\n\\nn = int(stdin.readline())\\na = list(map(int,stdin.readline().split()))\\na.sort()\\nfac,inv = modfac(2*n+10,mod)\\n\\nprint( (modnCr(2*n,n,mod,fac,inv) * (sum(a[n:]) - sum(a[:n]))) % mod )\\n\", \"n = int(input())\\nl = sorted(map(int, input().split()))\\ntot = sum(l[n:]) - sum(l[:n])\\nMOD = 998244353\\nfact = [1]\\nfor i in range(1, 2 * n + 1):\\n    fact.append((fact[-1] * i) % MOD)\\ntot *= fact[2 * n]\\ninv = pow(fact[n], MOD-3, MOD)\\ntot *= inv\\ntot %= MOD\\ninv *= pow(fact[n], MOD-2, MOD)\\ntot %= MOD\\nprint(tot % MOD)\", \"import sys\\ninput = sys.stdin.readline\\nmod=998244353\\nn=int(input())\\na=list(map(int,input().split()))\\na.sort()\\nval=0\\nfor i in range(n):\\n    val+=a[-i-1]\\n    val-=a[i]\\nfacs=[1]\\nfor i in range(2*n):\\n    facs.append((facs[-1]*(i+1))%mod)\\nnumb=facs[2*n]\\nnumb*=pow(facs[n]**2,mod-2,mod)\\nnumb*=val\\nnumb%=mod\\nprint(numb)\", \"import sys\\nreadline = sys.stdin.readline\\n\\nMOD = 998244353\\ndef make_fac(limit):\\n    fac = [1]*limit\\n    for i in range(2,limit):\\n        fac[i] = i * fac[i-1]%MOD\\n    faci = [0]*limit\\n    faci[-1] = pow(fac[-1], MOD -2, MOD)\\n    for i in range(limit-2, 0, -1):\\n        faci[i] = faci[i+1] * (i + 1) % MOD\\n    return fac, faci\\nfac, faci = make_fac(341398)\\ndef comb(a, b):\\n    if not a >= b >= 0:\\n        return 0\\n    return fac[a]*faci[b]*faci[a-b]%MOD\\nN = int(readline())\\nA = list(map(int, readline().split()))\\n\\nA.sort()\\nprint((sum(A[N:]) -  sum(A[:N]))%MOD*comb(2*N, N)%MOD)\"]", "difficulty": "competition"}
{"task_id": "APPS/2078", "prompt": "def minimal_coins(n: int, a: str, b: str) -> List[Union[int, Tuple[int, int]]]:\n    \"\"\"\n    One player came to a casino and found a slot machine where everything depends only on how he plays. The rules follow.\n    \n    A positive integer $a$ is initially on the screen. The player can put a coin into the machine and then add $1$ to or subtract $1$ from any two adjacent digits. All digits must remain from $0$ to $9$ after this operation, and the leading digit must not equal zero. In other words, it is forbidden to add $1$ to $9$, to subtract $1$ from $0$ and to subtract $1$ from the leading $1$. Once the number on the screen becomes equal to $b$, the player wins the jackpot. $a$ and $b$ have the same number of digits.\n    \n    Help the player to determine the minimal number of coins he needs to spend in order to win the jackpot and tell how to play.\n    \n    \n    -----Input-----\n    \n    The first line contains a single integer $n$ ($2 \\le n \\le 10^5$) standing for the length of numbers $a$ and $b$.\n    \n    The next two lines contain numbers $a$ and $b$, each one on a separate line ($10^{n-1} \\le a, b < 10^n$).\n    \n    \n    -----Output-----\n    \n    If it is impossible to win the jackpot, print a single integer $-1$.\n    \n    Otherwise, the first line must contain the minimal possible number $c$ of coins the player has to spend.\n    \n    $\\min(c, 10^5)$ lines should follow, $i$-th of them containing two integers $d_i$ and $s_i$ ($1\\le d_i\\le n - 1$, $s_i = \\pm 1$) denoting that on the $i$-th step the player should add $s_i$ to the $d_i$-th and $(d_i + 1)$-st digits from the left (e. g. $d_i = 1$ means that two leading digits change while $d_i = n - 1$ means that there are two trailing digits which change).\n    \n    Please notice that the answer may be very big and in case $c > 10^5$ you should print only the first $10^5$ moves. Your answer is considered correct if it is possible to finish your printed moves to win the jackpot in the minimal possible number of coins. In particular, if there are multiple ways to do this, you can output any of them.\n    \n    \n    -----Examples-----\n    Input\n    3\n    223\n    322\n    \n    Output\n    2\n    1 1\n    2 -1\n    \n    Input\n    2\n    20\n    42\n    \n    Output\n    2\n    1 1\n    1 1\n    \n    Input\n    2\n    35\n    44\n    \n    Output\n    -1\n    \n    \n    \n    -----Note-----\n    \n    In the first example, we can make a +1 operation on the two first digits, transforming number $\\textbf{22}3$ into $\\textbf{33}3$, and then make a -1 operation on the last two digits, transforming $3\\textbf{33}$ into $3\\textbf{22}$.\n    \n    It's also possible to do these operations in reverse order, which makes another correct answer.\n    \n    In the last example, one can show that it's impossible to transform $35$ into $44$.\n    \"\"\"\n", "entry_point": "minimal_coins", "test": "\ndef check(candidate):\n    assert candidate(3, '223', '322') == [2, (1, 1), (2, -1)]\n    assert candidate(2, '20', '42') == [2, (1, 1), (1, 1)]\n    assert candidate(2, '35', '44') == [-1]\n    assert candidate(2, '99', '11') == [8, (1, -1), (1, -1), (1, -1), (1, -1), (1, -1), (1, -1), (1, -1), (1, -1)]\n    assert candidate(2, '85', '96') == [1, (1, 1)]\n    assert candidate(2, '37', '97') == [-1]\n    assert candidate(28, '1467667189658578897086606309', '4558932538274887201553067079') == [-1]\n    assert candidate(4, '7972', '7092') == [-1]\n    assert candidate(100, '8089764625697650091223132375349870611728630464931601901362210777083214671357960568717257055725808124', '9512358653418449264455421855641556162252709608519133283842896597058892151122487184664631033189307143') == [-1]\n    assert candidate(100, '9953193386677068656613259318876668712379728264442641118985565124997863365094967466749358773230804023', '8091280541105944531036832503933946712379728264442641118985565124997863365094967466749358285078040833') == [-1]\n    assert candidate(2, '28', '94') == [-1]\n    assert candidate(72, '965163527472953255338345764036476021934360945764464062344647103353749065', '372568474736462416171613673826141727582556693945162947273839050948355408') == [-1]\n    assert candidate(100, '2908390908193827080719193819090807182908181818190719252809190619181919190829170919080919291718191927', '2817182917394829094615163908183408282718051819180808290729591738291918272728373717180807070717070838') == [-1]\ncheck(minimal_coins)\n", "given_tests": ["assert minimal_coins(3, '223', '322') == [2, (1, 1), (2, -1)]", "assert minimal_coins(2, '20', '42') == [2, (1, 1), (1, 1)]", "assert minimal_coins(2, '35', '44') == [-1]"], "canonical_solution": "[\"def main():\\n    n = int(input())\\n    a = list(map(int, (x for x in input())))\\n    b = list(map(int, (x for x in input())))\\n    x = [0] * (n - 1)\\n    x[0] = b[0] - a[0]\\n    for i in range(1, n - 1):\\n        x[i] = b[i] - a[i] - x[i - 1]\\n    if a[n - 1] + x[n - 2] != b[n - 1]:\\n        print(-1)\\n        return\\n    cnt = sum(map(abs, x))  # prevbug: ftl\\n    print(cnt)\\n    cnt = min(cnt, 10 ** 5)\\n    index = 0\\n\\n    def handle_zero_nine(cur_zero):\\n        nonlocal cnt\\n        nxt = index + 1\\n        # cur_zero = True prevbug: preserved this line\\n        while True:\\n            if cur_zero and a[nxt + 1] != 9:\\n                break\\n            if not cur_zero and a[nxt + 1] != 0:\\n                break\\n            nxt += 1\\n            cur_zero = not cur_zero\\n        while nxt > index:\\n            if cnt == 0:\\n                break\\n            if cur_zero:\\n                print(nxt + 1, 1)\\n                a[nxt] += 1\\n                a[nxt + 1] += 1\\n            else:\\n                print(nxt + 1, -1)\\n                a[nxt] -= 1\\n                a[nxt + 1] -= 1\\n            nxt -= 1\\n            cnt -= 1\\n            # print(a)\\n            cur_zero = not cur_zero\\n\\n    while cnt > 0:\\n        if a[index] == b[index]:\\n            index += 1\\n            continue\\n        elif a[index] > b[index] and a[index + 1] == 0:\\n            handle_zero_nine(True)\\n        elif a[index] < b[index] and a[index + 1] == 9:\\n            handle_zero_nine(False)\\n        elif a[index] > b[index]:\\n            print(index + 1, -1)\\n            a[index] -= 1\\n            a[index + 1] -= 1\\n            cnt -= 1\\n            # print(a)\\n        elif a[index] < b[index]:\\n            print(index + 1, 1)\\n            a[index] += 1\\n            a[index + 1] += 1\\n            cnt -= 1\\n            # print(a)\\n\\n\\ndef __starting_point():\\n    main()\\n\\n__starting_point()\"]", "difficulty": "competition"}
{"task_id": "APPS/2259", "prompt": "def weight_of_array(n: int, q: int, a: List[int], queries: List[Tuple[int, int]]) -> List[int]:\n    \"\"\"\n    Let $a_1, \\ldots, a_n$ be an array of $n$ positive integers. In one operation, you can choose an index $i$ such that $a_i = i$, and remove $a_i$ from the array (after the removal, the remaining parts are concatenated).\n    \n    The weight of $a$ is defined as the maximum number of elements you can remove.\n    \n    You must answer $q$ independent queries $(x, y)$: after replacing the $x$ first elements of $a$ and the $y$ last elements of $a$ by $n+1$ (making them impossible to remove), what would be the weight of $a$?\n    \n    \n    -----Input-----\n    \n    The first line contains two integers $n$ and $q$ ($1 \\le n, q \\le 3 \\cdot 10^5$) \u00a0\u2014 the length of the array and the number of queries.\n    \n    The second line contains $n$ integers $a_1$, $a_2$, ..., $a_n$ ($1 \\leq a_i \\leq n$)\u00a0\u2014 elements of the array.\n    \n    The $i$-th of the next $q$ lines contains two integers $x$ and $y$ ($x, y \\ge 0$ and $x+y < n$).\n    \n    \n    -----Output-----\n    \n    Print $q$ lines, $i$-th line should contain a single integer \u00a0\u2014 the answer to the $i$-th query.\n    \n    \n    -----Examples-----\n    Input\n    13 5\n    2 2 3 9 5 4 6 5 7 8 3 11 13\n    3 1\n    0 0\n    2 4\n    5 0\n    0 12\n    \n    Output\n    5\n    11\n    6\n    1\n    0\n    \n    Input\n    5 2\n    1 4 1 2 4\n    0 0\n    1 0\n    \n    Output\n    2\n    0\n    \n    \n    \n    -----Note-----\n    \n    Explanation of the first query:\n    \n    After making first $x = 3$ and last $y = 1$ elements impossible to remove, $a$ becomes $[\\times, \\times, \\times, 9, 5, 4, 6, 5, 7, 8, 3, 11, \\times]$ (we represent $14$ as $\\times$ for clarity).\n    \n    Here is a strategy that removes $5$ elements (the element removed is colored in red):  $[\\times, \\times, \\times, 9, \\color{red}{5}, 4, 6, 5, 7, 8, 3, 11, \\times]$  $[\\times, \\times, \\times, 9, 4, 6, 5, 7, 8, 3, \\color{red}{11}, \\times]$  $[\\times, \\times, \\times, 9, 4, \\color{red}{6}, 5, 7, 8, 3, \\times]$  $[\\times, \\times, \\times, 9, 4, 5, 7, \\color{red}{8}, 3, \\times]$  $[\\times, \\times, \\times, 9, 4, 5, \\color{red}{7}, 3, \\times]$  $[\\times, \\times, \\times, 9, 4, 5, 3, \\times]$ (final state)\n    \n    It is impossible to remove more than $5$ elements, hence the weight is $5$.\n    \"\"\"\n", "entry_point": "weight_of_array", "test": "\ndef check(candidate):\n    assert candidate(13, 5, [2, 2, 3, 9, 5, 4, 6, 5, 7, 8, 3, 11, 13], [(3, 1), (0, 0), (2, 4), (5, 0), (0, 12)]) == [5, 11, 6, 1, 0]\n    assert candidate(5, 2, [1, 4, 1, 2, 4], [(0, 0), (1, 0)]) == [2, 0]\n    assert candidate(1, 1, [1], [(0, 0)]) == [1]\n    assert candidate(30, 10, [1, 1, 3, 3, 5, 2, 1, 8, 2, 6, 11, 5, 2, 6, 12, 11, 8, 5, 11, 3, 14, 8, 16, 13, 14, 25, 16, 2, 8, 17], [(6, 3), (0, 15), (1, 0), (9, 2), (12, 16), (1, 0), (17, 3), (14, 13), (0, 22), (3, 10)]) == [3, 15, 16, 2, 0, 16, 0, 0, 8, 4]\ncheck(weight_of_array)\n", "given_tests": ["assert weight_of_array(13, 5, [2, 2, 3, 9, 5, 4, 6, 5, 7, 8, 3, 11, 13], [(3, 1), (0, 0), (2, 4), (5, 0), (0, 12)]) == [5, 11, 6, 1, 0]", "assert weight_of_array(5, 2, [1, 4, 1, 2, 4], [(0, 0), (1, 0)]) == [2, 0]"], "canonical_solution": "[\"from sys import stdin\\n\\ndef bitadd(a,w,bit):\\n \\n    x = a\\n    while x <= (len(bit)-1):\\n        bit[x] += w\\n        x += x & (-1 * x)\\n \\ndef bitsum(a,bit):\\n \\n    ret = 0\\n    x = a\\n    while x > 0:\\n        ret += bit[x]\\n        x -= x & (-1 * x)\\n    return ret\\n\\nclass RangeBIT:\\n\\n    def __init__(self,N,indexed):\\n        self.bit1 = [0] * (N+2)\\n        self.bit2 = [0] * (N+2)\\n        self.mode = indexed\\n\\n    def bitadd(self,a,w,bit):\\n \\n        x = a\\n        while x <= (len(bit)-1):\\n            bit[x] += w\\n            x += x & (-1 * x)\\n \\n    def bitsum(self,a,bit):\\n \\n        ret = 0\\n        x = a\\n        while x > 0:\\n            ret += bit[x]\\n            x -= x & (-1 * x)\\n        return ret\\n    \\n    def add(self,l,r,w):\\n\\n        l = l + (1-self.mode)\\n        r = r + (1-self.mode)\\n        self.bitadd(l,-1*w*l,self.bit1)\\n        self.bitadd(r,w*r,self.bit1)\\n        self.bitadd(l,w,self.bit2)\\n        self.bitadd(r,-1*w,self.bit2)\\n\\n    def sum(self,l,r):\\n        l = l + (1-self.mode)\\n        r = r + (1-self.mode)\\n        ret =  self.bitsum(r,self.bit1) + r * self.bitsum(r,self.bit2)\\n        ret -= self.bitsum(l,self.bit1) + l * self.bitsum(l,self.bit2)\\n\\n        return ret\\n\\nn,q = list(map(int,stdin.readline().split()))\\na = list(map(int,stdin.readline().split()))\\n\\nqs = [ [] for i in range(n+1) ]\\nans = [None] * q\\n\\nfor loop in range(q):\\n    x,y = list(map(int,stdin.readline().split()))\\n    l = x+1\\n    r = n-y\\n    qs[r].append((l,loop))\\n\\nBIT = [0] * (n+1)\\n\\nfor r in range(1,n+1):\\n\\n    b = r-a[r-1]\\n\\n    if b >= 0:\\n\\n        L = 1\\n        R = r+1\\n        while R-L != 1:\\n            M = (L+R)//2\\n\\n            if bitsum(M,BIT) >= b:\\n                L = M\\n            else:\\n                R = M\\n\\n        if bitsum(L,BIT) >= b:\\n            bitadd(1,1,BIT)\\n            bitadd(L+1,-1,BIT)\\n\\n\\n    for ql,qind in qs[r]:\\n        ans[qind] = bitsum(ql,BIT)\\n\\nfor i in ans:\\n    print (i)\\n\"]", "difficulty": "competition"}
{"task_id": "APPS/2082", "prompt": "def expected_game_duration(n: int, a: List[int]) -> int:\n    \"\"\"\n    Slime and his $n$ friends are at a party. Slime has designed a game for his friends to play.\n    \n    At the beginning of the game, the $i$-th player has $a_i$ biscuits. At each second, Slime will choose a biscuit randomly uniformly among all $a_1 + a_2 + \\ldots + a_n$ biscuits, and the owner of this biscuit will give it to a random uniform player among $n-1$ players except himself. The game stops when one person will have all the biscuits.\n    \n    As the host of the party, Slime wants to know the expected value of the time that the game will last, to hold the next activity on time.\n    \n    For convenience, as the answer can be represented as a rational number $\\frac{p}{q}$ for coprime $p$ and $q$, you need to find the value of $(p \\cdot q^{-1})\\mod 998\\,244\\,353$. You can prove that $q\\mod 998\\,244\\,353 \\neq 0$.\n    \n    \n    -----Input-----\n    \n    The first line contains one integer $n\\ (2\\le n\\le 100\\,000)$: the number of people playing the game.\n    \n    The second line contains $n$ non-negative integers $a_1,a_2,\\dots,a_n\\ (1\\le a_1+a_2+\\dots+a_n\\le 300\\,000)$, where $a_i$ represents the number of biscuits the $i$-th person own at the beginning.\n    \n    \n    -----Output-----\n    \n    Print one integer: the expected value of the time that the game will last, modulo $998\\,244\\,353$.\n    \n    \n    -----Examples-----\n    Input\n    2\n    1 1\n    \n    Output\n    1\n    \n    Input\n    2\n    1 2\n    \n    Output\n    3\n    \n    Input\n    5\n    0 0 0 0 35\n    \n    Output\n    0\n    \n    Input\n    5\n    8 4 2 0 1\n    \n    Output\n    801604029\n    \n    \n    \n    -----Note-----\n    \n    For the first example, in the first second, the probability that player $1$ will give the player $2$ a biscuit is $\\frac{1}{2}$, and the probability that player $2$ will give the player $1$ a biscuit is $\\frac{1}{2}$. But anyway, the game will stop after exactly $1$ second because only one player will occupy all biscuits after $1$ second, so the answer is $1$.\n    \"\"\"\n", "entry_point": "expected_game_duration", "test": "\ndef check(candidate):\n    assert candidate(2, [1, 1]) == 1\n    assert candidate(2, [1, 2]) == 3\n    assert candidate(5, [0, 0, 0, 0, 35]) == 0\n    assert candidate(5, [8, 4, 2, 0, 1]) == 801604029\n    assert candidate(5, [24348, 15401, 19543, 206086, 34622]) == 788526601\n    assert candidate(10, [7758, 19921, 15137, 1138, 90104, 17467, 82544, 55151, 3999, 6781]) == 663099907\n    assert candidate(2, [0, 1]) == 0\n    assert candidate(2, [184931, 115069]) == 244559876\n    assert candidate(100, [9, 0, 2, 8, 3, 6, 55, 1, 11, 12, 3, 8, 32, 18, 38, 16, 0, 27, 6, 3, 3, 4, 25, 2, 0, 0, 7, 3, 6, 16, 10, 26, 5, 4, 2, 38, 13, 1, 7, 4, 14, 8, 1, 9, 5, 26, 4, 8, 1, 11, 3, 4, 18, 2, 6, 11, 5, 6, 13, 9, 1, 1, 1, 2, 27, 0, 25, 3, 2, 6, 9, 5, 3, 17, 17, 2, 5, 1, 15, 41, 2, 2, 4, 4, 22, 64, 10, 31, 17, 7, 0, 0, 3, 5, 17, 20, 5, 1, 1, 4]) == 241327503\n    assert candidate(100, [4364, 698, 1003, 1128, 1513, 39, 4339, 969, 7452, 3415, 1154, 1635, 6649, 136, 1442, 50, 834, 1680, 107, 978, 983, 3176, 4017, 1692, 1113, 1504, 1118, 396, 1975, 2053, 2366, 3022, 3007, 167, 610, 4649, 14659, 2331, 4565, 318, 7232, 204, 7131, 6122, 2885, 5748, 1998, 3833, 6799, 4219, 8454, 8698, 4964, 1736, 1554, 1665, 2425, 4227, 1967, 534, 2719, 80, 2865, 652, 1920, 1577, 658, 1165, 3222, 1222, 1238, 560, 12018, 768, 7144, 2701, 501, 2520, 9194, 8052, 13092, 7366, 2733, 6050, 2914, 1740, 5467, 546, 2947, 186, 1789, 2658, 2150, 19, 1854, 1489, 7590, 990, 296, 1647]) == 301328767\n    assert candidate(2, [300000, 0]) == 0\n    assert candidate(36, [110, 7, 51, 3, 36, 69, 30, 7, 122, 22, 11, 96, 98, 17, 133, 44, 38, 75, 7, 10, 4, 3, 68, 50, 43, 25, 4, 29, 42, 36, 11, 7, 36, 12, 75, 1]) == 420723999\n    assert candidate(39, [79, 194, 29, 36, 51, 363, 57, 446, 559, 28, 41, 34, 98, 168, 555, 26, 111, 97, 167, 121, 749, 21, 719, 20, 207, 217, 226, 63, 168, 248, 478, 1231, 399, 518, 291, 14, 741, 149, 97]) == 918301015\ncheck(expected_game_duration)\n", "given_tests": ["assert expected_game_duration(2, [1, 1]) == 1", "assert expected_game_duration(2, [1, 2]) == 3", "assert expected_game_duration(5, [0, 0, 0, 0, 35]) == 0", "assert expected_game_duration(5, [8, 4, 2, 0, 1]) == 801604029"], "canonical_solution": "[\"MOD = 998244353\\n\\nn = int(input())\\n\\na = list(map(int, input().split()))\\ntot = sum(a)\\n\\ndef inv(x):\\n    return pow(x, MOD - 2, MOD)\\n\\nl = [0, pow(n, tot, MOD) - 1]\\n\\nfor i in range(1, tot):\\n    aC = i\\n    cC = (n - 1) * (tot - i)\\n    curr = (aC + cC) * l[-1]\\n    curr -= tot * (n - 1)\\n    curr -= aC * l[-2]\\n    curr *= inv(cC)\\n    curr %= MOD\\n    l.append(curr)\\n\\nout = 0\\nfor v in a:\\n    out += l[tot - v]\\n    out %= MOD\\n\\nzero = l[tot]\\nout -= (n - 1) * zero\\nout *= inv(n)\\nprint(out % MOD)\\n\", \"import sys\\n\\ndef II(): return int(sys.stdin.readline())\\ndef LI(): return list(map(int, sys.stdin.readline().split()))\\n\\nclass mint:\\n    def __init__(self, x):\\n        self.__x = x % md\\n\\n    def __repr__(self):\\n        return str(self.__x)\\n\\n    def __neg__(self):\\n        return mint(-self.__x)\\n\\n    def __add__(self, other):\\n        if isinstance(other, mint): other = other.__x\\n        return mint(self.__x + other)\\n\\n    def __sub__(self, other):\\n        if isinstance(other, mint): other = other.__x\\n        return mint(self.__x - other)\\n\\n    def __rsub__(self, other):\\n        return mint(other - self.__x)\\n\\n    def __mul__(self, other):\\n        if isinstance(other, mint): other = other.__x\\n        return mint(self.__x * other)\\n\\n    __radd__ = __add__\\n    __rmul__ = __mul__\\n\\n    def __truediv__(self, other):\\n        if isinstance(other, mint): other = other.__x\\n        return mint(self.__x * pow(other, md - 2, md))\\n\\n    def __rtruediv__(self, other):\\n        return mint(other * pow(self.__x, md - 2, md))\\n\\n    def __pow__(self, power, modulo=None):\\n        return mint(pow(self.__x, power, md))\\n\\nmd = 998244353\\n\\ndef main():\\n    n=II()\\n    aa=LI()\\n    sa=sum(aa)\\n    # dp[i]...ev from i-1 to i\\n    dp=[mint(0)]*(sa+1)\\n    for i in range(1,sa+1):\\n        dp[i]=((i-1)*dp[i-1]+sa)*(n-1)/(sa+1-i)\\n    #print(*dp)\\n\\n    for i in range(sa):dp[i+1]+=dp[i]\\n\\n    ans=-(n-1)*dp[-1]\\n    for a in aa:ans+=dp[sa]-dp[a]\\n    print(ans/n)\\n\\nmain()\"]", "difficulty": "competition"}
{"task_id": "APPS/2251", "prompt": "def dangerous_triples(n: int, m: int, dislikes: List[Tuple[int, int]], q: int, revisions: List[int]) -> List[int]:\n    \"\"\"\n    Konrad is a Human Relations consultant working for VoltModder, a large electrical equipment producer. Today, he has been tasked with evaluating the level of happiness in the company.\n    \n    There are $n$ people working for VoltModder, numbered from $1$ to $n$. Each employee earns a different amount of money in the company \u2014 initially, the $i$-th person earns $i$ rubles per day.\n    \n    On each of $q$ following days, the salaries will be revised. At the end of the $i$-th day, employee $v_i$ will start earning $n+i$ rubles per day and will become the best-paid person in the company. The employee will keep his new salary until it gets revised again.\n    \n    Some pairs of people don't like each other. This creates a great psychological danger in the company. Formally, if two people $a$ and $b$ dislike each other and $a$ earns more money than $b$, employee $a$ will brag about this to $b$. A dangerous triple is a triple of three employees $a$, $b$ and $c$, such that $a$ brags to $b$, who in turn brags to $c$. If $a$ dislikes $b$, then $b$ dislikes $a$.\n    \n    At the beginning of each day, Konrad needs to evaluate the number of dangerous triples in the company. Can you help him do it?\n    \n    \n    -----Input-----\n    \n    The first line contains two integers $n$ and $m$ ($1 \\le n \\le 100\\,000$, $0 \\le m \\le 100\\,000$) \u2014 the number of employees in the company and the number of pairs of people who don't like each other. Each of the following $m$ lines contains two integers $a_i$, $b_i$ ($1 \\le a_i, b_i \\le n$, $a_i \\neq b_i$) denoting that employees $a_i$ and $b_i$ hate each other (that is, $a_i$ dislikes $b_i$ and $b_i$ dislikes $a_i$). Each such relationship will be mentioned exactly once.\n    \n    The next line contains an integer $q$ ($0 \\le q \\le 100\\,000$) \u2014 the number of salary revisions. The $i$-th of the following $q$ lines contains a single integer $v_i$ ($1 \\le v_i \\le n$) denoting that at the end of the $i$-th day, employee $v_i$ will earn the most.\n    \n    \n    -----Output-----\n    \n    Output $q + 1$ integers. The $i$-th of them should contain the number of dangerous triples in the company at the beginning of the $i$-th day.\n    \n    \n    -----Examples-----\n    Input\n    4 5\n    1 2\n    2 4\n    1 3\n    3 4\n    2 3\n    2\n    2\n    3\n    \n    Output\n    4\n    3\n    2\n    \n    Input\n    3 3\n    1 2\n    2 3\n    1 3\n    5\n    1\n    2\n    2\n    1\n    3\n    \n    Output\n    1\n    1\n    1\n    1\n    1\n    1\n    \n    \n    \n    -----Note-----\n    \n    Consider the first sample test. The $i$-th row in the following image shows the structure of the company at the beginning of the $i$-th day. A directed edge from $a$ to $b$ denotes that employee $a$ brags to employee $b$. The dangerous triples are marked by highlighted edges. [Image]\n    \"\"\"\n", "entry_point": "dangerous_triples", "test": "\ndef check(candidate):\n    assert candidate(4, 5, [(1, 2), (2, 4), (1, 3), (3, 4), (2, 3)], 2, [2, 3]) == [4, 3, 2]\n    assert candidate(3, 3, [(1, 2), (2, 3), (1, 3)], 5, [1, 2, 2, 1, 3]) == [1, 1, 1, 1, 1, 1]\n    assert candidate(1, 0, [], 0, []) == [0]\n    assert candidate(10, 20, [(9, 1), (5, 3), (7, 9), (1, 8), (10, 7), (9, 5), (5, 7), (6, 5), (10, 9), (6, 4), (8, 7), (7, 6), (2, 3), (4, 5), (10, 1), (1, 4), (1, 2), (5, 1), (5, 10), (1, 7)], 40, [6, 9, 10, 4, 1, 3, 9, 4, 9, 4, 3, 7, 6, 4, 7, 2, 4, 2, 5, 3, 4, 3, 8, 7, 7, 2, 8, 3, 4, 4, 6, 4, 5, 10, 9, 3, 9, 5, 6, 7]) == [30, 27, 27, 27, 25, 24, 17, 20, 22, 22, 22, 22, 20, 25, 25, 20, 21, 21, 21, 21, 28, 30, 30, 29, 24, 24, 24, 28, 28, 28, 28, 33, 33, 25, 23, 24, 25, 25, 18, 22, 24]\ncheck(dangerous_triples)\n", "given_tests": ["assert dangerous_triples(4, 5, [(1, 2), (2, 4), (1, 3), (3, 4), (2, 3)], 2, [2, 3]) == [4, 3, 2]", "assert dangerous_triples(3, 3, [(1, 2), (2, 3), (1, 3)], 5, [1, 2, 2, 1, 3]) == [1, 1, 1, 1, 1, 1]"], "canonical_solution": "[\"import sys\\n\\nn, m = list(map(int, sys.stdin.readline().strip().split()))\\nL = [0 for i in range (0, n)]\\nH = [[] for i in range (0, n)]\\nfor i in range (0, m):\\n    x, y = list(map(int, sys.stdin.readline().strip().split()))\\n    x = x - 1\\n    y = y - 1\\n    if x > y:\\n        x, y = y, x\\n    L[y] = L[y] + 1\\n    H[x].append(y)\\nans = 0\\nfor i in range (0, n):\\n    ans = ans + L[i] * len(H[i])\\nprint(ans)\\nq = int(sys.stdin.readline().strip())\\nfor i in range (0, q):\\n    v = int(sys.stdin.readline().strip()) - 1\\n    ans = ans - L[v] * len(H[v])\\n    L[v] = L[v] + len(H[v])\\n    while len(H[v]) > 0:\\n        w = H[v].pop()\\n        H[w].append(v)\\n        L[w] = L[w] - 1\\n        ans = ans + L[w] - len(H[w]) + 1\\n    print(ans)\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nn,m=list(map(int,input().split()))\\n\\nIN=[0]*n\\nOUT=[0]*n\\n\\nINSET=[[] for i in range(n)]\\n\\nfor i in range(m):\\n    x,y=sorted(map(int,input().split()))\\n\\n    IN[x-1]+=1\\n    OUT[y-1]+=1\\n    INSET[x-1].append(y-1)\\n\\nANS=0\\nfor i in range(n):\\n    ANS+=IN[i]*OUT[i]\\n\\nprint(ANS)\\n\\nQ=int(input())\\n\\nfor i in range(Q):\\n    q=int(input())-1\\n    ANS-=IN[q]*OUT[q]\\n    OUT[q]+=IN[q]\\n    IN[q]=0\\n\\n    for x in INSET[q]:\\n        INSET[x].append(q)\\n        ANS+=(IN[x]+1)*(OUT[x]-1)-IN[x]*OUT[x]\\n        IN[x]+=1\\n        OUT[x]-=1\\n\\n    INSET[q]=[]\\n\\n    print(ANS)\\n\", \"n, m = map(int, input().split())\\nout, inp =[0]*(n+1), [0]*(n+1)\\ninset = [[] for i in range(n+1)]\\n\\nfor i in range(m):\\n    x, y = map(int, input().split())\\n    \\n    if x > y:\\n        z = x\\n        x = y\\n        y = z\\n    \\n    out[y] += 1\\n    inp[x] += 1\\n    inset[x].append(y)\\n\\nq = int(input())\\n\\nres = 0\\nfor ind in range(1, n+1):\\n    res += inp[ind] * out[ind]\\n\\nprint(res)\\nfor i in range(q):\\n    best = int(input())\\n    \\n    res -= out[best] * inp[best]\\n    for pred_ind in inset[best]:\\n        res += -out[pred_ind] * inp[pred_ind] + ((out[pred_ind] - 1) * (inp[pred_ind] + 1))\\n        out[pred_ind] -= 1\\n        inp[pred_ind] += 1\\n        inset[pred_ind].append(best)\\n    \\n    \\n    out[best] += inp[best]\\n    inp[best] = 0\\n    inset[best] = []\\n    \\n    print(res)\"]", "difficulty": "competition"}
{"task_id": "APPS/2284", "prompt": "def check_reducible_anagrams(s: str, q: int, queries: List[Tuple[int, int]]) -> List[str]:\n    \"\"\"\n    Let's call two strings $s$ and $t$ anagrams of each other if it is possible to rearrange symbols in the string $s$ to get a string, equal to $t$.\n    \n    Let's consider two strings $s$ and $t$ which are anagrams of each other. We say that $t$ is a reducible anagram of $s$ if there exists an integer $k \\ge 2$ and $2k$ non-empty strings $s_1, t_1, s_2, t_2, \\dots, s_k, t_k$ that satisfy the following conditions:\n    \n    If we write the strings $s_1, s_2, \\dots, s_k$ in order, the resulting string will be equal to $s$;  If we write the strings $t_1, t_2, \\dots, t_k$ in order, the resulting string will be equal to $t$;  For all integers $i$ between $1$ and $k$ inclusive, $s_i$ and $t_i$ are anagrams of each other.\n    \n    If such strings don't exist, then $t$ is said to be an irreducible anagram of $s$. Note that these notions are only defined when $s$ and $t$ are anagrams of each other.\n    \n    For example, consider the string $s = $ \"gamegame\". Then the string $t = $ \"megamage\" is a reducible anagram of $s$, we may choose for example $s_1 = $ \"game\", $s_2 = $ \"gam\", $s_3 = $ \"e\" and $t_1 = $ \"mega\", $t_2 = $ \"mag\", $t_3 = $ \"e\":\n    \n    [Image]\n    \n    On the other hand, we can prove that $t = $ \"memegaga\" is an irreducible anagram of $s$.\n    \n    You will be given a string $s$ and $q$ queries, represented by two integers $1 \\le l \\le r \\le |s|$ (where $|s|$ is equal to the length of the string $s$). For each query, you should find if the substring of $s$ formed by characters from the $l$-th to the $r$-th has at least one irreducible anagram.\n    \n    \n    -----Input-----\n    \n    The first line contains a string $s$, consisting of lowercase English characters ($1 \\le |s| \\le 2 \\cdot 10^5$).\n    \n    The second line contains a single integer $q$ ($1 \\le q \\le 10^5$) \u00a0\u2014 the number of queries.\n    \n    Each of the following $q$ lines contain two integers $l$ and $r$ ($1 \\le l \\le r \\le |s|$), representing a query for the substring of $s$ formed by characters from the $l$-th to the $r$-th.\n    \n    \n    -----Output-----\n    \n    For each query, print a single line containing \"Yes\" (without quotes) if the corresponding substring has at least one irreducible anagram, and a single line containing \"No\" (without quotes) otherwise.\n    \n    \n    -----Examples-----\n    Input\n    aaaaa\n    3\n    1 1\n    2 4\n    5 5\n    \n    Output\n    Yes\n    No\n    Yes\n    \n    Input\n    aabbbbbbc\n    6\n    1 2\n    2 4\n    2 2\n    1 9\n    5 7\n    3 5\n    \n    Output\n    No\n    Yes\n    Yes\n    Yes\n    No\n    No\n    \n    \n    \n    -----Note-----\n    \n    In the first sample, in the first and third queries, the substring is \"a\", which has itself as an irreducible anagram since two or more non-empty strings cannot be put together to obtain \"a\". On the other hand, in the second query, the substring is \"aaa\", which has no irreducible anagrams: its only anagram is itself, and we may choose $s_1 = $ \"a\", $s_2 = $ \"aa\", $t_1 = $ \"a\", $t_2 = $ \"aa\" to show that it is a reducible anagram.\n    \n    In the second query of the second sample, the substring is \"abb\", which has, for example, \"bba\" as an irreducible anagram.\n    \"\"\"\n", "entry_point": "check_reducible_anagrams", "test": "\ndef check(candidate):\n    assert candidate('aaaaa', 3, [(1, 1), (2, 4), (5, 5)]) == ['Yes', 'No', 'Yes']\n    assert candidate('aabbbbbbc', 6, [(1, 2), (2, 4), (2, 2), (1, 9), (5, 7), (3, 5)]) == ['No', 'Yes', 'Yes', 'Yes', 'No', 'No']\n    assert candidate('f', 1, [(1, 1)]) == ['Yes']\ncheck(check_reducible_anagrams)\n", "given_tests": ["assert check_reducible_anagrams('aaaaa', 3, [(1, 1), (2, 4), (5, 5)]) == ['Yes', 'No', 'Yes']", "assert check_reducible_anagrams('aabbbbbbc', 6, [(1, 2), (2, 4), (2, 2), (1, 9), (5, 7), (3, 5)]) == ['No', 'Yes', 'Yes', 'Yes', 'No', 'No']"], "canonical_solution": "[\"import sys\\nreadline = sys.stdin.readline\\n\\nS = list([ord(x)-97 for x in readline().strip()])\\nN = len(S)\\ntable = [[0]*26 for _ in range(N)]\\nfor i in range(N):\\n    table[i][S[i]] = 1\\nfor i in range(1, N):\\n    for j in range(26):\\n        table[i][j] += table[i-1][j]\\n\\nQ = int(readline())\\nAns = [None]*Q\\nfor qu in range(Q):\\n    l, r = list(map(int, readline().split()))\\n    l -= 1\\n    r -= 1 \\n    if l == r or S[l] != S[r]:\\n        Ans[qu] = True\\n        continue\\n    K = [table[r][j] - table[l][j] for j in range(26)]\\n    if len([k for k in K if k]) <= 2:\\n        Ans[qu] = False\\n    else:\\n        Ans[qu] = True\\nprint('\\\\n'.join(['Yes' if s else 'No' for s in Ans]))\\n\", \"import sys\\ninput = sys.stdin.readline\\n\\nfrom collections import Counter\\n\\nS=input().strip()\\ncount=[[0]*26 for i in range(len(S)+1)]\\nc=1\\nfor s in S:\\n    for k in range(26):\\n        count[c][k]=count[c-1][k]\\n    count[c][ord(s)-97]+=1\\n    c+=1\\n    \\nQ=int(input())\\nfor tests in range(Q):\\n    l,r=list(map(int,input().split()))\\n    if l==r:\\n        print(\\\"Yes\\\")\\n        continue\\n    \\n    elif S[l-1]!=S[r-1]:\\n        print(\\\"Yes\\\")\\n        continue\\n\\n    elif len(S)<=4:\\n        print(\\\"No\\\")\\n        continue\\n\\n    X=[count[r][j]-count[l-1][j] for j in range(26)]\\n    NZERO=0\\n    for x in X:\\n        if x!=0:\\n            NZERO+=1\\n\\n    if NZERO<=2:\\n        print(\\\"No\\\")\\n    else:\\n        print(\\\"Yes\\\")\\n\\n    \\n        \\n\", \"import sys\\ninput = sys.stdin.readline\\ns = input()\\nq = int(input())\\nquery = [tuple(map(int, input().split())) for i in range(q)]\\nchar = [[0]*26 for i in range(len(s)+1)]\\n\\nfor i in range(len(s)):\\n    si = ord(s[i])-97\\n    for j in range(26):\\n        if j == si:\\n            char[i+1][j] = char[i][j] + 1\\n        else:\\n            char[i+1][j] = char[i][j]\\n\\n\\nfor l, r in query:\\n    count = 0\\n    for i in range(26):\\n        if char[r][i] - char[l-1][i] != 0:\\n            count += 1\\n    if count == 1:\\n        if r == l:\\n            print(\\\"Yes\\\")\\n        else:\\n            print(\\\"No\\\")\\n    elif count == 2:\\n        if s[r-1] == s[l-1]:\\n            print(\\\"No\\\")\\n        else:\\n            print(\\\"Yes\\\")\\n    else:\\n        print(\\\"Yes\\\")\\n\"]", "difficulty": "competition"}